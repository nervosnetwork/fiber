
# Fiber Network Node RPC

The RPC module provides a set of APIs for developers to interact with FNN. Please note that APIs are not stable yet and may change in the future.

Allowing arbitrary machines to access the JSON-RPC port (using the `rpc.listening_addr` configuration option) is **dangerous and strongly discouraged**. Please strictly limit the access to only trusted machines.

You may refer to the e2e test cases in the `tests/bruno/e2e` directory for examples of how to use the RPC.

**We are in a actively developing stage, don't hesitate to [report issues](https://github.com/nervosnetwork/fiber/issues) or ask for help in the [channel of the Nervos dev community](https://discord.gg/c5gntbFd).**

<!--**NOTE:** the content below is generated by gen_doc -->

* [RPC Methods](#rpc-methods)


    * [Module Cch](#module-cch)
        * [Method `send_btc`](#cch-send_btc)
        * [Method `receive_btc`](#cch-receive_btc)
        * [Method `get_cch_order`](#cch-get_cch_order)
    * [Module Channel](#module-channel)
        * [Method `open_channel`](#channel-open_channel)
        * [Method `accept_channel`](#channel-accept_channel)
        * [Method `abandon_channel`](#channel-abandon_channel)
        * [Method `list_channels`](#channel-list_channels)
        * [Method `shutdown_channel`](#channel-shutdown_channel)
        * [Method `update_channel`](#channel-update_channel)
    * [Module Dev](#module-dev)
        * [Method `commitment_signed`](#dev-commitment_signed)
        * [Method `add_tlc`](#dev-add_tlc)
        * [Method `remove_tlc`](#dev-remove_tlc)
        * [Method `submit_commitment_transaction`](#dev-submit_commitment_transaction)
        * [Method `check_channel_shutdown`](#dev-check_channel_shutdown)
    * [Module Graph](#module-graph)
        * [Method `graph_nodes`](#graph-graph_nodes)
        * [Method `graph_channels`](#graph-graph_channels)
    * [Module Info](#module-info)
        * [Method `node_info`](#info-node_info)
    * [Module Invoice](#module-invoice)
        * [Method `new_invoice`](#invoice-new_invoice)
        * [Method `parse_invoice`](#invoice-parse_invoice)
        * [Method `get_invoice`](#invoice-get_invoice)
        * [Method `cancel_invoice`](#invoice-cancel_invoice)
        * [Method `settle_invoice`](#invoice-settle_invoice)
    * [Module Payment](#module-payment)
        * [Method `send_payment`](#payment-send_payment)
        * [Method `get_payment`](#payment-get_payment)
        * [Method `build_router`](#payment-build_router)
        * [Method `send_payment_with_router`](#payment-send_payment_with_router)
    * [Module Peer](#module-peer)
        * [Method `connect_peer`](#peer-connect_peer)
        * [Method `disconnect_peer`](#peer-disconnect_peer)
        * [Method `list_peers`](#peer-list_peers)
    * [Module Prof](#module-prof)
        * [Method `pprof`](#prof-pprof)
    * [Module Watchtower](#module-watchtower)
        * [Method `create_watch_channel`](#watchtower-create_watch_channel)
        * [Method `remove_watch_channel`](#watchtower-remove_watch_channel)
        * [Method `update_revocation`](#watchtower-update_revocation)
        * [Method `update_pending_remote_settlement`](#watchtower-update_pending_remote_settlement)
        * [Method `update_local_settlement`](#watchtower-update_local_settlement)
        * [Method `create_preimage`](#watchtower-create_preimage)
        * [Method `remove_preimage`](#watchtower-remove_preimage)
* [RPC Types](#rpc-types)

    * [Type `Attribute`](#type-attribute)
    * [Type `CchInvoice`](#type-cchinvoice)
    * [Type `CchOrderStatus`](#type-cchorderstatus)
    * [Type `Channel`](#type-channel)
    * [Type `ChannelInfo`](#type-channelinfo)
    * [Type `ChannelState`](#type-channelstate)
    * [Type `ChannelUpdateInfo`](#type-channelupdateinfo)
    * [Type `CkbInvoice`](#type-ckbinvoice)
    * [Type `CkbInvoiceStatus`](#type-ckbinvoicestatus)
    * [Type `Currency`](#type-currency)
    * [Type `Hash256`](#type-hash256)
    * [Type `HashAlgorithm`](#type-hashalgorithm)
    * [Type `HopHint`](#type-hophint)
    * [Type `HopRequire`](#type-hoprequire)
    * [Type `Htlc`](#type-htlc)
    * [Type `InvoiceData`](#type-invoicedata)
    * [Type `InvoiceSignature`](#type-invoicesignature)
    * [Type `NodeInfo`](#type-nodeinfo)
    * [Type `PaymentCustomRecords`](#type-paymentcustomrecords)
    * [Type `PaymentStatus`](#type-paymentstatus)
    * [Type `PeerInfo`](#type-peerinfo)
    * [Type `Privkey`](#type-privkey)
    * [Type `Pubkey`](#type-pubkey)
    * [Type `RemoveTlcReason`](#type-removetlcreason)
    * [Type `RevocationData`](#type-revocationdata)
    * [Type `RouterHop`](#type-routerhop)
    * [Type `SessionRoute`](#type-sessionroute)
    * [Type `SessionRouteNode`](#type-sessionroutenode)
    * [Type `SettlementData`](#type-settlementdata)
    * [Type `SettlementTlc`](#type-settlementtlc)
    * [Type `TLCId`](#type-tlcid)
    * [Type `TlcStatus`](#type-tlcstatus)
    * [Type `TrampolineHopParams`](#type-trampolinehopparams)
    * [Type `UdtArgInfo`](#type-udtarginfo)
    * [Type `UdtCellDep`](#type-udtcelldep)
    * [Type `UdtCfgInfos`](#type-udtcfginfos)
    * [Type `UdtDep`](#type-udtdep)
    * [Type `UdtScript`](#type-udtscript)

## RPC Modules

<a id="cch"></a>
### Module `Cch`
RPC module for cross chain hub demonstration.


<a id="cch-send_btc"></a>
#### Method `send_btc`

Send BTC to a address.

##### Params

* `btc_pay_req` - <em>`String`</em>, Bitcoin payment request string
* `currency` - <em>[Currency](#type-currency)</em>, Request currency

##### Returns

* `timestamp` - <em>`u64`</em>, Seconds since epoch when the order is created
* `expiry` - <em>`u64`</em>, Seconds after timestamp that the order expires
* `ckb_final_tlc_expiry_delta` - <em>`u64`</em>, The minimal expiry in seconds of the final TLC in the CKB network
* `wrapped_btc_type_script` - <em>`ckb_jsonrpc_types::Script`</em>, Wrapped BTC type script
* `incoming_invoice` - <em>[CchInvoice](#type-cchinvoice)</em>, Generated invoice for the incoming payment
* `outgoing_pay_req` - <em>`String`</em>, The final payee to accept the payment. It has the different network with incoming invoice.
* `payment_hash` - <em>[Hash256](#type-hash256)</em>, Payment hash for the HTLC for both CKB and BTC.
* `amount_sats` - <em>`u128`</em>, Amount required to pay in Satoshis, including fee
* `fee_sats` - <em>`u128`</em>, Fee in Satoshis
* `status` - <em>[CchOrderStatus](#type-cchorderstatus)</em>, Order status

---



<a id="cch-receive_btc"></a>
#### Method `receive_btc`

Receive BTC from a payment hash.

##### Params

* `fiber_pay_req` - <em>`String`</em>, Fiber payment request string

##### Returns

* `timestamp` - <em>`u64`</em>, Seconds since epoch when the order is created
* `expiry` - <em>`u64`</em>, Seconds after timestamp that the order expires
* `ckb_final_tlc_expiry_delta` - <em>`u64`</em>, The minimal expiry in seconds of the final TLC in the CKB network
* `wrapped_btc_type_script` - <em>`ckb_jsonrpc_types::Script`</em>, Wrapped BTC type script
* `incoming_invoice` - <em>[CchInvoice](#type-cchinvoice)</em>, Generated invoice for the incoming payment
* `outgoing_pay_req` - <em>`String`</em>, The final payee to accept the payment. It has the different network with incoming invoice.
* `payment_hash` - <em>[Hash256](#type-hash256)</em>, Payment hash for the HTLC for both CKB and BTC.
* `amount_sats` - <em>`u128`</em>, Amount required to pay in Satoshis, including fee
* `fee_sats` - <em>`u128`</em>, Fee in Satoshis
* `status` - <em>[CchOrderStatus](#type-cchorderstatus)</em>, Order status

---



<a id="cch-get_cch_order"></a>
#### Method `get_cch_order`

Get receive BTC order by payment hash.

##### Params

* `payment_hash` - <em>[Hash256](#type-hash256)</em>, Payment hash for the HTLC for both CKB and BTC.

##### Returns

* `timestamp` - <em>`u64`</em>, Seconds since epoch when the order is created
* `expiry` - <em>`u64`</em>, Seconds after timestamp that the order expires
* `ckb_final_tlc_expiry_delta` - <em>`u64`</em>, The minimal expiry in seconds of the final TLC in the CKB network
* `wrapped_btc_type_script` - <em>`ckb_jsonrpc_types::Script`</em>, Wrapped BTC type script
* `incoming_invoice` - <em>[CchInvoice](#type-cchinvoice)</em>, Generated invoice for the incoming payment
* `outgoing_pay_req` - <em>`String`</em>, The final payee to accept the payment. It has the different network with incoming invoice.
* `payment_hash` - <em>[Hash256](#type-hash256)</em>, Payment hash for the HTLC for both CKB and BTC.
* `amount_sats` - <em>`u128`</em>, Amount required to pay in Satoshis, including fee
* `fee_sats` - <em>`u128`</em>, Fee in Satoshis
* `status` - <em>[CchOrderStatus](#type-cchorderstatus)</em>, Order status

---



<a id="channel"></a>
### Module `Channel`
RPC module for channel management.


<a id="channel-open_channel"></a>
#### Method `open_channel`

Attempts to open a channel with a peer.

##### Params

* `peer_id` - <em>`PeerId`</em>, The peer ID to open a channel with, the peer must be connected through the [connect_peer](#peer-connect_peer) rpc first.
* `funding_amount` - <em>`u128`</em>, The amount of CKB or UDT to fund the channel with.
* `public` - <em>`Option<bool>`</em>, Whether this is a public channel (will be broadcasted to network, and can be used to forward TLCs), an optional parameter, default value is true.
* `one_way` - <em>`Option<bool>`</em>, Whether this is a one-way channel (will not be broadcasted to network, and can only be used to send payment one way), an optional parameter, default value is false.
* `funding_udt_type_script` - <em>`Option<Script>`</em>, The type script of the UDT to fund the channel with, an optional parameter.
* `shutdown_script` - <em>`Option<Script>`</em>, The script used to receive the channel balance, an optional parameter, default value is the secp256k1_blake160_sighash_all script corresponding to the configured private key.
* `commitment_delay_epoch` - <em>`Option<EpochNumberWithFraction>`</em>, The delay time for the commitment transaction, must be an [EpochNumberWithFraction](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0017-tx-valid-since/e-i-l-encoding.png) in u64 format, an optional parameter, default value is 1 epoch, which is 4 hours.
* `commitment_fee_rate` - <em>`Option<u64>`</em>, The fee rate for the commitment transaction, an optional parameter.
* `funding_fee_rate` - <em>`Option<u64>`</em>, The fee rate for the funding transaction, an optional parameter.
* `tlc_expiry_delta` - <em>`Option<u64>`</em>, The expiry delta to forward a tlc, in milliseconds, default to 4 hours, which is 4 * 60 * 60 * 1000 milliseconds
 Expect it >= 2/3 commitment_delay_epoch.
 This parameter can be updated with rpc `update_channel` later.
* `tlc_min_value` - <em>`Option<u128>`</em>, The minimum value for a TLC our side can send,
 an optional parameter, default is 0, which means we can send any TLC is larger than 0.
 This parameter can be updated with rpc `update_channel` later.
* `tlc_fee_proportional_millionths` - <em>`Option<u128>`</em>, The fee proportional millionths for a TLC, proportional to the amount of the forwarded tlc.
 The unit is millionths of the amount. default is 1000 which means 0.1%.
 This parameter can be updated with rpc `update_channel` later.
 Not that, we use outbound channel to calculate the fee for TLC forwarding. For example,
 if we have a path A -> B -> C, then the fee B requires for TLC forwarding, is calculated
 the channel configuration of B and C, not A and B.
* `max_tlc_value_in_flight` - <em>`Option<u128>`</em>, The maximum value in flight for TLCs, an optional parameter.
 This parameter can not be updated after channel is opened.
* `max_tlc_number_in_flight` - <em>`Option<u64>`</em>, The maximum number of TLCs that can be accepted, an optional parameter, default is 125
 This parameter can not be updated after channel is opened.

##### Returns

* `temporary_channel_id` - <em>[Hash256](#type-hash256)</em>, The temporary channel ID of the channel being opened

---



<a id="channel-accept_channel"></a>
#### Method `accept_channel`

Accepts a channel opening request from a peer.

##### Params

* `temporary_channel_id` - <em>[Hash256](#type-hash256)</em>, The temporary channel ID of the channel to accept
* `funding_amount` - <em>`u128`</em>, The amount of CKB or UDT to fund the channel with
* `shutdown_script` - <em>`Option<Script>`</em>, The script used to receive the channel balance, an optional parameter,
 default value is the secp256k1_blake160_sighash_all script corresponding to the configured private key
* `max_tlc_value_in_flight` - <em>`Option<u128>`</em>, The max tlc sum value in flight for the channel, default is u128::MAX
 This parameter can not be updated after channel is opened.
* `max_tlc_number_in_flight` - <em>`Option<u64>`</em>, The max tlc number in flight send from our side, default is 125
 This parameter can not be updated after channel is opened.
* `tlc_min_value` - <em>`Option<u128>`</em>, The minimum value for a TLC our side can send,
 an optional parameter, default is 0, which means we can send any TLC is larger than 0.
 This parameter can be updated with rpc `update_channel` later.
* `tlc_fee_proportional_millionths` - <em>`Option<u128>`</em>, The fee proportional millionths for a TLC, proportional to the amount of the forwarded tlc.
 The unit is millionths of the amount. default is 1000 which means 0.1%.
 This parameter can be updated with rpc `update_channel` later.
 Not that, we use outbound channel to calculate the fee for TLC forwarding. For example,
 if we have a path A -> B -> C, then the fee B requires for TLC forwarding, is calculated
 the channel configuration of B and C, not A and B.
* `tlc_expiry_delta` - <em>`Option<u64>`</em>, The expiry delta to forward a tlc, in milliseconds, default to 1 day, which is 24 * 60 * 60 * 1000 milliseconds
 This parameter can be updated with rpc `update_channel` later.

##### Returns

* `channel_id` - <em>[Hash256](#type-hash256)</em>, The final ID of the channel that was accepted, it's different from the temporary channel ID

---



<a id="channel-abandon_channel"></a>
#### Method `abandon_channel`

Abandon a channel, this will remove the channel from the channel manager and DB.
 Only channels not in Ready or Closed state can be abandoned.

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, The temporary channel ID or real channel ID of the channel being abandoned

##### Returns

* None

---



<a id="channel-list_channels"></a>
#### Method `list_channels`

Lists all channels.

##### Params

* `peer_id` - <em>`Option<PeerId>`</em>, The peer ID to list channels for, an optional parameter, if not provided, all channels will be listed
* `include_closed` - <em>`Option<bool>`</em>, Whether to include closed channels in the list, an optional parameter, default value is false

##### Returns

* `channels` - <em>Vec<[Channel](#type-channel)></em>, The list of channels

---



<a id="channel-shutdown_channel"></a>
#### Method `shutdown_channel`

Shuts down a channel.

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, The channel ID of the channel to shut down
* `close_script` - <em>`Option<Script>`</em>, The script used to receive the channel balance, only support secp256k1_blake160_sighash_all script for now
 default is `default_funding_lock_script` in `CkbConfig`
* `fee_rate` - <em>`Option<u64>`</em>, The fee rate for the closing transaction, the fee will be deducted from the closing initiator's channel balance
 default is 1000 shannons/KW
* `force` - <em>`Option<bool>`</em>, Whether to force the channel to close, when set to false, `close_script` and `fee_rate` should be set, default is false.
 When set to true, `close_script` and `fee_rate` will be ignored and will use the default value when opening the channel.

##### Returns

* None

---



<a id="channel-update_channel"></a>
#### Method `update_channel`

Updates a channel.

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, The channel ID of the channel to update
* `enabled` - <em>`Option<bool>`</em>, Whether the channel is enabled
* `tlc_expiry_delta` - <em>`Option<u64>`</em>, The expiry delta for the TLC locktime
* `tlc_minimum_value` - <em>`Option<u128>`</em>, The minimum value for a TLC
* `tlc_fee_proportional_millionths` - <em>`Option<u128>`</em>, The fee proportional millionths for a TLC

##### Returns

* None

---



<a id="dev"></a>
### Module `Dev`
RPC module for development purposes, this module is not intended to be used in production.
 This module will be disabled in release build.


<a id="dev-commitment_signed"></a>
#### Method `commitment_signed`

Sends a commitment_signed message to the peer.

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, The channel ID of the channel to send the commitment_signed message to

##### Returns

* None

---



<a id="dev-add_tlc"></a>
#### Method `add_tlc`

Adds a TLC to a channel.

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, The channel ID of the channel to add the TLC to
* `amount` - <em>`u128`</em>, The amount of the TLC
* `payment_hash` - <em>[Hash256](#type-hash256)</em>, The payment hash of the TLC
* `expiry` - <em>`u64`</em>, The expiry of the TLC
* `hash_algorithm` - <em>Option<[HashAlgorithm](#type-hashalgorithm)></em>, The hash algorithm of the TLC

##### Returns

* `tlc_id` - <em>`u64`</em>, The ID of the TLC

---



<a id="dev-remove_tlc"></a>
#### Method `remove_tlc`

Removes a TLC from a channel.

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, The channel ID of the channel to remove the TLC from
* `tlc_id` - <em>`u64`</em>, The ID of the TLC to remove
* `reason` - <em>[RemoveTlcReason](#type-removetlcreason)</em>, The reason for removing the TLC, either a 32-byte hash for preimage fulfillment or an u32 error code for removal

##### Returns

* None

---



<a id="dev-submit_commitment_transaction"></a>
#### Method `submit_commitment_transaction`

Submit a commitment transaction to the chain

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, Channel ID
* `commitment_number` - <em>`u64`</em>, Commitment number

##### Returns

* `tx_hash` - <em>[Hash256](#type-hash256)</em>, Submitted commitment transaction hash

---



<a id="dev-check_channel_shutdown"></a>
#### Method `check_channel_shutdown`

Manually trigger CheckShutdownTx on all channels

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, Channel ID

##### Returns

* None

---



<a id="graph"></a>
### Module `Graph`
RPC module for graph management.


<a id="graph-graph_nodes"></a>
#### Method `graph_nodes`

Get the list of nodes in the network graph.

##### Params

* `limit` - <em>`Option<u64>`</em>, The maximum number of nodes to return.
* `after` - <em>`Option<JsonBytes>`</em>, The cursor to start returning nodes from.

##### Returns

* `nodes` - <em>Vec<[NodeInfo](#type-nodeinfo)></em>, The list of nodes.
* `last_cursor` - <em>`JsonBytes`</em>, The last cursor.

---



<a id="graph-graph_channels"></a>
#### Method `graph_channels`

Get the list of channels in the network graph.

##### Params

* `limit` - <em>`Option<u64>`</em>, The maximum number of channels to return.
* `after` - <em>`Option<JsonBytes>`</em>, The cursor to start returning channels from.

##### Returns

* `channels` - <em>Vec<[ChannelInfo](#type-channelinfo)></em>, A list of channels.
* `last_cursor` - <em>`JsonBytes`</em>, The last cursor for pagination.

---



<a id="info"></a>
### Module `Info`
The RPC module for node information.


<a id="info-node_info"></a>
#### Method `node_info`

Get the node information.

##### Params
* None

##### Returns

* `version` - <em>`String`</em>, The version of the node software.
* `commit_hash` - <em>`String`</em>, The commit hash of the node software.
* `node_id` - <em>[Pubkey](#type-pubkey)</em>, The identity public key of the node.
* `features` - <em>`Vec<String>`</em>, The features supported by the node.
* `node_name` - <em>`Option<String>`</em>, The optional name of the node.
* `addresses` - <em>`Vec<MultiAddr>`</em>, A list of multi-addresses associated with the node.
* `chain_hash` - <em>[Hash256](#type-hash256)</em>, The hash of the blockchain that the node is connected to.
* `open_channel_auto_accept_min_ckb_funding_amount` - <em>`u64`</em>, The minimum CKB funding amount for automatically accepting open channel requests, serialized as a hexadecimal string.
* `auto_accept_channel_ckb_funding_amount` - <em>`u64`</em>, The CKB funding amount for automatically accepting channel requests, serialized as a hexadecimal string.
* `default_funding_lock_script` - <em>`Script`</em>, The default funding lock script for the node.
* `tlc_expiry_delta` - <em>`u64`</em>, The locktime expiry delta for Time-Locked Contracts (TLC), serialized as a hexadecimal string.
* `tlc_min_value` - <em>`u128`</em>, The minimum value for Time-Locked Contracts (TLC) we can send, serialized as a hexadecimal string.
* `tlc_fee_proportional_millionths` - <em>`u128`</em>, The fee (to forward payments) proportional to the value of Time-Locked Contracts (TLC), expressed in millionths and serialized as a hexadecimal string.
* `channel_count` - <em>`u32`</em>, The number of channels associated with the node, serialized as a hexadecimal string.
* `pending_channel_count` - <em>`u32`</em>, The number of pending channels associated with the node, serialized as a hexadecimal string.
* `peers_count` - <em>`u32`</em>, The number of peers connected to the node, serialized as a hexadecimal string.
* `udt_cfg_infos` - <em>[UdtCfgInfos](#type-udtcfginfos)</em>, Configuration information for User-Defined Tokens (UDT) associated with the node.

---



<a id="invoice"></a>
### Module `Invoice`
RPC module for invoice management.


<a id="invoice-new_invoice"></a>
#### Method `new_invoice`

Generates a new invoice.

##### Params

* `amount` - <em>`u128`</em>, The amount of the invoice.
* `description` - <em>`Option<String>`</em>, The description of the invoice.
* `currency` - <em>[Currency](#type-currency)</em>, The currency of the invoice.
* `payment_preimage` - <em>Option<[Hash256](#type-hash256)></em>, The preimage to settle an incoming TLC payable to this invoice. If preimage is set, hash must be absent. If both preimage and hash are absent, a random preimage is generated.
* `payment_hash` - <em>Option<[Hash256](#type-hash256)></em>, The hash of the preimage. If hash is set, preimage must be absent. This condition indicates a 'hold invoice' for which the tlc must be accepted and held until the preimage becomes known.
* `expiry` - <em>`Option<u64>`</em>, The expiry time of the invoice, in seconds.
* `fallback_address` - <em>`Option<String>`</em>, The fallback address of the invoice.
* `final_expiry_delta` - <em>`Option<u64>`</em>, The final HTLC timeout of the invoice, in milliseconds.
 Minimal value is 16 hours, and maximal value is 14 days.
* `udt_type_script` - <em>`Option<Script>`</em>, The UDT type script of the invoice.
* `hash_algorithm` - <em>Option<[HashAlgorithm](#type-hashalgorithm)></em>, The hash algorithm of the invoice.
* `allow_mpp` - <em>`Option<bool>`</em>, Whether allow payment to use MPP
* `allow_trampoline_routing` - <em>`Option<bool>`</em>, Whether allow payment to use trampoline routing

##### Returns

* `invoice_address` - <em>`String`</em>, The encoded invoice address.
* `invoice` - <em>[CkbInvoice](#type-ckbinvoice)</em>, The invoice.

---



<a id="invoice-parse_invoice"></a>
#### Method `parse_invoice`

Parses a encoded invoice.

##### Params

* `invoice` - <em>`String`</em>, The encoded invoice address.

##### Returns

* `invoice` - <em>[CkbInvoice](#type-ckbinvoice)</em>, The invoice.

---



<a id="invoice-get_invoice"></a>
#### Method `get_invoice`

Retrieves an invoice.

##### Params

* `payment_hash` - <em>[Hash256](#type-hash256)</em>, The payment hash of the invoice.

##### Returns

* `invoice_address` - <em>`String`</em>, The encoded invoice address.
* `invoice` - <em>[CkbInvoice](#type-ckbinvoice)</em>, The invoice.
* `status` - <em>[CkbInvoiceStatus](#type-ckbinvoicestatus)</em>, The invoice status

---



<a id="invoice-cancel_invoice"></a>
#### Method `cancel_invoice`

Cancels an invoice, only when invoice is in status `Open` can be canceled.

##### Params

* `payment_hash` - <em>[Hash256](#type-hash256)</em>, The payment hash of the invoice.

##### Returns

* `invoice_address` - <em>`String`</em>, The encoded invoice address.
* `invoice` - <em>[CkbInvoice](#type-ckbinvoice)</em>, The invoice.
* `status` - <em>[CkbInvoiceStatus](#type-ckbinvoicestatus)</em>, The invoice status

---



<a id="invoice-settle_invoice"></a>
#### Method `settle_invoice`

Settles an invoice by saving the preimage to this invoice.

##### Params

* `payment_hash` - <em>[Hash256](#type-hash256)</em>, The payment hash of the invoice.
* `payment_preimage` - <em>[Hash256](#type-hash256)</em>, The payment preimage of the invoice.

##### Returns

* None

---



<a id="payment"></a>
### Module `Payment`
RPC module for channel management.


<a id="payment-send_payment"></a>
#### Method `send_payment`

Sends a payment to a peer.

##### Params

* `target_pubkey` - <em>Option<[Pubkey](#type-pubkey)></em>, the identifier of the payment target
* `amount` - <em>`Option<u128>`</em>, the amount of the payment, the unit is Shannons for non UDT payment
 If not set and there is a invoice, the amount will be set to the invoice amount
* `payment_hash` - <em>Option<[Hash256](#type-hash256)></em>, the hash to use within the payment's HTLC.
 If not set and `keysend` is set to true, a random hash will be generated.
 If not set and there is a `payment_hash` in the invoice, it will be used.
 Otherwise, `payment_hash` need to be set.
* `final_tlc_expiry_delta` - <em>`Option<u64>`</em>, the TLC expiry delta should be used to set the timelock for the final hop, in milliseconds
* `tlc_expiry_limit` - <em>`Option<u64>`</em>, the TLC expiry limit for the whole payment, in milliseconds, each hop is with a default tlc delta of 1 day
 suppose the payment router is with N hops, the total tlc expiry limit is at least (N-1) days
 this is also the default value for the payment if this parameter is not provided
* `invoice` - <em>`Option<String>`</em>, the encoded invoice to send to the recipient
* `timeout` - <em>`Option<u64>`</em>, the payment timeout in seconds, if the payment is not completed within this time, it will be cancelled
* `max_fee_amount` - <em>`Option<u128>`</em>, the maximum fee amounts in shannons that the sender is willing to pay
* `max_parts` - <em>`Option<u64>`</em>, max parts for the payment, only used for multi-part payments
* `trampoline_hops` - <em>Option<Vec<[TrampolineHopParams](#type-trampolinehopparams)>></em>, Optional explicit trampoline hops.

 When set to a non-empty list `[t1, t2, ...]`, routing will only find a path from the
 payer to `t1`, and the inner trampoline onion will encode `t1 -> t2 -> ... -> final`.
* `keysend` - <em>`Option<bool>`</em>, keysend payment
* `udt_type_script` - <em>`Option<Script>`</em>, udt type script for the payment
* `allow_self_payment` - <em>`Option<bool>`</em>, allow self payment, default is false
* `custom_records` - <em>Option<[PaymentCustomRecords](#type-paymentcustomrecords)></em>, Some custom records for the payment which contains a map of u32 to Vec<u8>
 The key is the record type, and the value is the serialized data
 For example:
 ```json
 "custom_records": {
    "0x1": "0x01020304",
    "0x2": "0x05060708",
    "0x3": "0x090a0b0c",
    "0x4": "0x0d0e0f10010d090a0b0c"
  }
 ```
* `hop_hints` - <em>Option<Vec<[HopHint](#type-hophint)>></em>, Optional route hints to reach the destination through private channels.
 Note:
    1. this is only used for the private channels with the last hop.
    2. `hop_hints` is only a `hint` for routing algorithm,
       it is not a guarantee that the payment will be routed through the specified channels,
       it is up to the routing algorithm to decide whether to use the hints or not.

 For example `(pubkey, channel_outpoint, fee_rate, tlc_expiry_delta)` suggest path router
 to use the channel of `channel_outpoint` at hop with `pubkey` to forward the payment
 and the fee rate is `fee_rate` and tlc_expiry_delta is `tlc_expiry_delta`.
* `dry_run` - <em>`Option<bool>`</em>, dry_run for payment, used for check whether we can build valid router and the fee for this payment,
 it's useful for the sender to double check the payment before sending it to the network,
 default is false

##### Returns

* `payment_hash` - <em>[Hash256](#type-hash256)</em>, The payment hash of the payment
* `status` - <em>[PaymentStatus](#type-paymentstatus)</em>, The status of the payment
* `created_at` - <em>`u64`</em>, The time the payment was created at, in milliseconds from UNIX epoch
* `last_updated_at` - <em>`u64`</em>, The time the payment was last updated at, in milliseconds from UNIX epoch
* `failed_error` - <em>`Option<String>`</em>, The error message if the payment failed
* `fee` - <em>`u128`</em>, fee paid for the payment
* `custom_records` - <em>Option<[PaymentCustomRecords](#type-paymentcustomrecords)></em>, The custom records to be included in the payment.
* `routers` - <em>Vec<[SessionRoute](#type-sessionroute)></em>, The router is a list of nodes that the payment will go through.
 We store in the payment session and then will use it to track the payment history.
 The router is a list of nodes that the payment will go through.
 If the payment adapted MPP (multi-part payment), the routers will be a list of nodes
 For example:
    `A(amount, channel) -> B -> C -> D`
 means A will send `amount` with `channel` to B.

---



<a id="payment-get_payment"></a>
#### Method `get_payment`

Retrieves a payment.

##### Params

* `payment_hash` - <em>[Hash256](#type-hash256)</em>, The payment hash of the payment to retrieve

##### Returns

* `payment_hash` - <em>[Hash256](#type-hash256)</em>, The payment hash of the payment
* `status` - <em>[PaymentStatus](#type-paymentstatus)</em>, The status of the payment
* `created_at` - <em>`u64`</em>, The time the payment was created at, in milliseconds from UNIX epoch
* `last_updated_at` - <em>`u64`</em>, The time the payment was last updated at, in milliseconds from UNIX epoch
* `failed_error` - <em>`Option<String>`</em>, The error message if the payment failed
* `fee` - <em>`u128`</em>, fee paid for the payment
* `custom_records` - <em>Option<[PaymentCustomRecords](#type-paymentcustomrecords)></em>, The custom records to be included in the payment.
* `routers` - <em>Vec<[SessionRoute](#type-sessionroute)></em>, The router is a list of nodes that the payment will go through.
 We store in the payment session and then will use it to track the payment history.
 The router is a list of nodes that the payment will go through.
 If the payment adapted MPP (multi-part payment), the routers will be a list of nodes
 For example:
    `A(amount, channel) -> B -> C -> D`
 means A will send `amount` with `channel` to B.

---



<a id="payment-build_router"></a>
#### Method `build_router`

Builds a router with a list of pubkeys and required channels.

##### Params

* `amount` - <em>`Option<u128>`</em>, the amount of the payment, the unit is Shannons for non UDT payment
 If not set, the minimum routable amount `1` is used
* `udt_type_script` - <em>`Option<Script>`</em>, udt type script for the payment router
* `hops_info` - <em>Vec<[HopRequire](#type-hoprequire)></em>, A list of hops that defines the route. This does not include the source hop pubkey.
 A hop info is a tuple of pubkey and the channel(specified by channel funding tx) will be used.
 This is a strong restriction given on payment router, which means these specified hops and channels
 must be adapted in the router. This is different from hop hints, which maybe ignored by find path.
 If channel is not specified, find path algorithm will pick a channel within these two peers.

 An error will be returned if there is no router could be build from given hops and channels
* `final_tlc_expiry_delta` - <em>`Option<u64>`</em>, the TLC expiry delta should be used to set the timelock for the final hop, in milliseconds

##### Returns

* `router_hops` - <em>Vec<[RouterHop](#type-routerhop)></em>, The hops information for router

---



<a id="payment-send_payment_with_router"></a>
#### Method `send_payment_with_router`

Sends a payment to a peer with specified router
 This method differs from SendPayment in that it allows users to specify a full route manually.
 This can be used for things like rebalancing.

##### Params

* `payment_hash` - <em>Option<[Hash256](#type-hash256)></em>, the hash to use within the payment's HTLC.
 If not set and `keysend` is set to true, a random hash will be generated.
 If not set and there is a `payment_hash` in the invoice, it will be used.
 Otherwise, `payment_hash` need to be set.
* `router` - <em>Vec<[RouterHop](#type-routerhop)></em>, The router to use for the payment
* `invoice` - <em>`Option<String>`</em>, the encoded invoice to send to the recipient
* `custom_records` - <em>Option<[PaymentCustomRecords](#type-paymentcustomrecords)></em>, Some custom records for the payment which contains a map of u32 to Vec<u8>
 The key is the record type, and the value is the serialized data.
 Limits: the sum size of values can not exceed 2048 bytes.

 For example:
 ```json
 "custom_records": {
    "0x1": "0x01020304",
    "0x2": "0x05060708",
    "0x3": "0x090a0b0c",
    "0x4": "0x0d0e0f10010d090a0b0c"
  }
 ```
* `keysend` - <em>`Option<bool>`</em>, keysend payment
* `udt_type_script` - <em>`Option<Script>`</em>, udt type script for the payment
* `dry_run` - <em>`Option<bool>`</em>, dry_run for payment, used for check whether we can build valid router and the fee for this payment,
 it's useful for the sender to double check the payment before sending it to the network,
 default is false

##### Returns

* `payment_hash` - <em>[Hash256](#type-hash256)</em>, The payment hash of the payment
* `status` - <em>[PaymentStatus](#type-paymentstatus)</em>, The status of the payment
* `created_at` - <em>`u64`</em>, The time the payment was created at, in milliseconds from UNIX epoch
* `last_updated_at` - <em>`u64`</em>, The time the payment was last updated at, in milliseconds from UNIX epoch
* `failed_error` - <em>`Option<String>`</em>, The error message if the payment failed
* `fee` - <em>`u128`</em>, fee paid for the payment
* `custom_records` - <em>Option<[PaymentCustomRecords](#type-paymentcustomrecords)></em>, The custom records to be included in the payment.
* `routers` - <em>Vec<[SessionRoute](#type-sessionroute)></em>, The router is a list of nodes that the payment will go through.
 We store in the payment session and then will use it to track the payment history.
 The router is a list of nodes that the payment will go through.
 If the payment adapted MPP (multi-part payment), the routers will be a list of nodes
 For example:
    `A(amount, channel) -> B -> C -> D`
 means A will send `amount` with `channel` to B.

---



<a id="peer"></a>
### Module `Peer`
RPC module for peer management.


<a id="peer-connect_peer"></a>
#### Method `connect_peer`

Connect to a peer.

##### Params

* `address` - <em>`MultiAddr`</em>, The address of the peer to connect to.
* `save` - <em>`Option<bool>`</em>, Whether to save the peer address to the peer store.

##### Returns

* None

---



<a id="peer-disconnect_peer"></a>
#### Method `disconnect_peer`

Disconnect from a peer.

##### Params

* `peer_id` - <em>`PeerId`</em>, The peer ID of the peer to disconnect.

##### Returns

* None

---



<a id="peer-list_peers"></a>
#### Method `list_peers`

List connected peers

##### Params
* None

##### Returns

* `peers` - <em>Vec<[PeerInfo](#type-peerinfo)></em>, A list of connected peers.

---



<a id="prof"></a>
### Module `Prof`
RPC module for profiling
 This module require build with pprof feature and debug symbol.


<a id="prof-pprof"></a>
#### Method `pprof`

Collects a temporary CPU profile and writes a flamegraph SVG to disk.

##### Params

* `duration_secs` - <em>`Option<u64>`</em>, Duration to profile in seconds. Defaults 10s.

##### Returns

* `path` - <em>`String`</em>, Path of the generated flamegraph SVG.

---



<a id="watchtower"></a>
### Module `Watchtower`
RPC module for watchtower related operations


<a id="watchtower-create_watch_channel"></a>
#### Method `create_watch_channel`

Create a new watched channel

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, Channel ID
* `funding_udt_type_script` - <em>`Option<Script>`</em>, Funding UDT type script
* `local_settlement_key` - <em>[Privkey](#type-privkey)</em>, The local party's private key used to settle the commitment transaction
* `remote_settlement_key` - <em>[Pubkey](#type-pubkey)</em>, The remote party's public key used to settle the commitment transaction
* `local_funding_pubkey` - <em>[Pubkey](#type-pubkey)</em>, The local party's funding public key
* `remote_funding_pubkey` - <em>[Pubkey](#type-pubkey)</em>, The remote party's funding public key
* `settlement_data` - <em>[SettlementData](#type-settlementdata)</em>, Settlement data

##### Returns

* None

---



<a id="watchtower-remove_watch_channel"></a>
#### Method `remove_watch_channel`

Remove a watched channel

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, Channel ID

##### Returns

* None

---



<a id="watchtower-update_revocation"></a>
#### Method `update_revocation`

Update revocation

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, Channel ID
* `revocation_data` - <em>[RevocationData](#type-revocationdata)</em>, Revocation data
* `settlement_data` - <em>[SettlementData](#type-settlementdata)</em>, Settlement data

##### Returns

* None

---



<a id="watchtower-update_pending_remote_settlement"></a>
#### Method `update_pending_remote_settlement`

Update pending remote settlement

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, Channel ID
* `settlement_data` - <em>[SettlementData](#type-settlementdata)</em>, Settlement data

##### Returns

* None

---



<a id="watchtower-update_local_settlement"></a>
#### Method `update_local_settlement`

Update settlement

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, Channel ID
* `settlement_data` - <em>[SettlementData](#type-settlementdata)</em>, Settlement data

##### Returns

* None

---



<a id="watchtower-create_preimage"></a>
#### Method `create_preimage`

Create preimage

##### Params

* `payment_hash` - <em>[Hash256](#type-hash256)</em>, Payment hash
* `preimage` - <em>[Hash256](#type-hash256)</em>, Preimage

##### Returns

* None

---



<a id="watchtower-remove_preimage"></a>
#### Method `remove_preimage`

Remove preimage

##### Params

* `payment_hash` - <em>[Hash256](#type-hash256)</em>, Payment hash

##### Returns

* None

---




## RPC Types


<a id="#type-attribute"></a>
### Type `Attribute`

The attributes of the invoice


#### Enum with values of

* `FinalHtlcTimeout` - <em>`u64`</em>, This attribute is deprecated since v0.6.0, The final tlc time out, in milliseconds
* `FinalHtlcMinimumExpiryDelta` - <em>`u64`</em>, The final tlc minimum expiry delta, in milliseconds, default is 1 day
* `ExpiryTime` - <em>`Duration`</em>, The expiry time of the invoice, in seconds
* `Description` - <em>`String`</em>, The description of the invoice
* `FallbackAddr` - <em>`String`</em>, The fallback address of the invoice
* `UdtScript` - <em>[CkbScript](#type-ckbscript)</em>, The udt type script of the invoice
* `PayeePublicKey` - <em>`PublicKey`</em>, The payee public key of the invoice
* `HashAlgorithm` - <em>[HashAlgorithm](#type-hashalgorithm)</em>, The hash algorithm of the invoice
* `Feature` - <em>`Vec<String>`</em>, The feature flags of the invoice
* `PaymentSecret` - <em>[Hash256](#type-hash256)</em>, The payment secret of the invoice
---

<a id="#type-cchinvoice"></a>
### Type `CchInvoice`

The generated proxy invoice for the incoming payment.

 The JSON representation:

 ```text
 { "Fiber": String } | { "Lightning": String }
 ```


#### Enum with values of

* `Fiber` - <em>[CkbInvoice](#type-ckbinvoice)</em>, Fiber invoice that once paid, the hub will send the outgoing payment to Lightning
* `Lightning` - <em>`Bolt11Invoice`</em>, Lightning invoice that once paid, the hub will send the outgoing payment to Fiber
---

<a id="#type-cchorderstatus"></a>
### Type `CchOrderStatus`

The status of a cross-chain hub order, will update as the order progresses.


#### Enum with values of

* `Pending` - Order is created and has not received the incoming payment
* `IncomingAccepted` - HTLC in the incoming payment is accepted.
* `OutgoingInFlight` - There's an outgoing payment in flight.
* `OutgoingSettled` - The outgoing payment is settled.
* `Succeeded` - Both payments are settled and the order succeeds.
* `Failed` - Order is failed.
---

<a id="#type-channel"></a>
### Type `Channel`

The channel data structure


#### Fields

* `channel_id` - <em>[Hash256](#type-hash256)</em>, The channel ID
* `is_public` - <em>`bool`</em>, Whether the channel is public
* `is_acceptor` - <em>`bool`</em>, Is this channel initially inbound?
 An inbound channel is one where the counterparty is the funder of the channel.
* `is_one_way` - <em>`bool`</em>, Is this channel one-way?
 Combines with is_acceptor to determine if the channel able to send payment to the counterparty or not.
* `channel_outpoint` - <em>`Option<OutPoint>`</em>, The outpoint of the channel
* `peer_id` - <em>`PeerId`</em>, The peer ID of the channel
* `funding_udt_type_script` - <em>`Option<Script>`</em>, The UDT type script of the channel
* `state` - <em>[ChannelState](#type-channelstate)</em>, The state of the channel
* `local_balance` - <em>`u128`</em>, The local balance of the channel
* `offered_tlc_balance` - <em>`u128`</em>, The offered balance of the channel
* `remote_balance` - <em>`u128`</em>, The remote balance of the channel
* `received_tlc_balance` - <em>`u128`</em>, The received balance of the channel
* `pending_tlcs` - <em>Vec<[Htlc](#type-htlc)></em>, The list of pending tlcs
* `latest_commitment_transaction_hash` - <em>`Option<H256>`</em>, The hash of the latest commitment transaction
* `created_at` - <em>`u64`</em>, The time the channel was created at, in milliseconds from UNIX epoch
* `enabled` - <em>`bool`</em>, Whether the channel is enabled
* `tlc_expiry_delta` - <em>`u64`</em>, The expiry delta to forward a tlc, in milliseconds, default to 1 day, which is 24 * 60 * 60 * 1000 milliseconds
 This parameter can be updated with rpc `update_channel` later.
* `tlc_fee_proportional_millionths` - <em>`u128`</em>, The fee proportional millionths for a TLC, proportional to the amount of the forwarded tlc.
 The unit is millionths of the amount. default is 1000 which means 0.1%.
 This parameter can be updated with rpc `update_channel` later.
 Not that, we use outbound channel to calculate the fee for TLC forwarding. For example,
 if we have a path A -> B -> C, then the fee B requires for TLC forwarding, is calculated
 the channel configuration of B and C, not A and B.
* `shutdown_transaction_hash` - <em>`Option<H256>`</em>, The hash of the shutdown transaction
---

<a id="#type-channelinfo"></a>
### Type `ChannelInfo`

The Channel information.


#### Fields

* `channel_outpoint` - <em>`OutPoint`</em>, The outpoint of the channel.
* `node1` - <em>[Pubkey](#type-pubkey)</em>, The identity public key of the first node.
* `node2` - <em>[Pubkey](#type-pubkey)</em>, The identity public key of the second node.
* `created_timestamp` - <em>`u64`</em>, The created timestamp of the channel, which is the block header timestamp of the block
 that contains the channel funding transaction.
* `update_info_of_node1` - <em>Option<[ChannelUpdateInfo](#type-channelupdateinfo)></em>, The update info from node1 to node2, e.g. timestamp, fee_rate, tlc_expiry_delta, tlc_minimum_value
* `update_info_of_node2` - <em>Option<[ChannelUpdateInfo](#type-channelupdateinfo)></em>, The update info from node2 to node1, e.g. timestamp, fee_rate, tlc_expiry_delta, tlc_minimum_value
* `capacity` - <em>`u128`</em>, The capacity of the channel.
* `chain_hash` - <em>[Hash256](#type-hash256)</em>, The chain hash of the channel.
* `udt_type_script` - <em>`Option<Script>`</em>, The UDT type script of the channel.
---

<a id="#type-channelstate"></a>
### Type `ChannelState`

The state of a channel


#### Enum with values of

* `NegotiatingFunding` - <em>`NegotiatingFundingFlags`</em>, We are negotiating the parameters required for the channel prior to funding it.
* `CollaboratingFundingTx` - <em>`CollaboratingFundingTxFlags`</em>, We're collaborating with the other party on the funding transaction.
* `SigningCommitment` - <em>`SigningCommitmentFlags`</em>, We have collaborated over the funding and are now waiting for CommitmentSigned messages.
* `AwaitingTxSignatures` - <em>`AwaitingTxSignaturesFlags`</em>, We've received and sent `commitment_signed` and are now waiting for both
 party to collaborate on creating a valid funding transaction.
* `AwaitingChannelReady` - <em>`AwaitingChannelReadyFlags`</em>, We've received/sent `funding_created` and `funding_signed` and are thus now waiting on the
 funding transaction to confirm.
* `ChannelReady` - Both we and our counterparty consider the funding transaction confirmed and the channel is
 now operational.
* `ShuttingDown` - <em>`ShuttingDownFlags`</em>, We've successfully negotiated a `closing_signed` dance. At this point, the `ChannelManager`
* `Closed` - <em>`CloseFlags`</em>, This channel is closed.
---

<a id="#type-channelupdateinfo"></a>
### Type `ChannelUpdateInfo`

The channel update info with a single direction of channel


#### Fields

* `timestamp` - <em>`u64`</em>, The timestamp is the time when the channel update was received by the node.
* `enabled` - <em>`bool`</em>, Whether the channel can be currently used for payments (in this one direction).
* `outbound_liquidity` - <em>`Option<u128>`</em>, The exact amount of balance that we can send to the other party via the channel.
* `tlc_expiry_delta` - <em>`u64`</em>, The difference in htlc expiry values that you must have when routing through this channel (in milliseconds).
* `tlc_minimum_value` - <em>`u128`</em>, The minimum value, which must be relayed to the next hop via the channel
* `fee_rate` - <em>`u64`</em>, The forwarding fee rate for the channel.
---

<a id="#type-ckbinvoice"></a>
### Type `CkbInvoice`

Represents a syntactically and semantically correct lightning BOLT11 invoice

 There are three ways to construct a `CkbInvoice`:
  1. using [`CkbInvoiceBuilder`]
  2. using `str::parse::<CkbInvoice>(&str)` (see [`CkbInvoice::from_str`])


#### Fields

* `currency` - <em>[Currency](#type-currency)</em>, The currency of the invoice
* `amount` - <em>`Option<u128>`</em>, The amount of the invoice
* `signature` - <em>Option<[InvoiceSignature](#type-invoicesignature)></em>, The signature of the invoice
* `data` - <em>[InvoiceData](#type-invoicedata)</em>, The invoice data, including the payment hash, timestamp and other attributes
---

<a id="#type-ckbinvoicestatus"></a>
### Type `CkbInvoiceStatus`

The currency of the invoice, can also used to represent the CKB network chain.


#### Enum with values of

* `Open` - The invoice is open and can be paid.
* `Cancelled` - The invoice is cancelled.
* `Expired` - The invoice is expired.
* `Received` - The invoice is received, but not settled yet.
* `Paid` - The invoice is paid.
---

<a id="#type-currency"></a>
### Type `Currency`

The currency of the invoice, can also used to represent the CKB network chain.


#### Enum with values of

* `Fibb` - The mainnet currency of CKB.
* `Fibt` - The testnet currency of the CKB network.
* `Fibd` - The devnet currency of the CKB network.
---

<a id="#type-hash256"></a>
### Type `Hash256`

A 256-bit hash digest, used as identifier of channel, payment, transaction hash etc.



---

<a id="#type-hashalgorithm"></a>
### Type `HashAlgorithm`

HashAlgorithm is the hash algorithm used in the hash lock.


#### Enum with values of

* `CkbHash` - The default hash algorithm, CkbHash
* `Sha256` - The sha256 hash algorithm
---

<a id="#type-hophint"></a>
### Type `HopHint`

A hop hint is a hint for a node to use a specific channel.


#### Fields

* `pubkey` - <em>[Pubkey](#type-pubkey)</em>, The public key of the node
* `channel_outpoint` - <em>`OutPoint`</em>, The outpoint of the channel
* `fee_rate` - <em>`u64`</em>, The fee rate to use this hop to forward the payment.
* `tlc_expiry_delta` - <em>`u64`</em>, The TLC expiry delta to use this hop to forward the payment.
---

<a id="#type-hoprequire"></a>
### Type `HopRequire`

A hop requirement need to meet when building router, do not including the source node,
 the last hop is the target node.


#### Fields

* `pubkey` - <em>[Pubkey](#type-pubkey)</em>, The public key of the node
* `channel_outpoint` - <em>`Option<OutPoint>`</em>, The outpoint for the channel, which means use channel with `channel_outpoint` to reach this node
---

<a id="#type-htlc"></a>
### Type `Htlc`

The htlc data structure


#### Fields

* `id` - <em>`u64`</em>, The id of the htlc
* `amount` - <em>`u128`</em>, The amount of the htlc
* `payment_hash` - <em>[Hash256](#type-hash256)</em>, The payment hash of the htlc
* `expiry` - <em>`u64`</em>, The expiry of the htlc
* `forwarding_channel_id` - <em>Option<[Hash256](#type-hash256)></em>, If this HTLC is involved in a forwarding operation, this field indicates the forwarding channel.
 For an outbound htlc, it is the inbound channel. For an inbound htlc, it is the outbound channel.
* `forwarding_tlc_id` - <em>`Option<u64>`</em>, If this HTLC is involved in a forwarding operation, this field indicates the forwarding tlc id.
* `status` - <em>[TlcStatus](#type-tlcstatus)</em>, The status of the htlc
---

<a id="#type-invoicedata"></a>
### Type `InvoiceData`

The metadata of the invoice


#### Fields

* `timestamp` - <em>`u128`</em>, The timestamp of the invoice
* `payment_hash` - <em>[Hash256](#type-hash256)</em>, The payment hash of the invoice
* `attrs` - <em>Vec<[Attribute](#type-attribute)></em>, The attributes of the invoice, e.g. description, expiry time, etc.
---

<a id="#type-invoicesignature"></a>
### Type `InvoiceSignature`

Recoverable signature



---

<a id="#type-nodeinfo"></a>
### Type `NodeInfo`

The Node information.


#### Fields

* `node_name` - <em>`String`</em>, The name of the node.
* `version` - <em>`String`</em>, The version of the node.
* `addresses` - <em>`Vec<MultiAddr>`</em>, The addresses of the node.
* `features` - <em>`Vec<String>`</em>, The node features supported by the node.
* `node_id` - <em>[Pubkey](#type-pubkey)</em>, The identity public key of the node.
* `timestamp` - <em>`u64`</em>, The latest timestamp set by the owner for the node announcement.
 When a Node is online this timestamp will be updated to the latest value.
* `chain_hash` - <em>[Hash256](#type-hash256)</em>, The chain hash of the node.
* `auto_accept_min_ckb_funding_amount` - <em>`u64`</em>, The minimum CKB funding amount for automatically accepting open channel requests.
* `udt_cfg_infos` - <em>[UdtCfgInfos](#type-udtcfginfos)</em>, The UDT configuration infos of the node.
---

<a id="#type-paymentcustomrecords"></a>
### Type `PaymentCustomRecords`

The custom records to be included in the payment.
 The key is hex encoded of `u32`, it's range limited in 0 ~ 65535, and the value is hex encoded of `Vec<u8>` with `0x` as prefix.
 For example:
 ```json
 "custom_records": {
    "0x1": "0x01020304",
    "0x2": "0x05060708",
    "0x3": "0x090a0b0c",
    "0x4": "0x0d0e0f10010d090a0b0c"
  }
 ```


#### Fields

* `data` - <em>`HashMap<u32::Vec<u8>>`</em>, The custom records to be included in the payment.
---

<a id="#type-paymentstatus"></a>
### Type `PaymentStatus`

The status of a payment, will update as the payment progresses.
 The transfer path for payment status is `Created -> Inflight -> Success | Failed`.


#### Enum with values of

* `Created` - initial status, a payment session is created, no HTLC is sent
* `Inflight` - the first hop AddTlc is sent successfully and waiting for the response
* `Success` - related HTLC is successfully settled
* `Failed` - related HTLC is failed
---

<a id="#type-peerinfo"></a>
### Type `PeerInfo`

The information about a peer connected to the node.


#### Fields

* `pubkey` - <em>[Pubkey](#type-pubkey)</em>, The identity public key of the peer.
* `peer_id` - <em>`PeerId`</em>, The peer ID of the peer
* `address` - <em>`MultiAddr`</em>, The multi-address associated with the connecting peer.
 Note: this is only the address which used for connecting to the peer, not all addresses of the peer.
 The `graph_nodes` in Graph rpc module will return all addresses of the peer.
---

<a id="#type-privkey"></a>
### Type `Privkey`

A wrapper for secp256k1 secret key



---

<a id="#type-pubkey"></a>
### Type `Pubkey`

The public key for a Node



---

<a id="#type-removetlcreason"></a>
### Type `RemoveTlcReason`

The reason for removing a TLC


#### Enum with values of

* `RemoveTlcFulfill` - The reason for removing the TLC is that it was fulfilled
* `RemoveTlcFail` - The reason for removing the TLC is that it failed
---

<a id="#type-revocationdata"></a>
### Type `RevocationData`

Data needed to revoke an outdated commitment transaction.


#### Fields

* `commitment_number` - <em>`u64`</em>, The commitment transaction version number that was revoked
* `aggregated_signature` - <em>`CompactSignature`</em>, The aggregated signature from both parties that authorizes the revocation
* `output` - <em>`CellOutput`</em>, The output cell from the revoked commitment transaction
* `output_data` - <em>`Bytes`</em>, The associated data for the output cell (e.g., UDT amount for token transfers)
---

<a id="#type-routerhop"></a>
### Type `RouterHop`

A router hop information for a payment, a paymenter router is an array of RouterHop,
 a router hop generally implies hop `target` will receive `amount_received` with `channel_outpoint` of channel.
 Improper hop hint may make payment fail, for example the specified channel do not have enough capacity.


#### Fields

* `target` - <em>[Pubkey](#type-pubkey)</em>, The node that is sending the TLC to the next node.
* `channel_outpoint` - <em>`OutPoint`</em>, The channel of this hop used to receive TLC
* `amount_received` - <em>`u128`</em>, The amount that the source node will transfer to the target node.
 We have already added up all the fees along the path, so this amount can be used directly for the TLC.
* `incoming_tlc_expiry` - <em>`u64`</em>, The expiry for the TLC that the source node sends to the target node.
 We have already added up all the expiry deltas along the path,
 the only thing missing is current time. So the expiry is the current time plus the expiry delta.
---

<a id="#type-sessionroute"></a>
### Type `SessionRoute`

The router is a list of nodes that the payment will go through.
 We store in the payment session and then will use it to track the payment history.
 The router is a list of nodes that the payment will go through.
 For example:
    `A(amount, channel) -> B -> C -> D`
 means A will send `amount` with `channel` to B.


#### Fields

* `nodes` - <em>Vec<[SessionRouteNode](#type-sessionroutenode)></em>, the nodes in the route
---

<a id="#type-sessionroutenode"></a>
### Type `SessionRouteNode`

The node and channel information in a payment route hop


#### Fields

* `pubkey` - <em>[Pubkey](#type-pubkey)</em>, the public key of the node
* `amount` - <em>`u128`</em>, the amount for this hop
* `channel_outpoint` - <em>`OutPoint`</em>, the channel outpoint for this hop
---

<a id="#type-settlementdata"></a>
### Type `SettlementData`

Data needed to authorize and execute a settlement transaction.


#### Fields

* `local_amount` - <em>`u128`</em>, The total amount of CKB/UDT being settled for the local party
* `remote_amount` - <em>`u128`</em>, The total amount of CKB/UDT being settled for the remote party
* `tlcs` - <em>Vec<[SettlementTlc](#type-settlementtlc)></em>, The list of pending Time-Locked Contracts (TLCs) included in this settlement
---

<a id="#type-settlementtlc"></a>
### Type `SettlementTlc`

Data needed to authorize and execute a Time-Locked Contract (TLC) settlement transaction.


#### Fields

* `tlc_id` - <em>[TLCId](#type-tlcid)</em>, The ID of the TLC (either offered or received)
* `hash_algorithm` - <em>[HashAlgorithm](#type-hashalgorithm)</em>, The hash algorithm used for the TLC
* `payment_amount` - <em>`u128`</em>, The amount of CKB/UDT involved in the TLC
* `payment_hash` - <em>[Hash256](#type-hash256)</em>, The hash of the payment preimage
* `expiry` - <em>`u64`</em>, The expiry time for the TLC in milliseconds
* `local_key` - <em>[Privkey](#type-privkey)</em>, The local party's private key used to sign the TLC
* `remote_key` - <em>[Pubkey](#type-pubkey)</em>, The remote party's public key used to verify the TLC
---

<a id="#type-tlcid"></a>
### Type `TLCId`

The id of a tlc, it can be either offered or received.


#### Enum with values of

* `Offered` - <em>`u64`</em>, Offered tlc id
* `Received` - <em>`u64`</em>, Received tlc id
---

<a id="#type-tlcstatus"></a>
### Type `TlcStatus`

The status of a tlc


#### Enum with values of

* `Outbound` - <em>[OutboundTlcStatus](#type-outboundtlcstatus)</em>, Outbound tlc
* `Inbound` - <em>[InboundTlcStatus](#type-inboundtlcstatus)</em>, Inbound tlc
---

<a id="#type-trampolinehopparams"></a>
### Type `TrampolineHopParams`

Trampoline hop parameters for specifying optional trampoline hops in a payment.


#### Fields

* `pubkey` - <em>[Pubkey](#type-pubkey)</em>, The public key of the trampoline hop
* `fee_rate` - <em>`Option<u64>`</em>, Optional fee rate (proportional millionths) charged by this trampoline hop.
* `tlc_expiry_delta` - <em>`Option<u64>`</em>, Optional TLC expiry delta (ms) contributed by this trampoline hop.
---

<a id="#type-udtarginfo"></a>
### Type `UdtArgInfo`

The UDT argument info which is used to identify the UDT configuration


#### Fields

* `name` - <em>`String`</em>, The name of the UDT.
* `script` - <em>[UdtScript](#type-udtscript)</em>, The script of the UDT.
* `auto_accept_amount` - <em>`Option<u128>`</em>, The minimum amount of the UDT that can be automatically accepted.
* `cell_deps` - <em>Vec<[UdtDep](#type-udtdep)></em>, The cell deps of the UDT.
---

<a id="#type-udtcelldep"></a>
### Type `UdtCellDep`

The UDT cell dep which is used to identify the UDT configuration for a Fiber Node


#### Fields

* `out_point` - <em>`OutPointWrapper`</em>, The out point of the cell dep.
* `dep_type` - <em>`DepType`</em>, The type of the cell dep.
---

<a id="#type-udtcfginfos"></a>
### Type `UdtCfgInfos`

A list of UDT configuration infos.



---

<a id="#type-udtdep"></a>
### Type `UdtDep`

Udt script on-chain dependencies.


#### Fields

* `cell_dep` - <em>Option<[UdtCellDep](#type-udtcelldep)></em>, cell dep described by out_point.
* `type_id` - <em>`Option<Script>`</em>, cell dep described by type ID.
---

<a id="#type-udtscript"></a>
### Type `UdtScript`

The UDT script which is used to identify the UDT configuration for a Fiber Node


#### Fields

* `code_hash` - <em>`H256`</em>, The code hash of the script.
* `hash_type` - <em>`ScriptHashType`</em>, The hash type of the script.
* `args` - <em>`String`</em>, The arguments of the script.
---

