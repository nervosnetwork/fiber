
# Fiber Network Node RPC

The RPC module provides a set of APIs for developers to interact with FNN. Please note that APIs are not stable yet and may change in the future.

Allowing arbitrary machines to access the JSON-RPC port (using the `rpc.listening_addr` configuration option) is **dangerous and strongly discouraged**. Please strictly limit the access to only trusted machines.

You may refer to the e2e test cases in the `tests/bruno/e2e` directory for examples of how to use the RPC.

**We are in a actively developing stage, don't hesitate to [report issues](https://github.com/nervosnetwork/fiber/issues) or ask for help in the [channel of the Nervos dev community](https://discord.gg/c5gntbFd).**

<!--**NOTE:** the content below is generated by gen_doc -->

* [RPC Methods](#rpc-methods)


    * [Module Cch](#module-cch)
        * [Method `send_btc`](#cch-send_btc)
        * [Method `receive_btc`](#cch-receive_btc)
        * [Method `get_receive_btc_order`](#cch-get_receive_btc_order)
    * [Module Channel](#module-channel)
        * [Method `open_channel`](#channel-open_channel)
        * [Method `accept_channel`](#channel-accept_channel)
        * [Method `abandon_channel`](#channel-abandon_channel)
        * [Method `list_channels`](#channel-list_channels)
        * [Method `shutdown_channel`](#channel-shutdown_channel)
        * [Method `update_channel`](#channel-update_channel)
    * [Module Dev](#module-dev)
        * [Method `commitment_signed`](#dev-commitment_signed)
        * [Method `add_tlc`](#dev-add_tlc)
        * [Method `remove_tlc`](#dev-remove_tlc)
        * [Method `submit_commitment_transaction`](#dev-submit_commitment_transaction)
        * [Method `remove_watch_channel`](#dev-remove_watch_channel)
    * [Module Graph](#module-graph)
        * [Method `graph_nodes`](#graph-graph_nodes)
        * [Method `graph_channels`](#graph-graph_channels)
    * [Module Info](#module-info)
        * [Method `node_info`](#info-node_info)
    * [Module Invoice](#module-invoice)
        * [Method `new_invoice`](#invoice-new_invoice)
        * [Method `parse_invoice`](#invoice-parse_invoice)
        * [Method `get_invoice`](#invoice-get_invoice)
        * [Method `cancel_invoice`](#invoice-cancel_invoice)
    * [Module Payment](#module-payment)
        * [Method `send_payment`](#payment-send_payment)
        * [Method `get_payment`](#payment-get_payment)
    * [Module Peer](#module-peer)
        * [Method `connect_peer`](#peer-connect_peer)
        * [Method `disconnect_peer`](#peer-disconnect_peer)
        * [Method `list_peers`](#peer-list_peers)
* [RPC Types](#rpc-types)

    * [Type `Attribute`](#type-attribute)
    * [Type `CchOrderStatus`](#type-cchorderstatus)
    * [Type `Channel`](#type-channel)
    * [Type `ChannelInfo`](#type-channelinfo)
    * [Type `ChannelState`](#type-channelstate)
    * [Type `ChannelUpdateInfo`](#type-channelupdateinfo)
    * [Type `CkbInvoice`](#type-ckbinvoice)
    * [Type `CkbInvoiceStatus`](#type-ckbinvoicestatus)
    * [Type `Currency`](#type-currency)
    * [Type `Hash256`](#type-hash256)
    * [Type `HashAlgorithm`](#type-hashalgorithm)
    * [Type `HopHint`](#type-hophint)
    * [Type `InvoiceData`](#type-invoicedata)
    * [Type `InvoiceSignature`](#type-invoicesignature)
    * [Type `NodeInfo`](#type-nodeinfo)
    * [Type `PaymentCustomRecords`](#type-paymentcustomrecords)
    * [Type `PaymentSessionStatus`](#type-paymentsessionstatus)
    * [Type `PeerInfo`](#type-peerinfo)
    * [Type `Pubkey`](#type-pubkey)
    * [Type `RemoveTlcReason`](#type-removetlcreason)
    * [Type `SessionRouteNode`](#type-sessionroutenode)
    * [Type `UdtArgInfo`](#type-udtarginfo)
    * [Type `UdtCellDep`](#type-udtcelldep)
    * [Type `UdtCfgInfos`](#type-udtcfginfos)
    * [Type `UdtDep`](#type-udtdep)
    * [Type `UdtScript`](#type-udtscript)

## RPC Modules

<a id="cch"></a>
### Module `Cch`
RPC module for cross chain hub demonstration.


<a id="cch-send_btc"></a>
#### Method `send_btc`

Send BTC to a address.

##### Params

* `btc_pay_req` - <em>`String`</em>, Bitcoin payment request string
* `currency` - <em>[Currency](#type-currency)</em>, Request currency

##### Returns

* `timestamp` - <em>`u64`</em>, Seconds since epoch when the order is created
* `expiry` - <em>`u64`</em>, Seconds after timestamp that the order expires
* `ckb_final_tlc_expiry_delta` - <em>`u64`</em>, The minimal expiry in seconds of the final TLC in the CKB network
* `currency` - <em>[Currency](#type-currency)</em>, Request currency
* `wrapped_btc_type_script` - <em>`ckb_jsonrpc_types::Script`</em>, Wrapped BTC type script
* `btc_pay_req` - <em>`String`</em>, Payment request for BTC
* `ckb_pay_req` - <em>`String`</em>, Payment request for CKB
* `payment_hash` - <em>`String`</em>, Payment hash for the HTLC for both CKB and BTC.
* `amount_sats` - <em>`u128`</em>, Amount required to pay in Satoshis, including fee
* `fee_sats` - <em>`u128`</em>, Fee in Satoshis
* `status` - <em>[CchOrderStatus](#type-cchorderstatus)</em>, Order status

---



<a id="cch-receive_btc"></a>
#### Method `receive_btc`

Receive BTC from a payment hash.

##### Params

* `payment_hash` - <em>`String`</em>, Payment hash for the HTLC for both CKB and BTC.
* `channel_id` - <em>[Hash256](#type-hash256)</em>, Channel ID for the CKB payment.
* `amount_sats` - <em>`u128`</em>, How many satoshis to receive, excluding cross-chain hub fee.
* `final_tlc_expiry` - <em>`u64`</em>, Expiry set for the HTLC for the CKB payment to the payee.

##### Returns

* `timestamp` - <em>`u64`</em>, Seconds since epoch when the order is created
* `expiry` - <em>`u64`</em>, Seconds after timestamp that the order expires
* `ckb_final_tlc_expiry_delta` - <em>`u64`</em>, The minimal expiry in seconds of the final TLC in the CKB network
* `wrapped_btc_type_script` - <em>`ckb_jsonrpc_types::Script`</em>, Wrapped BTC type script
* `btc_pay_req` - <em>`String`</em>, Payment request for BTC
* `payment_hash` - <em>`String`</em>, Payment hash for the HTLC for both CKB and BTC.
* `channel_id` - <em>[Hash256](#type-hash256)</em>, Channel ID for the CKB payment.
* `tlc_id` - <em>`Option<u64>`</em>, TLC ID for the CKB payment.
* `amount_sats` - <em>`u128`</em>, Amount will be received by the payee
* `fee_sats` - <em>`u128`</em>, Fee in Satoshis
* `status` - <em>[CchOrderStatus](#type-cchorderstatus)</em>, Order status

---



<a id="cch-get_receive_btc_order"></a>
#### Method `get_receive_btc_order`

Get receive BTC order by payment hash.

##### Params

* `payment_hash` - <em>`String`</em>, Payment hash for the HTLC for both CKB and BTC.

##### Returns

* `timestamp` - <em>`u64`</em>, Seconds since epoch when the order is created
* `expiry` - <em>`u64`</em>, Seconds after timestamp that the order expires
* `ckb_final_tlc_expiry_delta` - <em>`u64`</em>, The minimal expiry in seconds of the final TLC in the CKB network
* `wrapped_btc_type_script` - <em>`ckb_jsonrpc_types::Script`</em>, Wrapped BTC type script
* `btc_pay_req` - <em>`String`</em>, Payment request for BTC
* `payment_hash` - <em>`String`</em>, Payment hash for the HTLC for both CKB and BTC.
* `channel_id` - <em>[Hash256](#type-hash256)</em>, Channel ID for the CKB payment.
* `tlc_id` - <em>`Option<u64>`</em>, TLC ID for the CKB payment.
* `amount_sats` - <em>`u128`</em>, Amount will be received by the payee
* `fee_sats` - <em>`u128`</em>, Fee in Satoshis
* `status` - <em>[CchOrderStatus](#type-cchorderstatus)</em>, Order status

---



<a id="channel"></a>
### Module `Channel`
RPC module for channel management.


<a id="channel-open_channel"></a>
#### Method `open_channel`

Attempts to open a channel with a peer.

##### Params

* `peer_id` - <em>`PeerId`</em>, The peer ID to open a channel with, the peer must be connected through the [connect_peer](#peer-connect_peer) rpc first.
* `funding_amount` - <em>`u128`</em>, The amount of CKB or UDT to fund the channel with.
* `public` - <em>`Option<bool>`</em>, Whether this is a public channel (will be broadcasted to network, and can be used to forward TLCs), an optional parameter, default value is true.
* `funding_udt_type_script` - <em>`Option<Script>`</em>, The type script of the UDT to fund the channel with, an optional parameter.
* `shutdown_script` - <em>`Option<Script>`</em>, The script used to receive the channel balance, an optional parameter, default value is the secp256k1_blake160_sighash_all script corresponding to the configured private key.
* `commitment_delay_epoch` - <em>`Option<EpochNumberWithFraction>`</em>, The delay time for the commitment transaction, must be an [EpochNumberWithFraction](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0017-tx-valid-since/e-i-l-encoding.png) in u64 format, an optional parameter, default value is 24 hours.
* `commitment_fee_rate` - <em>`Option<u64>`</em>, The fee rate for the commitment transaction, an optional parameter.
* `funding_fee_rate` - <em>`Option<u64>`</em>, The fee rate for the funding transaction, an optional parameter.
* `tlc_expiry_delta` - <em>`Option<u64>`</em>, The expiry delta to forward a tlc, in milliseconds, default to 1 day, which is 24 * 60 * 60 * 1000 milliseconds
 This parameter can be updated with rpc `update_channel` later.
* `tlc_min_value` - <em>`Option<u128>`</em>, The minimum value for a TLC our side can send,
 an optional parameter, default is 0, which means we can send any TLC is larger than 0.
 This parameter can be updated with rpc `update_channel` later.
* `tlc_fee_proportional_millionths` - <em>`Option<u128>`</em>, The fee proportional millionths for a TLC, proportional to the amount of the forwarded tlc.
 The unit is millionths of the amount. default is 1000 which means 0.1%.
 This parameter can be updated with rpc `update_channel` later.
 Not that, we use outbound channel to calculate the fee for TLC forwarding. For example,
 if we have a path A -> B -> C, then the fee B requires for TLC forwarding, is calculated
 the channel configuration of B and C, not A and B.
* `max_tlc_value_in_flight` - <em>`Option<u128>`</em>, The maximum value in flight for TLCs, an optional parameter.
 This parameter can not be updated after channel is opened.
* `max_tlc_number_in_flight` - <em>`Option<u64>`</em>, The maximum number of TLCs that can be accepted, an optional parameter, default is 125
 This parameter can not be updated after channel is opened.

##### Returns

* `temporary_channel_id` - <em>[Hash256](#type-hash256)</em>, The temporary channel ID of the channel being opened

---



<a id="channel-accept_channel"></a>
#### Method `accept_channel`

Accepts a channel opening request from a peer.

##### Params

* `temporary_channel_id` - <em>[Hash256](#type-hash256)</em>, The temporary channel ID of the channel to accept
* `funding_amount` - <em>`u128`</em>, The amount of CKB or UDT to fund the channel with
* `shutdown_script` - <em>`Option<Script>`</em>, The script used to receive the channel balance, an optional parameter,
 default value is the secp256k1_blake160_sighash_all script corresponding to the configured private key
* `max_tlc_value_in_flight` - <em>`Option<u128>`</em>, The max tlc sum value in flight for the channel, default is u128::MAX
 This parameter can not be updated after channel is opened.
* `max_tlc_number_in_flight` - <em>`Option<u64>`</em>, The max tlc number in flight send from our side, default is 125
 This parameter can not be updated after channel is opened.
* `tlc_min_value` - <em>`Option<u128>`</em>, The minimum value for a TLC our side can send,
 an optional parameter, default is 0, which means we can send any TLC is larger than 0.
 This parameter can be updated with rpc `update_channel` later.
* `tlc_fee_proportional_millionths` - <em>`Option<u128>`</em>, The fee proportional millionths for a TLC, proportional to the amount of the forwarded tlc.
 The unit is millionths of the amount. default is 1000 which means 0.1%.
 This parameter can be updated with rpc `update_channel` later.
 Not that, we use outbound channel to calculate the fee for TLC forwarding. For example,
 if we have a path A -> B -> C, then the fee B requires for TLC forwarding, is calculated
 the channel configuration of B and C, not A and B.
* `tlc_expiry_delta` - <em>`Option<u64>`</em>, The expiry delta to forward a tlc, in milliseconds, default to 1 day, which is 24 * 60 * 60 * 1000 milliseconds
 This parameter can be updated with rpc `update_channel` later.

##### Returns

* `channel_id` - <em>[Hash256](#type-hash256)</em>, The final ID of the channel that was accepted, it's different from the temporary channel ID

---



<a id="channel-abandon_channel"></a>
#### Method `abandon_channel`

Abandon a channel, this will remove the channel from the channel manager and DB.
 Only channels not in Ready or Closed state can be abandoned.

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, The temporary channel ID or real channel ID of the channel being abandoned

##### Returns

* None

---



<a id="channel-list_channels"></a>
#### Method `list_channels`

Lists all channels.

##### Params

* `peer_id` - <em>`Option<PeerId>`</em>, The peer ID to list channels for, an optional parameter, if not provided, all channels will be listed
* `include_closed` - <em>`Option<bool>`</em>, Whether to include closed channels in the list, an optional parameter, default value is false

##### Returns

* `channels` - <em>Vec<[Channel](#type-channel)></em>, The list of channels

---



<a id="channel-shutdown_channel"></a>
#### Method `shutdown_channel`

Shuts down a channel.

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, The channel ID of the channel to shut down
* `close_script` - <em>`Option<Script>`</em>, The script used to receive the channel balance, only support secp256k1_blake160_sighash_all script for now
* `fee_rate` - <em>`Option<u64>`</em>, The fee rate for the closing transaction, the fee will be deducted from the closing initiator's channel balance
* `force` - <em>`Option<bool>`</em>, Whether to force the channel to close, when set to false, `close_script` and `fee_rate` should be set, default is false.
 When set to true, `close_script` and `fee_rate` will be ignored and will use the default value when opening the channel.

##### Returns

* None

---



<a id="channel-update_channel"></a>
#### Method `update_channel`

Updates a channel.

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, The channel ID of the channel to update
* `enabled` - <em>`Option<bool>`</em>, Whether the channel is enabled
* `tlc_expiry_delta` - <em>`Option<u64>`</em>, The expiry delta for the TLC locktime
* `tlc_minimum_value` - <em>`Option<u128>`</em>, The minimum value for a TLC
* `tlc_fee_proportional_millionths` - <em>`Option<u128>`</em>, The fee proportional millionths for a TLC

##### Returns

* None

---



<a id="dev"></a>
### Module `Dev`
RPC module for development purposes, this module is not intended to be used in production.
 This module will be disabled in release build.


<a id="dev-commitment_signed"></a>
#### Method `commitment_signed`

Sends a commitment_signed message to the peer.

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, The channel ID of the channel to send the commitment_signed message to

##### Returns

* None

---



<a id="dev-add_tlc"></a>
#### Method `add_tlc`

Adds a TLC to a channel.

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, The channel ID of the channel to add the TLC to
* `amount` - <em>`u128`</em>, The amount of the TLC
* `payment_hash` - <em>[Hash256](#type-hash256)</em>, The payment hash of the TLC
* `expiry` - <em>`u64`</em>, The expiry of the TLC
* `hash_algorithm` - <em>Option<[HashAlgorithm](#type-hashalgorithm)></em>, The hash algorithm of the TLC

##### Returns

* `tlc_id` - <em>`u64`</em>, The ID of the TLC

---



<a id="dev-remove_tlc"></a>
#### Method `remove_tlc`

Removes a TLC from a channel.

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, The channel ID of the channel to remove the TLC from
* `tlc_id` - <em>`u64`</em>, The ID of the TLC to remove
* `reason` - <em>[RemoveTlcReason](#type-removetlcreason)</em>, The reason for removing the TLC, either a 32-byte hash for preimage fulfillment or an u32 error code for removal

##### Returns

* None

---



<a id="dev-submit_commitment_transaction"></a>
#### Method `submit_commitment_transaction`

Submit a commitment transaction to the chain

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, Channel ID
* `commitment_number` - <em>`u64`</em>, Commitment number

##### Returns

* `tx_hash` - <em>[Hash256](#type-hash256)</em>, Submitted commitment transaction hash

---



<a id="dev-remove_watch_channel"></a>
#### Method `remove_watch_channel`

Remove a watched channel from the watchtower store

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, Channel ID

##### Returns

* None

---



<a id="graph"></a>
### Module `Graph`
RPC module for graph management.


<a id="graph-graph_nodes"></a>
#### Method `graph_nodes`

Get the list of nodes in the network graph.

##### Params

* `limit` - <em>`Option<u64>`</em>, The maximum number of nodes to return.
* `after` - <em>`Option<JsonBytes>`</em>, The cursor to start returning nodes from.

##### Returns

* `nodes` - <em>Vec<[NodeInfo](#type-nodeinfo)></em>, The list of nodes.
* `last_cursor` - <em>`JsonBytes`</em>, The last cursor.

---



<a id="graph-graph_channels"></a>
#### Method `graph_channels`

Get the list of channels in the network graph.

##### Params

* `limit` - <em>`Option<u64>`</em>, The maximum number of channels to return.
* `after` - <em>`Option<JsonBytes>`</em>, The cursor to start returning channels from.

##### Returns

* `channels` - <em>Vec<[ChannelInfo](#type-channelinfo)></em>, A list of channels.
* `last_cursor` - <em>`JsonBytes`</em>, The last cursor for pagination.

---



<a id="info"></a>
### Module `Info`
The RPC module for node information.


<a id="info-node_info"></a>
#### Method `node_info`

Get the node information.

##### Params
* None

##### Returns

* `version` - <em>`String`</em>, The version of the node software.
* `commit_hash` - <em>`String`</em>, The commit hash of the node software.
* `node_id` - <em>[Pubkey](#type-pubkey)</em>, The identity public key of the node.
* `node_name` - <em>`Option<String>`</em>, The optional name of the node.
* `addresses` - <em>`Vec<MultiAddr>`</em>, A list of multi-addresses associated with the node.
* `chain_hash` - <em>[Hash256](#type-hash256)</em>, The hash of the blockchain that the node is connected to.
* `open_channel_auto_accept_min_ckb_funding_amount` - <em>`u64`</em>, The minimum CKB funding amount for automatically accepting open channel requests, serialized as a hexadecimal string.
* `auto_accept_channel_ckb_funding_amount` - <em>`u64`</em>, The CKB funding amount for automatically accepting channel requests, serialized as a hexadecimal string.
* `default_funding_lock_script` - <em>`Script`</em>, The default funding lock script for the node.
* `tlc_expiry_delta` - <em>`u64`</em>, The locktime expiry delta for Time-Locked Contracts (TLC), serialized as a hexadecimal string.
* `tlc_min_value` - <em>`u128`</em>, The minimum value for Time-Locked Contracts (TLC) we can send, serialized as a hexadecimal string.
* `tlc_max_value` - <em>`u128`</em>, The maximum value for Time-Locked Contracts (TLC) we can send, serialized as a hexadecimal string, `0` means no maximum value limit.
* `tlc_fee_proportional_millionths` - <em>`u128`</em>, The fee (to forward payments) proportional to the value of Time-Locked Contracts (TLC), expressed in millionths and serialized as a hexadecimal string.
* `channel_count` - <em>`u32`</em>, The number of channels associated with the node, serialized as a hexadecimal string.
* `pending_channel_count` - <em>`u32`</em>, The number of pending channels associated with the node, serialized as a hexadecimal string.
* `peers_count` - <em>`u32`</em>, The number of peers connected to the node, serialized as a hexadecimal string.
* `udt_cfg_infos` - <em>[UdtCfgInfos](#type-udtcfginfos)</em>, Configuration information for User-Defined Tokens (UDT) associated with the node.

---



<a id="invoice"></a>
### Module `Invoice`
RPC module for invoice management.


<a id="invoice-new_invoice"></a>
#### Method `new_invoice`

Generates a new invoice.

##### Params

* `amount` - <em>`u128`</em>, The amount of the invoice.
* `description` - <em>`Option<String>`</em>, The description of the invoice.
* `currency` - <em>[Currency](#type-currency)</em>, The currency of the invoice.
* `payment_preimage` - <em>[Hash256](#type-hash256)</em>, The payment preimage of the invoice.
* `expiry` - <em>`Option<u64>`</em>, The expiry time of the invoice, in seconds.
* `fallback_address` - <em>`Option<String>`</em>, The fallback address of the invoice.
* `final_expiry_delta` - <em>`Option<u64>`</em>, The final HTLC timeout of the invoice, in milliseconds.
* `udt_type_script` - <em>`Option<Script>`</em>, The UDT type script of the invoice.
* `hash_algorithm` - <em>Option<[HashAlgorithm](#type-hashalgorithm)></em>, The hash algorithm of the invoice.

##### Returns

* `invoice_address` - <em>`String`</em>, The encoded invoice address.
* `invoice` - <em>[CkbInvoice](#type-ckbinvoice)</em>, The invoice.

---



<a id="invoice-parse_invoice"></a>
#### Method `parse_invoice`

Parses a encoded invoice.

##### Params

* `invoice` - <em>`String`</em>, The encoded invoice address.

##### Returns

* `invoice` - <em>[CkbInvoice](#type-ckbinvoice)</em>, The invoice.

---



<a id="invoice-get_invoice"></a>
#### Method `get_invoice`

Retrieves an invoice.

##### Params

* `payment_hash` - <em>[Hash256](#type-hash256)</em>, The payment hash of the invoice.

##### Returns

* `invoice_address` - <em>`String`</em>, The encoded invoice address.
* `invoice` - <em>[CkbInvoice](#type-ckbinvoice)</em>, The invoice.
* `status` - <em>[CkbInvoiceStatus](#type-ckbinvoicestatus)</em>, The invoice status

---



<a id="invoice-cancel_invoice"></a>
#### Method `cancel_invoice`

Cancels an invoice, only when invoice is in status `Open` can be canceled.

##### Params

* `payment_hash` - <em>[Hash256](#type-hash256)</em>, The payment hash of the invoice.

##### Returns

* `invoice_address` - <em>`String`</em>, The encoded invoice address.
* `invoice` - <em>[CkbInvoice](#type-ckbinvoice)</em>, The invoice.
* `status` - <em>[CkbInvoiceStatus](#type-ckbinvoicestatus)</em>, The invoice status

---



<a id="payment"></a>
### Module `Payment`
RPC module for channel management.


<a id="payment-send_payment"></a>
#### Method `send_payment`

Sends a payment to a peer.

##### Params

* `target_pubkey` - <em>Option<[Pubkey](#type-pubkey)></em>, the identifier of the payment target
* `amount` - <em>`Option<u128>`</em>, the amount of the payment
* `payment_hash` - <em>Option<[Hash256](#type-hash256)></em>, the hash to use within the payment's HTLC
* `final_tlc_expiry_delta` - <em>`Option<u64>`</em>, the TLC expiry delta should be used to set the timelock for the final hop, in milliseconds
* `tlc_expiry_limit` - <em>`Option<u64>`</em>, the TLC expiry limit for the whole payment, in milliseconds, each hop is with a default tlc delta of 1 day
 suppose the payment router is with N hops, the total tlc expiry limit is at least (N-1) days
 this is also the default value for the payment if this parameter is not provided
* `invoice` - <em>`Option<String>`</em>, the encoded invoice to send to the recipient
* `timeout` - <em>`Option<u64>`</em>, the payment timeout in seconds, if the payment is not completed within this time, it will be cancelled
* `max_fee_amount` - <em>`Option<u128>`</em>, the maximum fee amounts in shannons that the sender is willing to pay
* `max_parts` - <em>`Option<u64>`</em>, max parts for the payment, only used for multi-part payments
* `keysend` - <em>`Option<bool>`</em>, keysend payment
* `udt_type_script` - <em>`Option<Script>`</em>, udt type script for the payment
* `allow_self_payment` - <em>`Option<bool>`</em>, allow self payment, default is false
* `custom_records` - <em>Option<[PaymentCustomRecords](#type-paymentcustomrecords)></em>, Some custom records for the payment which contains a map of u32 to Vec<u8>
 The key is the record type, and the value is the serialized data
 For example:
 ```json
 "custom_records": {
    "0x1": "0x01020304",
    "0x2": "0x05060708",
    "0x3": "0x090a0b0c",
    "0x4": "0x0d0e0f10010d090a0b0c"
  }
 ```
* `hop_hints` - <em>Option<Vec<[HopHint](#type-hophint)>></em>, Optional route hints to reach the destination through private channels.
 Note:
    1. this is only used for the private channels with the last hop.
    2. `hop_hints` is only a `hint` for routing algorithm,
       it is not a guarantee that the payment will be routed through the specified channels,
       it is up to the routing algorithm to decide whether to use the hints or not.

 For example `(pubkey, channel_outpoint, fee_rate, tlc_expiry_delta)` suggest path router
 to use the channel of `channel_outpoint` at hop with `pubkey` to forward the payment
 and the fee rate is `fee_rate` and tlc_expiry_delta is `tlc_expiry_delta`.
* `dry_run` - <em>`Option<bool>`</em>, dry_run for payment, used for check whether we can build valid router and the fee for this payment,
 it's useful for the sender to double check the payment before sending it to the network,
 default is false

##### Returns

* `payment_hash` - <em>[Hash256](#type-hash256)</em>, The payment hash of the payment
* `status` - <em>[PaymentSessionStatus](#type-paymentsessionstatus)</em>, The status of the payment
* `created_at` - <em>`u64`</em>, The time the payment was created at, in milliseconds from UNIX epoch
* `last_updated_at` - <em>`u64`</em>, The time the payment was last updated at, in milliseconds from UNIX epoch
* `failed_error` - <em>`Option<String>`</em>, The error message if the payment failed
* `fee` - <em>`u128`</em>, fee paid for the payment
* `custom_records` - <em>Option<[PaymentCustomRecords](#type-paymentcustomrecords)></em>, The custom records to be included in the payment.
* `router` - <em>Vec<[SessionRouteNode](#type-sessionroutenode)></em>, The router is a list of nodes that the payment will go through.
 We store in the payment session and then will use it to track the payment history.
 The router is a list of nodes that the payment will go through.
 For example:
    `A(amount, channel) -> B -> C -> D`
 means A will send `amount` with `channel` to B.

---



<a id="payment-get_payment"></a>
#### Method `get_payment`

Retrieves a payment.

##### Params

* `payment_hash` - <em>[Hash256](#type-hash256)</em>, The payment hash of the payment to retrieve

##### Returns

* `payment_hash` - <em>[Hash256](#type-hash256)</em>, The payment hash of the payment
* `status` - <em>[PaymentSessionStatus](#type-paymentsessionstatus)</em>, The status of the payment
* `created_at` - <em>`u64`</em>, The time the payment was created at, in milliseconds from UNIX epoch
* `last_updated_at` - <em>`u64`</em>, The time the payment was last updated at, in milliseconds from UNIX epoch
* `failed_error` - <em>`Option<String>`</em>, The error message if the payment failed
* `fee` - <em>`u128`</em>, fee paid for the payment
* `custom_records` - <em>Option<[PaymentCustomRecords](#type-paymentcustomrecords)></em>, The custom records to be included in the payment.
* `router` - <em>Vec<[SessionRouteNode](#type-sessionroutenode)></em>, The router is a list of nodes that the payment will go through.
 We store in the payment session and then will use it to track the payment history.
 The router is a list of nodes that the payment will go through.
 For example:
    `A(amount, channel) -> B -> C -> D`
 means A will send `amount` with `channel` to B.

---



<a id="peer"></a>
### Module `Peer`
RPC module for peer management.


<a id="peer-connect_peer"></a>
#### Method `connect_peer`

Connect to a peer.

##### Params

* `address` - <em>`MultiAddr`</em>, The address of the peer to connect to.
* `save` - <em>`Option<bool>`</em>, Whether to save the peer address to the peer store.

##### Returns

* None

---



<a id="peer-disconnect_peer"></a>
#### Method `disconnect_peer`

Disconnect from a peer.

##### Params

* `peer_id` - <em>`PeerId`</em>, The peer ID of the peer to disconnect.

##### Returns

* None

---



<a id="peer-list_peers"></a>
#### Method `list_peers`

List connected peers

##### Params
* None

##### Returns

* `peers` - <em>Vec<[PeerInfo](#type-peerinfo)></em>, A list of connected peers.

---




## RPC Types


<a id="#type-attribute"></a>
### Type `Attribute`

The attributes of the invoice


#### Enum with values of

* `FinalHtlcTimeout` - <em>u64</em>, The final tlc time out, in milliseconds
* `FinalHtlcMinimumExpiryDelta` - <em>u64</em>, The final tlc minimum expiry delta, in milliseconds, default is 1 day
* `ExpiryTime` - <em>Duration</em>, The expiry time of the invoice, in seconds
* `Description` - <em>String</em>, The description of the invoice
* `FallbackAddr` - <em>String</em>, The fallback address of the invoice
* `UdtScript` - <em>[CkbScript](#type-ckbscript)</em>, The udt type script of the invoice
* `PayeePublicKey` - <em>PublicKey</em>, The payee public key of the invoice
* `HashAlgorithm` - <em>[HashAlgorithm](#type-hashalgorithm)</em>, The hash algorithm of the invoice
* `Feature` - <em>u64</em>, The feature flags of the invoice
---

<a id="#type-cchorderstatus"></a>
### Type `CchOrderStatus`

The status of a cross-chain hub order, will update as the order progresses.


#### Enum with values of

* `Pending` - Order is created and has not send out payments yet.
* `Accepted` - HTLC in the first half is accepted.
* `InFlight` - There's an outgoing payment in flight for the second half.
* `Succeeded` - Order is settled.
* `Failed` - Order is failed.
---

<a id="#type-channel"></a>
### Type `Channel`

The channel data structure


#### Fields

* `channel_id` - <em>[Hash256](#type-hash256)</em>, The channel ID
* `is_public` - <em>bool</em>, Whether the channel is public
* `channel_outpoint` - <em>Option<OutPoint></em>, The outpoint of the channel
* `peer_id` - <em>PeerId</em>, The peer ID of the channel
* `funding_udt_type_script` - <em>Option<Script></em>, The UDT type script of the channel
* `state` - <em>[ChannelState](#type-channelstate)</em>, The state of the channel
* `local_balance` - <em>u128</em>, The local balance of the channel
* `offered_tlc_balance` - <em>u128</em>, The offered balance of the channel
* `remote_balance` - <em>u128</em>, The remote balance of the channel
* `received_tlc_balance` - <em>u128</em>, The received balance of the channel
* `latest_commitment_transaction_hash` - <em>Option<H256></em>, The hash of the latest commitment transaction
* `created_at` - <em>u64</em>, The time the channel was created at, in milliseconds from UNIX epoch
* `enabled` - <em>bool</em>, Whether the channel is enabled
* `tlc_expiry_delta` - <em>u64</em>, The expiry delta to forward a tlc, in milliseconds, default to 1 day, which is 24 * 60 * 60 * 1000 milliseconds
 This parameter can be updated with rpc `update_channel` later.
* `tlc_fee_proportional_millionths` - <em>u128</em>, The fee proportional millionths for a TLC, proportional to the amount of the forwarded tlc.
 The unit is millionths of the amount. default is 1000 which means 0.1%.
 This parameter can be updated with rpc `update_channel` later.
 Not that, we use outbound channel to calculate the fee for TLC forwarding. For example,
 if we have a path A -> B -> C, then the fee B requires for TLC forwarding, is calculated
 the channel configuration of B and C, not A and B.
---

<a id="#type-channelinfo"></a>
### Type `ChannelInfo`

The Channel information.


#### Fields

* `channel_outpoint` - <em>OutPoint</em>, The outpoint of the channel.
* `node1` - <em>[Pubkey](#type-pubkey)</em>, The identity public key of the first node.
* `node2` - <em>[Pubkey](#type-pubkey)</em>, The identity public key of the second node.
* `created_timestamp` - <em>u64</em>, The created timestamp of the channel, which is the block header timestamp of the block
 that contains the channel funding transaction.
* `update_info_of_node1` - <em>Option<[ChannelUpdateInfo](#type-channelupdateinfo)></em>, The update info from node1 to node2, e.g. timestamp, fee_rate, tlc_expiry_delta, tlc_minimum_value
* `update_info_of_node2` - <em>Option<[ChannelUpdateInfo](#type-channelupdateinfo)></em>, The update info from node2 to node1, e.g. timestamp, fee_rate, tlc_expiry_delta, tlc_minimum_value
* `capacity` - <em>u128</em>, The capacity of the channel.
* `chain_hash` - <em>[Hash256](#type-hash256)</em>, The chain hash of the channel.
* `udt_type_script` - <em>Option<Script></em>, The UDT type script of the channel.
---

<a id="#type-channelstate"></a>
### Type `ChannelState`

The state of a channel


#### Enum with values of

* `NegotiatingFunding` - <em>NegotiatingFundingFlags</em>, We are negotiating the parameters required for the channel prior to funding it.
* `CollaboratingFundingTx` - <em>CollaboratingFundingTxFlags</em>, We're collaborating with the other party on the funding transaction.
* `SigningCommitment` - <em>SigningCommitmentFlags</em>, We have collaborated over the funding and are now waiting for CommitmentSigned messages.
* `AwaitingTxSignatures` - <em>AwaitingTxSignaturesFlags</em>, We've received and sent `commitment_signed` and are now waiting for both
 party to collaborate on creating a valid funding transaction.
* `AwaitingChannelReady` - <em>AwaitingChannelReadyFlags</em>, We've received/sent `funding_created` and `funding_signed` and are thus now waiting on the
 funding transaction to confirm.
* `ChannelReady` - Both we and our counterparty consider the funding transaction confirmed and the channel is
 now operational.
* `ShuttingDown` - <em>ShuttingDownFlags</em>, We've successfully negotiated a `closing_signed` dance. At this point, the `ChannelManager`
* `Closed` - <em>CloseFlags</em>, This channel is closed.
---

<a id="#type-channelupdateinfo"></a>
### Type `ChannelUpdateInfo`

The channel update info with a single direction of channel


#### Fields

* `timestamp` - <em>u64</em>, The timestamp is the time when the channel update was received by the node.
* `enabled` - <em>bool</em>, Whether the channel can be currently used for payments (in this one direction).
* `outbound_liquidity` - <em>Option<u128></em>, The exact amount of balance that we can send to the other party via the channel.
* `tlc_expiry_delta` - <em>u64</em>, The difference in htlc expiry values that you must have when routing through this channel (in milliseconds).
* `tlc_minimum_value` - <em>u128</em>, The minimum value, which must be relayed to the next hop via the channel
* `fee_rate` - <em>u64</em>, The forwarding fee rate for the channel.
---

<a id="#type-ckbinvoice"></a>
### Type `CkbInvoice`

Represents a syntactically and semantically correct lightning BOLT11 invoice

 There are three ways to construct a `CkbInvoice`:
  1. using [`CkbInvoiceBuilder`]
  2. using `str::parse::<CkbInvoice>(&str)` (see [`CkbInvoice::from_str`])


#### Fields

* `currency` - <em>[Currency](#type-currency)</em>, The currency of the invoice
* `amount` - <em>Option<u128></em>, The amount of the invoice
* `signature` - <em>Option<[InvoiceSignature](#type-invoicesignature)></em>, The signature of the invoice
* `data` - <em>[InvoiceData](#type-invoicedata)</em>, The invoice data, including the payment hash, timestamp and other attributes
---

<a id="#type-ckbinvoicestatus"></a>
### Type `CkbInvoiceStatus`

The currency of the invoice, can also used to represent the CKB network chain.


#### Enum with values of

* `Open` - The invoice is open and can be paid.
* `Cancelled` - The invoice is cancelled.
* `Expired` - The invoice is expired.
* `Received` - The invoice is received, but not settled yet.
* `Paid` - The invoice is paid.
---

<a id="#type-currency"></a>
### Type `Currency`

The currency of the invoice, can also used to represent the CKB network chain.


#### Enum with values of

* `Fibb` - The mainnet currency of CKB.
* `Fibt` - The testnet currency of the CKB network.
* `Fibd` - The devnet currency of the CKB network.
---

<a id="#type-hash256"></a>
### Type `Hash256`

A 256-bit hash digest, used as identifier of channel, payment, transaction hash etc.



---

<a id="#type-hashalgorithm"></a>
### Type `HashAlgorithm`

HashAlgorithm is the hash algorithm used in the hash lock.


#### Enum with values of

* `CkbHash` - The default hash algorithm, CkbHash
* `Sha256` - The sha256 hash algorithm
---

<a id="#type-hophint"></a>
### Type `HopHint`

A hop hint is a hint for a node to use a specific channel.


#### Fields

* `pubkey` - <em>[Pubkey](#type-pubkey)</em>, The public key of the node
* `channel_outpoint` - <em>OutPoint</em>, The outpoint of the channel
* `fee_rate` - <em>u64</em>, The fee rate to use this hop to forward the payment.
* `tlc_expiry_delta` - <em>u64</em>, The TLC expiry delta to use this hop to forward the payment.
---

<a id="#type-invoicedata"></a>
### Type `InvoiceData`

The metadata of the invoice


#### Fields

* `timestamp` - <em>u128</em>, The timestamp of the invoice
* `payment_hash` - <em>[Hash256](#type-hash256)</em>, The payment hash of the invoice
* `attrs` - <em>Vec<[Attribute](#type-attribute)></em>, The attributes of the invoice, e.g. description, expiry time, etc.
---

<a id="#type-invoicesignature"></a>
### Type `InvoiceSignature`

Recoverable signature



---

<a id="#type-nodeinfo"></a>
### Type `NodeInfo`

The Node information.


#### Fields

* `node_name` - <em>String</em>, The name of the node.
* `addresses` - <em>Vec<MultiAddr></em>, The addresses of the node.
* `node_id` - <em>[Pubkey](#type-pubkey)</em>, The identity public key of the node.
* `timestamp` - <em>u64</em>, The latest timestamp set by the owner for the node announcement.
 When a Node is online this timestamp will be updated to the latest value.
* `chain_hash` - <em>[Hash256](#type-hash256)</em>, The chain hash of the node.
* `auto_accept_min_ckb_funding_amount` - <em>u64</em>, The minimum CKB funding amount for automatically accepting open channel requests.
* `udt_cfg_infos` - <em>[UdtCfgInfos](#type-udtcfginfos)</em>, The UDT configuration infos of the node.
---

<a id="#type-paymentcustomrecords"></a>
### Type `PaymentCustomRecords`

The custom records to be included in the payment.
 The key is hex encoded of `u32`, and the value is hex encoded of `Vec<u8>` with `0x` as prefix.
 For example:
 ```json
 "custom_records": {
    "0x1": "0x01020304",
    "0x2": "0x05060708",
    "0x3": "0x090a0b0c",
    "0x4": "0x0d0e0f10010d090a0b0c"
  }
 ```


#### Fields

* `data` - <em>HashMap<u32::Vec<u8>></em>, The custom records to be included in the payment.
---

<a id="#type-paymentsessionstatus"></a>
### Type `PaymentSessionStatus`

The status of a payment, will update as the payment progresses.


#### Enum with values of

* `Created` - initial status, payment session is created, no HTLC is sent
* `Inflight` - the first hop AddTlc is sent successfully and waiting for the response
* `Success` - related HTLC is successfully settled
* `Failed` - related HTLC is failed
---

<a id="#type-peerinfo"></a>
### Type `PeerInfo`

The information about a peer connected to the node.


#### Fields

* `pubkey` - <em>[Pubkey](#type-pubkey)</em>, The identity public key of the peer.
* `peer_id` - <em>PeerId</em>, The peer ID of the peer
* `addresses` - <em>Vec<MultiAddr></em>, A list of multi-addresses associated with the peer.
---

<a id="#type-pubkey"></a>
### Type `Pubkey`

The public key for a Node



---

<a id="#type-removetlcreason"></a>
### Type `RemoveTlcReason`

The reason for removing a TLC


#### Enum with values of

* `RemoveTlcFulfill` - The reason for removing the TLC is that it was fulfilled
* `RemoveTlcFail` - The reason for removing the TLC is that it failed
---

<a id="#type-sessionroutenode"></a>
### Type `SessionRouteNode`

The node and channel information in a payment route hop


#### Fields

* `pubkey` - <em>[Pubkey](#type-pubkey)</em>, the public key of the node
* `amount` - <em>u128</em>, the amount for this hop
* `channel_outpoint` - <em>OutPoint</em>, the channel outpoint for this hop
---

<a id="#type-udtarginfo"></a>
### Type `UdtArgInfo`

The UDT argument info which is used to identify the UDT configuration


#### Fields

* `name` - <em>String</em>, The name of the UDT.
* `script` - <em>[UdtScript](#type-udtscript)</em>, The script of the UDT.
* `auto_accept_amount` - <em>Option<u128></em>, The minimum amount of the UDT that can be automatically accepted.
* `cell_deps` - <em>Vec<[UdtDep](#type-udtdep)></em>, The cell deps of the UDT.
---

<a id="#type-udtcelldep"></a>
### Type `UdtCellDep`

The UDT cell dep which is used to identify the UDT configuration for a Fiber Node


#### Fields

* `out_point` - <em>OutPointWrapper</em>, The out point of the cell dep.
* `dep_type` - <em>DepType</em>, The type of the cell dep.
---

<a id="#type-udtcfginfos"></a>
### Type `UdtCfgInfos`

A list of UDT configuration infos.



---

<a id="#type-udtdep"></a>
### Type `UdtDep`

Udt script on-chain dependencies.


#### Fields

* `cell_dep` - <em>Option<[UdtCellDep](#type-udtcelldep)></em>, cell dep described by out_point.
* `type_id` - <em>Option<Script></em>, cell dep described by type ID.
---

<a id="#type-udtscript"></a>
### Type `UdtScript`

The UDT script which is used to identify the UDT configuration for a Fiber Node


#### Fields

* `code_hash` - <em>H256</em>, The code hash of the script.
* `hash_type` - <em>ScriptHashType</em>, The hash type of the script.
* `args` - <em>String</em>, The arguments of the script.
---

