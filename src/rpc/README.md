
# Fiber Network Node RPC

The RPC module provides a set of APIs for developers to interact with FNN. Please note that APIs are not stable yet and may change in the future.

Allowing arbitrary machines to access the JSON-RPC port (using the `rpc.listening_addr` configuration option) is **dangerous and strongly discouraged**. Please strictly limit the access to only trusted machines.

You may refer to the e2e test cases in the `tests/bruno/e2e` directory for examples of how to use the RPC.

<!--**NOTE:** the content below is generated by gen_doc -->

* [RPC Methods](#rpc-methods)


    * [Module Cch](#module-cch)
        * [Method `send_btc`](#cch-send_btc)
        * [Method `receive_btc`](#cch-receive_btc)
        * [Method `get_receive_btc_order`](#cch-get_receive_btc_order)
    * [Module Channel](#module-channel)
        * [Method `open_channel`](#channel-open_channel)
        * [Method `accept_channel`](#channel-accept_channel)
        * [Method `list_channels`](#channel-list_channels)
        * [Method `shutdown_channel`](#channel-shutdown_channel)
        * [Method `update_channel`](#channel-update_channel)
    * [Module Dev](#module-dev)
        * [Method `commitment_signed`](#dev-commitment_signed)
        * [Method `add_tlc`](#dev-add_tlc)
        * [Method `remove_tlc`](#dev-remove_tlc)
        * [Method `submit_commitment_transaction`](#dev-submit_commitment_transaction)
    * [Module Graph](#module-graph)
        * [Method `graph_nodes`](#graph-graph_nodes)
        * [Method `graph_channels`](#graph-graph_channels)
    * [Module Info](#module-info)
        * [Method `node_info`](#info-node_info)
    * [Module Invoice](#module-invoice)
        * [Method `new_invoice`](#invoice-new_invoice)
        * [Method `parse_invoice`](#invoice-parse_invoice)
        * [Method `get_invoice`](#invoice-get_invoice)
        * [Method `cancel_invoice`](#invoice-cancel_invoice)
    * [Module Payment](#module-payment)
        * [Method `send_payment`](#payment-send_payment)
        * [Method `get_payment`](#payment-get_payment)
    * [Module Peer](#module-peer)
        * [Method `connect_peer`](#peer-connect_peer)
        * [Method `disconnect_peer`](#peer-disconnect_peer)
* [RPC Types](#rpc-types)

    * [Type `CchOrderStatus`](#type-cchorderstatus)
    * [Type `Channel`](#type-channel)
    * [Type `ChannelInfo`](#type-channelinfo)
    * [Type `CkbInvoice`](#type-ckbinvoice)
    * [Type `CkbInvoiceStatus`](#type-ckbinvoicestatus)
    * [Type `Currency`](#type-currency)
    * [Type `Hash256`](#type-hash256)
    * [Type `HashAlgorithm`](#type-hashalgorithm)
    * [Type `HopHint`](#type-hophint)
    * [Type `NodeInfo`](#type-nodeinfo)
    * [Type `PaymentSessionStatus`](#type-paymentsessionstatus)
    * [Type `Pubkey`](#type-pubkey)
    * [Type `RemoveTlcReason`](#type-removetlcreason)
    * [Type `SessionRoute`](#type-sessionroute)
    * [Type `UdtCfgInfos`](#type-udtcfginfos)

## RPC Modules

<a id="cch"></a>
### Module `Cch`
RPC module for cross chain hub demonstration.


<a id="cch-send_btc"></a>
#### Method `send_btc`

Send BTC to a address.

##### Params

* `btc_pay_req` - <em>`String`</em>, Bitcoin payment request string
* `currency` - <em>[Currency](#type-currency)</em>, Request currency

##### Returns

* `timestamp` - <em>`u64`</em>, Seconds since epoch when the order is created
* `expiry` - <em>`u64`</em>, Seconds after timestamp that the order expires
* `ckb_final_tlc_expiry_delta` - <em>`u64`</em>, The minimal expiry in seconds of the final TLC in the CKB network
* `currency` - <em>[Currency](#type-currency)</em>, Request currency
* `wrapped_btc_type_script` - <em>`ckb_jsonrpc_types::Script`</em>, Wrapped BTC type script
* `btc_pay_req` - <em>`String`</em>, Payment request for BTC
* `ckb_pay_req` - <em>`String`</em>, Payment request for CKB
* `payment_hash` - <em>`String`</em>, Payment hash for the HTLC for both CKB and BTC.
* `amount_sats` - <em>`u128`</em>, Amount required to pay in Satoshis, including fee
* `fee_sats` - <em>`u128`</em>, Fee in Satoshis
* `status` - <em>[CchOrderStatus](#type-cchorderstatus)</em>, Order status

---



<a id="cch-receive_btc"></a>
#### Method `receive_btc`

Receive BTC from a payment hash.

##### Params

* `payment_hash` - <em>`String`</em>, Payment hash for the HTLC for both CKB and BTC.
* `channel_id` - <em>[Hash256](#type-hash256)</em>, Channel ID for the CKB payment.
* `amount_sats` - <em>`u128`</em>, How many satoshis to receive, excluding cross-chain hub fee.
* `final_tlc_expiry` - <em>`u64`</em>, Expiry set for the HTLC for the CKB payment to the payee.

##### Returns

* `timestamp` - <em>`u64`</em>, Seconds since epoch when the order is created
* `expiry` - <em>`u64`</em>, Seconds after timestamp that the order expires
* `ckb_final_tlc_expiry_delta` - <em>`u64`</em>, The minimal expiry in seconds of the final TLC in the CKB network
* `wrapped_btc_type_script` - <em>`ckb_jsonrpc_types::Script`</em>, Wrapped BTC type script
* `btc_pay_req` - <em>`String`</em>, Payment request for BTC
* `payment_hash` - <em>`String`</em>, Payment hash for the HTLC for both CKB and BTC.
* `channel_id` - <em>[Hash256](#type-hash256)</em>, Channel ID for the CKB payment.
* `tlc_id` - <em>`Option<u64>`</em>, TLC ID for the CKB payment.
* `amount_sats` - <em>`u128`</em>, Amount will be received by the payee
* `fee_sats` - <em>`u128`</em>, Fee in Satoshis
* `status` - <em>[CchOrderStatus](#type-cchorderstatus)</em>, Order status

---



<a id="cch-get_receive_btc_order"></a>
#### Method `get_receive_btc_order`

Get receive BTC order by payment hash.

##### Params

* `payment_hash` - <em>`String`</em>, Payment hash for the HTLC for both CKB and BTC.

##### Returns

* `timestamp` - <em>`u64`</em>, Seconds since epoch when the order is created
* `expiry` - <em>`u64`</em>, Seconds after timestamp that the order expires
* `ckb_final_tlc_expiry_delta` - <em>`u64`</em>, The minimal expiry in seconds of the final TLC in the CKB network
* `wrapped_btc_type_script` - <em>`ckb_jsonrpc_types::Script`</em>, Wrapped BTC type script
* `btc_pay_req` - <em>`String`</em>, Payment request for BTC
* `payment_hash` - <em>`String`</em>, Payment hash for the HTLC for both CKB and BTC.
* `channel_id` - <em>[Hash256](#type-hash256)</em>, Channel ID for the CKB payment.
* `tlc_id` - <em>`Option<u64>`</em>, TLC ID for the CKB payment.
* `amount_sats` - <em>`u128`</em>, Amount will be received by the payee
* `fee_sats` - <em>`u128`</em>, Fee in Satoshis
* `status` - <em>[CchOrderStatus](#type-cchorderstatus)</em>, Order status

---



<a id="channel"></a>
### Module `Channel`
RPC module for channel management.


<a id="channel-open_channel"></a>
#### Method `open_channel`

Attempts to open a channel with a peer.

##### Params

* `peer_id` - <em>`PeerId`</em>, The peer ID to open a channel with, the peer must be connected through the [connect_peer](#peer-connect_peer) rpc first.
* `funding_amount` - <em>`u128`</em>, The amount of CKB or UDT to fund the channel with.
* `public` - <em>`Option<bool>`</em>, Whether this is a public channel (will be broadcasted to network, and can be used to forward TLCs), an optional parameter, default value is true.
* `funding_udt_type_script` - <em>`Option<Script>`</em>, The type script of the UDT to fund the channel with, an optional parameter.
* `shutdown_script` - <em>`Option<Script>`</em>, The script used to receive the channel balance, an optional parameter, default value is the secp256k1_blake160_sighash_all script corresponding to the configured private key.
* `commitment_delay_epoch` - <em>`Option<EpochNumberWithFraction>`</em>, The delay time for the commitment transaction, must be an [EpochNumberWithFraction](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0017-tx-valid-since/e-i-l-encoding.png) in u64 format, an optional parameter, default value is 24 hours.
* `commitment_fee_rate` - <em>`Option<u64>`</em>, The fee rate for the commitment transaction, an optional parameter.
* `funding_fee_rate` - <em>`Option<u64>`</em>, The fee rate for the funding transaction, an optional parameter.
* `tlc_expiry_delta` - <em>`Option<u64>`</em>, The expiry delta to forward a tlc, in milliseconds, default to 1 day, which is 24 * 60 * 60 * 1000 milliseconds
 This parameter can be updated with rpc `update_channel` later.
* `tlc_min_value` - <em>`Option<u128>`</em>, The minimum value for a TLC our side can send,
 an optional parameter, default is 0, which means we can send any TLC is larger than 0.
 This parameter can be updated with rpc `update_channel` later.
* `tlc_fee_proportional_millionths` - <em>`Option<u128>`</em>, The fee proportional millionths for a TLC, proportional to the amount of the forwarded tlc.
 The unit is millionths of the amount. default is 1000 which means 0.1%.
 This parameter can be updated with rpc `update_channel` later.
 Not that, we use outbound channel to calculate the fee for TLC forwarding. For example,
 if we have a path A -> B -> C, then the fee B requires for TLC forwarding, is calculated
 the channel configuration of B and C, not A and B.
* `max_tlc_value_in_flight` - <em>`Option<u128>`</em>, The maximum value in flight for TLCs, an optional parameter.
 This parameter can not be updated after channel is opened.
* `max_tlc_number_in_flight` - <em>`Option<u64>`</em>, The maximum number of TLCs that can be accepted, an optional parameter, default is 125
 This parameter can not be updated after channel is opened.

##### Returns

* `temporary_channel_id` - <em>[Hash256](#type-hash256)</em>, The temporary channel ID of the channel being opened

---



<a id="channel-accept_channel"></a>
#### Method `accept_channel`

Accepts a channel opening request from a peer.

##### Params

* `temporary_channel_id` - <em>[Hash256](#type-hash256)</em>, The temporary channel ID of the channel to accept
* `funding_amount` - <em>`u128`</em>, The amount of CKB or UDT to fund the channel with
* `shutdown_script` - <em>`Option<Script>`</em>, The script used to receive the channel balance, an optional parameter,
 default value is the secp256k1_blake160_sighash_all script corresponding to the configured private key
* `max_tlc_value_in_flight` - <em>`Option<u128>`</em>, The max tlc sum value in flight for the channel, default is u128::MAX
 This parameter can not be updated after channel is opened.
* `max_tlc_number_in_flight` - <em>`Option<u64>`</em>, The max tlc number in flight send from our side, default is 125
 This parameter can not be updated after channel is opened.
* `tlc_min_value` - <em>`Option<u128>`</em>, The minimum value for a TLC our side can send,
 an optional parameter, default is 0, which means we can send any TLC is larger than 0.
 This parameter can be updated with rpc `update_channel` later.
* `tlc_fee_proportional_millionths` - <em>`Option<u128>`</em>, The fee proportional millionths for a TLC, proportional to the amount of the forwarded tlc.
 The unit is millionths of the amount. default is 1000 which means 0.1%.
 This parameter can be updated with rpc `update_channel` later.
 Not that, we use outbound channel to calculate the fee for TLC forwarding. For example,
 if we have a path A -> B -> C, then the fee B requires for TLC forwarding, is calculated
 the channel configuration of B and C, not A and B.
* `tlc_expiry_delta` - <em>`Option<u64>`</em>, The expiry delta to forward a tlc, in milliseconds, default to 1 day, which is 24 * 60 * 60 * 1000 milliseconds
 This parameter can be updated with rpc `update_channel` later.

##### Returns

* `channel_id` - <em>[Hash256](#type-hash256)</em>, The final ID of the channel that was accepted, it's different from the temporary channel ID

---



<a id="channel-list_channels"></a>
#### Method `list_channels`

Lists all channels.

##### Params

* `peer_id` - <em>`Option<PeerId>`</em>, The peer ID to list channels for, an optional parameter, if not provided, all channels will be listed
* `include_closed` - <em>`Option<bool>`</em>, Whether to include closed channels in the list, an optional parameter, default value is false

##### Returns

* `channels` - <em>Vec<[Channel](#type-channel)></em>, The list of channels

---



<a id="channel-shutdown_channel"></a>
#### Method `shutdown_channel`

Shuts down a channel.

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, The channel ID of the channel to shut down
* `close_script` - <em>`Script`</em>, The script used to receive the channel balance, only support secp256k1_blake160_sighash_all script for now
* `force` - <em>`Option<bool>`</em>, Whether to force the channel to close
* `fee_rate` - <em>`u64`</em>, The fee rate for the closing transaction, the fee will be deducted from the closing initiator's channel balance

##### Returns

* None

---



<a id="channel-update_channel"></a>
#### Method `update_channel`

Updates a channel.

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, The channel ID of the channel to update
* `enabled` - <em>`Option<bool>`</em>, Whether the channel is enabled
* `tlc_expiry_delta` - <em>`Option<u64>`</em>, The CLTV delta from the current height that should be used to set the timelock for the final hop

 The expiry delta for the TLC locktime
* `tlc_minimum_value` - <em>`Option<u128>`</em>, The minimum value for a TLC
* `tlc_fee_proportional_millionths` - <em>`Option<u128>`</em>, The fee proportional millionths for a TLC

##### Returns

* None

---



<a id="dev"></a>
### Module `Dev`
RPC module for development purposes, this module is not intended to be used in production.
 This module will be disabled in release build.


<a id="dev-commitment_signed"></a>
#### Method `commitment_signed`

Sends a commitment_signed message to the peer.

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, The channel ID of the channel to send the commitment_signed message to

##### Returns

* None

---



<a id="dev-add_tlc"></a>
#### Method `add_tlc`

Adds a TLC to a channel.

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, The channel ID of the channel to add the TLC to
* `amount` - <em>`u128`</em>, The amount of the TLC
* `payment_hash` - <em>[Hash256](#type-hash256)</em>, The payment hash of the TLC
* `expiry` - <em>`u64`</em>, The expiry of the TLC
* `hash_algorithm` - <em>Option<[HashAlgorithm](#type-hashalgorithm)></em>, The hash algorithm of the TLC

##### Returns

* `tlc_id` - <em>`u64`</em>, The ID of the TLC

---



<a id="dev-remove_tlc"></a>
#### Method `remove_tlc`

Removes a TLC from a channel.

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, The channel ID of the channel to remove the TLC from
* `tlc_id` - <em>`u64`</em>, The ID of the TLC to remove
* `reason` - <em>[RemoveTlcReason](#type-removetlcreason)</em>, The reason for removing the TLC, either a 32-byte hash for preimage fulfillment or an u32 error code for removal

##### Returns

* None

---



<a id="dev-submit_commitment_transaction"></a>
#### Method `submit_commitment_transaction`

Submit a commitment transaction to the chain

##### Params

* `channel_id` - <em>[Hash256](#type-hash256)</em>, Channel ID
* `commitment_number` - <em>`u64`</em>, Commitment number

##### Returns

* `tx_hash` - <em>[Hash256](#type-hash256)</em>, Submitted commitment transaction hash

---



<a id="graph"></a>
### Module `Graph`
RPC module for graph management.


<a id="graph-graph_nodes"></a>
#### Method `graph_nodes`

Get the list of nodes in the network graph.

##### Params

* `limit` - <em>`Option<u64>`</em>, The maximum number of nodes to return.
* `after` - <em>`Option<JsonBytes>`</em>, The cursor to start returning nodes from.

##### Returns

* `nodes` - <em>Vec<[NodeInfo](#type-nodeinfo)></em>, The list of nodes.
* `last_cursor` - <em>`JsonBytes`</em>, The last cursor.

---



<a id="graph-graph_channels"></a>
#### Method `graph_channels`

Get the list of channels in the network graph.

##### Params

* `limit` - <em>`Option<u64>`</em>, The maximum number of channels to return.
* `after` - <em>`Option<JsonBytes>`</em>, The cursor to start returning channels from.

##### Returns

* `channels` - <em>Vec<[ChannelInfo](#type-channelinfo)></em>, A list of channels.
* `last_cursor` - <em>`JsonBytes`</em>, The last cursor for pagination.

---



<a id="info"></a>
### Module `Info`
The RPC module for node information.


<a id="info-node_info"></a>
#### Method `node_info`

Get the node information.

##### Params
* None

##### Returns

* `version` - <em>`String`</em>, The version of the node software.
* `commit_hash` - <em>`String`</em>, The commit hash of the node software.
* `node_id` - <em>[Pubkey](#type-pubkey)</em>, The identity public key of the node.
* `node_name` - <em>`Option<String>`</em>, The optional name of the node.
* `addresses` - <em>`Vec<MultiAddr>`</em>, A list of multi-addresses associated with the node.
* `chain_hash` - <em>[Hash256](#type-hash256)</em>, The hash of the blockchain that the node is connected to.
* `open_channel_auto_accept_min_ckb_funding_amount` - <em>`u64`</em>, The minimum CKB funding amount for automatically accepting open channel requests, serialized as a hexadecimal string.
* `auto_accept_channel_ckb_funding_amount` - <em>`u64`</em>, The CKB funding amount for automatically accepting channel requests, serialized as a hexadecimal string.
* `default_funding_lock_script` - <em>`Script`</em>, The default funding lock script for the node.
* `tlc_expiry_delta` - <em>`u64`</em>, The locktime expiry delta for Time-Locked Contracts (TLC), serialized as a hexadecimal string.
* `tlc_min_value` - <em>`u128`</em>, The minimum value for Time-Locked Contracts (TLC) we can send, serialized as a hexadecimal string.
* `tlc_max_value` - <em>`u128`</em>, The maximum value for Time-Locked Contracts (TLC) we can send, serialized as a hexadecimal string, `0` means no maximum value limit.
* `tlc_fee_proportional_millionths` - <em>`u128`</em>, The fee (to forward payments) proportional to the value of Time-Locked Contracts (TLC), expressed in millionths and serialized as a hexadecimal string.
* `channel_count` - <em>`u32`</em>, The number of channels associated with the node, serialized as a hexadecimal string.
* `pending_channel_count` - <em>`u32`</em>, The number of pending channels associated with the node, serialized as a hexadecimal string.
* `peers_count` - <em>`u32`</em>, The number of peers connected to the node, serialized as a hexadecimal string.
* `udt_cfg_infos` - <em>[UdtCfgInfos](#type-udtcfginfos)</em>, Configuration information for User-Defined Tokens (UDT) associated with the node.

---



<a id="invoice"></a>
### Module `Invoice`
RPC module for invoice management.


<a id="invoice-new_invoice"></a>
#### Method `new_invoice`

Generates a new invoice.

##### Params

* `amount` - <em>`u128`</em>, The amount of the invoice.
* `description` - <em>`Option<String>`</em>, The description of the invoice.
* `currency` - <em>[Currency](#type-currency)</em>, The currency of the invoice.
* `payment_preimage` - <em>[Hash256](#type-hash256)</em>, The payment preimage of the invoice.
* `expiry` - <em>`Option<u64>`</em>, The expiry time of the invoice.
* `fallback_address` - <em>`Option<String>`</em>, The fallback address of the invoice.
* `final_expiry_delta` - <em>`Option<u64>`</em>, The final HTLC timeout of the invoice.
* `udt_type_script` - <em>`Option<Script>`</em>, The UDT type script of the invoice.
* `hash_algorithm` - <em>Option<[HashAlgorithm](#type-hashalgorithm)></em>, The hash algorithm of the invoice.

##### Returns

* `invoice_address` - <em>`String`</em>, The encoded invoice address.
* `invoice` - <em>[CkbInvoice](#type-ckbinvoice)</em>, The invoice.

---



<a id="invoice-parse_invoice"></a>
#### Method `parse_invoice`

Parses a encoded invoice.

##### Params

* `invoice` - <em>`String`</em>, The encoded invoice address.

##### Returns

* `invoice` - <em>[CkbInvoice](#type-ckbinvoice)</em>, The invoice.

---



<a id="invoice-get_invoice"></a>
#### Method `get_invoice`

Retrieves an invoice.

##### Params

* `payment_hash` - <em>[Hash256](#type-hash256)</em>, The payment hash of the invoice.

##### Returns

* `invoice_address` - <em>`String`</em>, The encoded invoice address.
* `invoice` - <em>[CkbInvoice](#type-ckbinvoice)</em>, The invoice.
* `status` - <em>[CkbInvoiceStatus](#type-ckbinvoicestatus)</em>, The invoice status

---



<a id="invoice-cancel_invoice"></a>
#### Method `cancel_invoice`

Cancels an invoice, only when invoice is in status `Open` can be canceled.

##### Params

* `payment_hash` - <em>[Hash256](#type-hash256)</em>, The payment hash of the invoice.

##### Returns

* `invoice_address` - <em>`String`</em>, The encoded invoice address.
* `invoice` - <em>[CkbInvoice](#type-ckbinvoice)</em>, The invoice.
* `status` - <em>[CkbInvoiceStatus](#type-ckbinvoicestatus)</em>, The invoice status

---



<a id="payment"></a>
### Module `Payment`
RPC module for channel management.


<a id="payment-send_payment"></a>
#### Method `send_payment`

Sends a payment to a peer.

##### Params

* `target_pubkey` - <em>Option<[Pubkey](#type-pubkey)></em>, the identifier of the payment target
* `amount` - <em>`Option<u128>`</em>, the amount of the payment
* `payment_hash` - <em>Option<[Hash256](#type-hash256)></em>, the hash to use within the payment's HTLC
* `final_tlc_expiry_delta` - <em>`Option<u64>`</em>, the TLC expiry delta should be used to set the timelock for the final hop, in milliseconds
* `tlc_expiry_limit` - <em>`Option<u64>`</em>, the TLC expiry limit for the whole payment, in milliseconds, each hop is with a default tlc delta of 1 day
 suppose the payment router is with N hops, the total tlc expiry limit is at least (N-1) days
 this is also the default value for the payment if this parameter is not provided
* `invoice` - <em>`Option<String>`</em>, the encoded invoice to send to the recipient
* `timeout` - <em>`Option<u64>`</em>, the payment timeout in seconds, if the payment is not completed within this time, it will be cancelled
* `max_fee_amount` - <em>`Option<u128>`</em>, the maximum fee amounts in shannons that the sender is willing to pay
* `max_parts` - <em>`Option<u64>`</em>, max parts for the payment, only used for multi-part payments
* `keysend` - <em>`Option<bool>`</em>, keysend payment
* `udt_type_script` - <em>`Option<Script>`</em>, udt type script for the payment
* `allow_self_payment` - <em>`Option<bool>`</em>, allow self payment, default is false
* `hop_hints` - <em>Option<Vec<[HopHint](#type-hophint)>></em>, Optional route hints to reach the destination through private channels.
 A hop hint is a hint for a node to use a specific channel, for example
 (pubkey, funding_txid, inbound) where pubkey is the public key of the node,
 funding_txid is the funding transaction hash of the channel outpoint, and
 inbound is a boolean indicating whether to use the channel to send or receive.
 Note: an inproper hint may cause the payment to fail, and hop_hints maybe helpful for self payment scenario
 for helping the routing algorithm to find the correct path
* `dry_run` - <em>`Option<bool>`</em>, dry_run for payment, used for check whether we can build valid router and the fee for this payment,
 it's useful for the sender to double check the payment before sending it to the network,
 default is false

##### Returns

* `payment_hash` - <em>[Hash256](#type-hash256)</em>, The payment hash of the payment
* `status` - <em>[PaymentSessionStatus](#type-paymentsessionstatus)</em>, The status of the payment
* `created_at` - <em>`u64`</em>, The time the payment was created at, in milliseconds from UNIX epoch
* `last_updated_at` - <em>`u64`</em>, The time the payment was last updated at, in milliseconds from UNIX epoch
* `failed_error` - <em>`Option<String>`</em>, The error message if the payment failed
* `fee` - <em>`u128`</em>, fee paid for the payment
* `router` - <em>[SessionRoute](#type-sessionroute)</em>, The route information for the payment

---



<a id="payment-get_payment"></a>
#### Method `get_payment`

Retrieves a payment.

##### Params

* `payment_hash` - <em>[Hash256](#type-hash256)</em>, The payment hash of the payment to retrieve

##### Returns

* `payment_hash` - <em>[Hash256](#type-hash256)</em>, The payment hash of the payment
* `status` - <em>[PaymentSessionStatus](#type-paymentsessionstatus)</em>, The status of the payment
* `created_at` - <em>`u64`</em>, The time the payment was created at, in milliseconds from UNIX epoch
* `last_updated_at` - <em>`u64`</em>, The time the payment was last updated at, in milliseconds from UNIX epoch
* `failed_error` - <em>`Option<String>`</em>, The error message if the payment failed
* `fee` - <em>`u128`</em>, fee paid for the payment
* `router` - <em>[SessionRoute](#type-sessionroute)</em>, The route information for the payment

---



<a id="peer"></a>
### Module `Peer`
RPC module for peer management.


<a id="peer-connect_peer"></a>
#### Method `connect_peer`

Connect to a peer.

##### Params

* `address` - <em>`MultiAddr`</em>, The address of the peer to connect to.
* `save` - <em>`Option<bool>`</em>, Whether to save the peer address to the peer store.

##### Returns

* None

---



<a id="peer-disconnect_peer"></a>
#### Method `disconnect_peer`

Disconnect from a peer.

##### Params

* `peer_id` - <em>`PeerId`</em>, The peer ID of the peer to disconnect.

##### Returns

* None

---




## RPC Types


<a id="#type-cchorderstatus"></a>
### Type `CchOrderStatus`

The status of a cross-chain hub order, will update as the order progresses.


#### Enum with values of

* `Pending` - Order is created and has not send out payments yet.
* `Accepted` - HTLC in the first half is accepted.
* `InFlight` - There's an outgoing payment in flight for the second half.
* `Succeeded` - Order is settled.
* `Failed` - Order is failed.
---

<a id="#type-channel"></a>
### Type `Channel`

The channel data structure


#### Fields

* `channel_id` - <em>Hash256</em>, The channel ID
* `is_public` - <em>bool</em>, Whether the channel is public
* `channel_outpoint` - <em>`Option<OutPoint>`</em>, The outpoint of the channel
* `peer_id` - <em>PeerId</em>, The peer ID of the channel
* `funding_udt_type_script` - <em>`Option<Script>`</em>, The UDT type script of the channel
* `state` - <em>ChannelState</em>, The state of the channel
* `local_balance` - <em>u128</em>, The local balance of the channel
* `offered_tlc_balance` - <em>u128</em>, The offered balance of the channel
* `remote_balance` - <em>u128</em>, The remote balance of the channel
* `received_tlc_balance` - <em>u128</em>, The received balance of the channel
* `latest_commitment_transaction_hash` - <em>`Option<H256>`</em>, The hash of the latest commitment transaction
* `created_at` - <em>u64</em>, The time the channel was created at, in milliseconds from UNIX epoch
---

<a id="#type-channelinfo"></a>
### Type `ChannelInfo`

The Channel information.


#### Fields

* `channel_outpoint` - <em>OutPoint</em>, The outpoint of the channel.
* `node1` - <em>Pubkey</em>, The identity public key of the first node.
* `node2` - <em>Pubkey</em>, The identity public key of the second node.
* `created_timestamp` - <em>u64</em>, The created timestamp of the channel, which is the block header timestamp of the block
 that contains the channel funding transaction.
* `last_updated_timestamp_of_node1` - <em>`Option<u64>`</em>, The timestamp of the last update to channel by node 1 (e.g. updating fee rate).
* `last_updated_timestamp_of_node2` - <em>`Option<u64>`</em>, The timestamp of the last update to channel by node 2 (e.g. updating fee rate).
* `fee_rate_of_node1` - <em>`Option<u64>`</em>, The fee rate set by node 1. This is the fee rate for node 1 to forward tlcs sent from node 2 to node 1.
* `fee_rate_of_node2` - <em>`Option<u64>`</em>, The fee rate set by node 2. This is the fee rate for node 2 to forward tlcs sent from node 1 to node 2.
* `capacity` - <em>u128</em>, The capacity of the channel.
* `chain_hash` - <em>Hash256</em>, The chain hash of the channel.
* `udt_type_script` - <em>`Option<Script>`</em>, The UDT type script of the channel.
---

<a id="#type-ckbinvoice"></a>
### Type `CkbInvoice`

Represents a syntactically and semantically correct lightning BOLT11 invoice

 There are three ways to construct a `CkbInvoice`:
  1. using [`CkbInvoiceBuilder`]
  2. using `str::parse::<CkbInvoice>(&str)` (see [`CkbInvoice::from_str`])


#### Fields

* `currency` - <em>Currency</em>, The currency of the invoice
* `amount` - <em>`Option<u128>`</em>, The amount of the invoice
* `signature` - <em>`Option<InvoiceSignature>`</em>, The signature of the invoice
* `data` - <em>InvoiceData</em>, The invoice data, including the payment hash, timestamp and other attributes
---

<a id="#type-ckbinvoicestatus"></a>
### Type `CkbInvoiceStatus`

The currency of the invoice, can also used to represent the CKB network chain.


#### Enum with values of

* `Open` - The invoice is open and can be paid.
* `Cancelled` - The invoice is cancelled.
* `Expired` - The invoice is expired.
* `Received` - The invoice is received, but not settled yet.
* `Paid` - The invoice is paid.
---

<a id="#type-currency"></a>
### Type `Currency`

The currency of the invoice, can also used to represent the CKB network chain.


#### Enum with values of

* `Fibb` - The mainnet currency of CKB.
* `Fibt` - The testnet currency of the CKB network.
* `Fibd` - The devnet currency of the CKB network.
---

<a id="#type-hash256"></a>
### Type `Hash256`

A 256-bit hash digest, used as identifier of channnel, payment, transaction hash etc.



---

<a id="#type-hashalgorithm"></a>
### Type `HashAlgorithm`

HashAlgorithm is the hash algorithm used in the hash lock.


#### Enum with values of

* `CkbHash` - The default hash algorithm, CkbHash
* `Sha256` - The sha256 hash algorithm
---

<a id="#type-hophint"></a>
### Type `HopHint`

A hop hint is a hint for a node to use a specific channel.


#### Fields

* `pubkey` - <em>Pubkey</em>, The public key of the node
* `channel_funding_tx` - <em>Hash256</em>, The funding transaction hash of the channel outpoint
* `inbound` - <em>bool</em>, inbound or outbound to use this channel
---

<a id="#type-nodeinfo"></a>
### Type `NodeInfo`

The Node information.


#### Fields

* `node_name` - <em>String</em>, The name of the node.
* `addresses` - <em>`Vec<MultiAddr>`</em>, The addresses of the node.
* `node_id` - <em>Pubkey</em>, The identity public key of the node.
* `timestamp` - <em>u64</em>, The timestamp of the node.
* `chain_hash` - <em>Hash256</em>, The chain hash of the node.
* `auto_accept_min_ckb_funding_amount` - <em>u64</em>, The minimum CKB funding amount for automatically accepting open channel requests.
* `udt_cfg_infos` - <em>UdtCfgInfos</em>, The UDT configuration infos of the node.
---

<a id="#type-paymentsessionstatus"></a>
### Type `PaymentSessionStatus`

The status of a payment, will update as the payment progresses.


#### Enum with values of

* `Created` - initial status, payment session is created, no HTLC is sent
* `Inflight` - the first hop AddTlc is sent successfully and waiting for the response
* `Success` - related HTLC is successfully settled
* `Failed` - related HTLC is failed
---

<a id="#type-pubkey"></a>
### Type `Pubkey`

The public key for a Node



---

<a id="#type-removetlcreason"></a>
### Type `RemoveTlcReason`

The reason for removing a TLC


#### Enum with values of

* `RemoveTlcFulfill` - The reason for removing the TLC is that it was fulfilled
* `RemoveTlcFail` - The reason for removing the TLC is that it failed
---

<a id="#type-sessionroute"></a>
### Type `SessionRoute`

The router is a list of nodes that the payment will go through.
 We store in the payment session and then will use it to track the payment history.
 The router is a list of nodes that the payment will go through.
 For example:
    A(amount, channel) -> B -> C -> D means A will send `amount` with `channel` to B.


#### Fields

* `nodes` - <em>`Vec<SessionRouteNode>`</em>, the nodes in the route
---

<a id="#type-udtcfginfos"></a>
### Type `UdtCfgInfos`

The UDT configurations



---

