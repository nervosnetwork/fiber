// Generated by Molecule 0.8.0

use super::blockchain::*;
use molecule::prelude::*;
#[derive(Clone)]
pub struct Uint16(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Uint16 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Uint16 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Uint16 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Uint16 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Uint16::new_unchecked(v)
    }
}
impl Uint16 {
    const DEFAULT_VALUE: [u8; 2] = [0, 0];
    pub const TOTAL_SIZE: usize = 2;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 2;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> Uint16Reader<'r> {
        Uint16Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Uint16 {
    type Builder = Uint16Builder;
    const NAME: &'static str = "Uint16";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Uint16(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint16Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint16Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0(), self.nth1()])
    }
}
#[derive(Clone, Copy)]
pub struct Uint16Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Uint16Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Uint16Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Uint16Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> Uint16Reader<'r> {
    pub const TOTAL_SIZE: usize = 2;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 2;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for Uint16Reader<'r> {
    type Entity = Uint16;
    const NAME: &'static str = "Uint16Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Uint16Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Uint16Builder(pub(crate) [Byte; 2]);
impl ::core::fmt::Debug for Uint16Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Uint16Builder {
    fn default() -> Self {
        Uint16Builder([Byte::default(), Byte::default()])
    }
}
impl Uint16Builder {
    pub const TOTAL_SIZE: usize = 2;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 2;
    pub fn set(mut self, v: [Byte; 2]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
}
impl molecule::prelude::Builder for Uint16Builder {
    type Entity = Uint16;
    const NAME: &'static str = "Uint16Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Uint16::new_unchecked(inner.into())
    }
}
impl From<[Byte; 2usize]> for Uint16 {
    fn from(value: [Byte; 2usize]) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl ::core::convert::TryFrom<&[Byte]> for Uint16 {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[Byte]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(Self::new_builder()
            .set(<&[Byte; 2usize]>::try_from(value)?.clone())
            .build())
    }
}
impl From<Uint16> for [Byte; 2usize] {
    #[track_caller]
    fn from(value: Uint16) -> Self {
        [value.nth0(), value.nth1()]
    }
}
impl From<[u8; 2usize]> for Uint16 {
    fn from(value: [u8; 2usize]) -> Self {
        Uint16Reader::new_unchecked(&value).to_entity()
    }
}
impl ::core::convert::TryFrom<&[u8]> for Uint16 {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[u8]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(<[u8; 2usize]>::try_from(value)?.into())
    }
}
impl From<Uint16> for [u8; 2usize] {
    #[track_caller]
    fn from(value: Uint16) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<Uint16Reader<'a>> for &'a [u8; 2usize] {
    #[track_caller]
    fn from(value: Uint16Reader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<&'a Uint16Reader<'a>> for &'a [u8; 2usize] {
    #[track_caller]
    fn from(value: &'a Uint16Reader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
#[derive(Clone)]
pub struct EcdsaSignature(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for EcdsaSignature {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for EcdsaSignature {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for EcdsaSignature {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for EcdsaSignature {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        EcdsaSignature::new_unchecked(v)
    }
}
impl EcdsaSignature {
    const DEFAULT_VALUE: [u8; 64] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0,
    ];
    pub const TOTAL_SIZE: usize = 64;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 64;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn nth9(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(9..10))
    }
    pub fn nth10(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(10..11))
    }
    pub fn nth11(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(11..12))
    }
    pub fn nth12(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(12..13))
    }
    pub fn nth13(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(13..14))
    }
    pub fn nth14(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(14..15))
    }
    pub fn nth15(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(15..16))
    }
    pub fn nth16(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(16..17))
    }
    pub fn nth17(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(17..18))
    }
    pub fn nth18(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(18..19))
    }
    pub fn nth19(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(19..20))
    }
    pub fn nth20(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(20..21))
    }
    pub fn nth21(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(21..22))
    }
    pub fn nth22(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(22..23))
    }
    pub fn nth23(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(23..24))
    }
    pub fn nth24(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(24..25))
    }
    pub fn nth25(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(25..26))
    }
    pub fn nth26(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(26..27))
    }
    pub fn nth27(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(27..28))
    }
    pub fn nth28(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(28..29))
    }
    pub fn nth29(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(29..30))
    }
    pub fn nth30(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(30..31))
    }
    pub fn nth31(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(31..32))
    }
    pub fn nth32(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(32..33))
    }
    pub fn nth33(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(33..34))
    }
    pub fn nth34(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(34..35))
    }
    pub fn nth35(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(35..36))
    }
    pub fn nth36(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(36..37))
    }
    pub fn nth37(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(37..38))
    }
    pub fn nth38(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(38..39))
    }
    pub fn nth39(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(39..40))
    }
    pub fn nth40(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(40..41))
    }
    pub fn nth41(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(41..42))
    }
    pub fn nth42(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(42..43))
    }
    pub fn nth43(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(43..44))
    }
    pub fn nth44(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(44..45))
    }
    pub fn nth45(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(45..46))
    }
    pub fn nth46(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(46..47))
    }
    pub fn nth47(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(47..48))
    }
    pub fn nth48(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(48..49))
    }
    pub fn nth49(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(49..50))
    }
    pub fn nth50(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(50..51))
    }
    pub fn nth51(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(51..52))
    }
    pub fn nth52(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(52..53))
    }
    pub fn nth53(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(53..54))
    }
    pub fn nth54(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(54..55))
    }
    pub fn nth55(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(55..56))
    }
    pub fn nth56(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(56..57))
    }
    pub fn nth57(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(57..58))
    }
    pub fn nth58(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(58..59))
    }
    pub fn nth59(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(59..60))
    }
    pub fn nth60(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(60..61))
    }
    pub fn nth61(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(61..62))
    }
    pub fn nth62(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(62..63))
    }
    pub fn nth63(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(63..64))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> EcdsaSignatureReader<'r> {
        EcdsaSignatureReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for EcdsaSignature {
    type Builder = EcdsaSignatureBuilder;
    const NAME: &'static str = "EcdsaSignature";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        EcdsaSignature(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        EcdsaSignatureReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        EcdsaSignatureReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
            self.nth10(),
            self.nth11(),
            self.nth12(),
            self.nth13(),
            self.nth14(),
            self.nth15(),
            self.nth16(),
            self.nth17(),
            self.nth18(),
            self.nth19(),
            self.nth20(),
            self.nth21(),
            self.nth22(),
            self.nth23(),
            self.nth24(),
            self.nth25(),
            self.nth26(),
            self.nth27(),
            self.nth28(),
            self.nth29(),
            self.nth30(),
            self.nth31(),
            self.nth32(),
            self.nth33(),
            self.nth34(),
            self.nth35(),
            self.nth36(),
            self.nth37(),
            self.nth38(),
            self.nth39(),
            self.nth40(),
            self.nth41(),
            self.nth42(),
            self.nth43(),
            self.nth44(),
            self.nth45(),
            self.nth46(),
            self.nth47(),
            self.nth48(),
            self.nth49(),
            self.nth50(),
            self.nth51(),
            self.nth52(),
            self.nth53(),
            self.nth54(),
            self.nth55(),
            self.nth56(),
            self.nth57(),
            self.nth58(),
            self.nth59(),
            self.nth60(),
            self.nth61(),
            self.nth62(),
            self.nth63(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct EcdsaSignatureReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for EcdsaSignatureReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for EcdsaSignatureReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for EcdsaSignatureReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> EcdsaSignatureReader<'r> {
    pub const TOTAL_SIZE: usize = 64;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 64;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn nth9(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[9..10])
    }
    pub fn nth10(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[10..11])
    }
    pub fn nth11(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[11..12])
    }
    pub fn nth12(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[12..13])
    }
    pub fn nth13(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[13..14])
    }
    pub fn nth14(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[14..15])
    }
    pub fn nth15(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[15..16])
    }
    pub fn nth16(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[16..17])
    }
    pub fn nth17(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[17..18])
    }
    pub fn nth18(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[18..19])
    }
    pub fn nth19(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[19..20])
    }
    pub fn nth20(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[20..21])
    }
    pub fn nth21(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[21..22])
    }
    pub fn nth22(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[22..23])
    }
    pub fn nth23(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[23..24])
    }
    pub fn nth24(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[24..25])
    }
    pub fn nth25(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[25..26])
    }
    pub fn nth26(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[26..27])
    }
    pub fn nth27(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[27..28])
    }
    pub fn nth28(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[28..29])
    }
    pub fn nth29(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[29..30])
    }
    pub fn nth30(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[30..31])
    }
    pub fn nth31(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[31..32])
    }
    pub fn nth32(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[32..33])
    }
    pub fn nth33(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[33..34])
    }
    pub fn nth34(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[34..35])
    }
    pub fn nth35(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[35..36])
    }
    pub fn nth36(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[36..37])
    }
    pub fn nth37(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[37..38])
    }
    pub fn nth38(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[38..39])
    }
    pub fn nth39(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[39..40])
    }
    pub fn nth40(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[40..41])
    }
    pub fn nth41(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[41..42])
    }
    pub fn nth42(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[42..43])
    }
    pub fn nth43(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[43..44])
    }
    pub fn nth44(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[44..45])
    }
    pub fn nth45(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[45..46])
    }
    pub fn nth46(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[46..47])
    }
    pub fn nth47(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[47..48])
    }
    pub fn nth48(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[48..49])
    }
    pub fn nth49(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[49..50])
    }
    pub fn nth50(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[50..51])
    }
    pub fn nth51(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[51..52])
    }
    pub fn nth52(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[52..53])
    }
    pub fn nth53(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[53..54])
    }
    pub fn nth54(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[54..55])
    }
    pub fn nth55(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[55..56])
    }
    pub fn nth56(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[56..57])
    }
    pub fn nth57(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[57..58])
    }
    pub fn nth58(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[58..59])
    }
    pub fn nth59(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[59..60])
    }
    pub fn nth60(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[60..61])
    }
    pub fn nth61(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[61..62])
    }
    pub fn nth62(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[62..63])
    }
    pub fn nth63(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[63..64])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for EcdsaSignatureReader<'r> {
    type Entity = EcdsaSignature;
    const NAME: &'static str = "EcdsaSignatureReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        EcdsaSignatureReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct EcdsaSignatureBuilder(pub(crate) [Byte; 64]);
impl ::core::fmt::Debug for EcdsaSignatureBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for EcdsaSignatureBuilder {
    fn default() -> Self {
        EcdsaSignatureBuilder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl EcdsaSignatureBuilder {
    pub const TOTAL_SIZE: usize = 64;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 64;
    pub fn set(mut self, v: [Byte; 64]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Byte) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: Byte) -> Self {
        self.0[7] = v;
        self
    }
    pub fn nth8(mut self, v: Byte) -> Self {
        self.0[8] = v;
        self
    }
    pub fn nth9(mut self, v: Byte) -> Self {
        self.0[9] = v;
        self
    }
    pub fn nth10(mut self, v: Byte) -> Self {
        self.0[10] = v;
        self
    }
    pub fn nth11(mut self, v: Byte) -> Self {
        self.0[11] = v;
        self
    }
    pub fn nth12(mut self, v: Byte) -> Self {
        self.0[12] = v;
        self
    }
    pub fn nth13(mut self, v: Byte) -> Self {
        self.0[13] = v;
        self
    }
    pub fn nth14(mut self, v: Byte) -> Self {
        self.0[14] = v;
        self
    }
    pub fn nth15(mut self, v: Byte) -> Self {
        self.0[15] = v;
        self
    }
    pub fn nth16(mut self, v: Byte) -> Self {
        self.0[16] = v;
        self
    }
    pub fn nth17(mut self, v: Byte) -> Self {
        self.0[17] = v;
        self
    }
    pub fn nth18(mut self, v: Byte) -> Self {
        self.0[18] = v;
        self
    }
    pub fn nth19(mut self, v: Byte) -> Self {
        self.0[19] = v;
        self
    }
    pub fn nth20(mut self, v: Byte) -> Self {
        self.0[20] = v;
        self
    }
    pub fn nth21(mut self, v: Byte) -> Self {
        self.0[21] = v;
        self
    }
    pub fn nth22(mut self, v: Byte) -> Self {
        self.0[22] = v;
        self
    }
    pub fn nth23(mut self, v: Byte) -> Self {
        self.0[23] = v;
        self
    }
    pub fn nth24(mut self, v: Byte) -> Self {
        self.0[24] = v;
        self
    }
    pub fn nth25(mut self, v: Byte) -> Self {
        self.0[25] = v;
        self
    }
    pub fn nth26(mut self, v: Byte) -> Self {
        self.0[26] = v;
        self
    }
    pub fn nth27(mut self, v: Byte) -> Self {
        self.0[27] = v;
        self
    }
    pub fn nth28(mut self, v: Byte) -> Self {
        self.0[28] = v;
        self
    }
    pub fn nth29(mut self, v: Byte) -> Self {
        self.0[29] = v;
        self
    }
    pub fn nth30(mut self, v: Byte) -> Self {
        self.0[30] = v;
        self
    }
    pub fn nth31(mut self, v: Byte) -> Self {
        self.0[31] = v;
        self
    }
    pub fn nth32(mut self, v: Byte) -> Self {
        self.0[32] = v;
        self
    }
    pub fn nth33(mut self, v: Byte) -> Self {
        self.0[33] = v;
        self
    }
    pub fn nth34(mut self, v: Byte) -> Self {
        self.0[34] = v;
        self
    }
    pub fn nth35(mut self, v: Byte) -> Self {
        self.0[35] = v;
        self
    }
    pub fn nth36(mut self, v: Byte) -> Self {
        self.0[36] = v;
        self
    }
    pub fn nth37(mut self, v: Byte) -> Self {
        self.0[37] = v;
        self
    }
    pub fn nth38(mut self, v: Byte) -> Self {
        self.0[38] = v;
        self
    }
    pub fn nth39(mut self, v: Byte) -> Self {
        self.0[39] = v;
        self
    }
    pub fn nth40(mut self, v: Byte) -> Self {
        self.0[40] = v;
        self
    }
    pub fn nth41(mut self, v: Byte) -> Self {
        self.0[41] = v;
        self
    }
    pub fn nth42(mut self, v: Byte) -> Self {
        self.0[42] = v;
        self
    }
    pub fn nth43(mut self, v: Byte) -> Self {
        self.0[43] = v;
        self
    }
    pub fn nth44(mut self, v: Byte) -> Self {
        self.0[44] = v;
        self
    }
    pub fn nth45(mut self, v: Byte) -> Self {
        self.0[45] = v;
        self
    }
    pub fn nth46(mut self, v: Byte) -> Self {
        self.0[46] = v;
        self
    }
    pub fn nth47(mut self, v: Byte) -> Self {
        self.0[47] = v;
        self
    }
    pub fn nth48(mut self, v: Byte) -> Self {
        self.0[48] = v;
        self
    }
    pub fn nth49(mut self, v: Byte) -> Self {
        self.0[49] = v;
        self
    }
    pub fn nth50(mut self, v: Byte) -> Self {
        self.0[50] = v;
        self
    }
    pub fn nth51(mut self, v: Byte) -> Self {
        self.0[51] = v;
        self
    }
    pub fn nth52(mut self, v: Byte) -> Self {
        self.0[52] = v;
        self
    }
    pub fn nth53(mut self, v: Byte) -> Self {
        self.0[53] = v;
        self
    }
    pub fn nth54(mut self, v: Byte) -> Self {
        self.0[54] = v;
        self
    }
    pub fn nth55(mut self, v: Byte) -> Self {
        self.0[55] = v;
        self
    }
    pub fn nth56(mut self, v: Byte) -> Self {
        self.0[56] = v;
        self
    }
    pub fn nth57(mut self, v: Byte) -> Self {
        self.0[57] = v;
        self
    }
    pub fn nth58(mut self, v: Byte) -> Self {
        self.0[58] = v;
        self
    }
    pub fn nth59(mut self, v: Byte) -> Self {
        self.0[59] = v;
        self
    }
    pub fn nth60(mut self, v: Byte) -> Self {
        self.0[60] = v;
        self
    }
    pub fn nth61(mut self, v: Byte) -> Self {
        self.0[61] = v;
        self
    }
    pub fn nth62(mut self, v: Byte) -> Self {
        self.0[62] = v;
        self
    }
    pub fn nth63(mut self, v: Byte) -> Self {
        self.0[63] = v;
        self
    }
}
impl molecule::prelude::Builder for EcdsaSignatureBuilder {
    type Entity = EcdsaSignature;
    const NAME: &'static str = "EcdsaSignatureBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        writer.write_all(self.0[10].as_slice())?;
        writer.write_all(self.0[11].as_slice())?;
        writer.write_all(self.0[12].as_slice())?;
        writer.write_all(self.0[13].as_slice())?;
        writer.write_all(self.0[14].as_slice())?;
        writer.write_all(self.0[15].as_slice())?;
        writer.write_all(self.0[16].as_slice())?;
        writer.write_all(self.0[17].as_slice())?;
        writer.write_all(self.0[18].as_slice())?;
        writer.write_all(self.0[19].as_slice())?;
        writer.write_all(self.0[20].as_slice())?;
        writer.write_all(self.0[21].as_slice())?;
        writer.write_all(self.0[22].as_slice())?;
        writer.write_all(self.0[23].as_slice())?;
        writer.write_all(self.0[24].as_slice())?;
        writer.write_all(self.0[25].as_slice())?;
        writer.write_all(self.0[26].as_slice())?;
        writer.write_all(self.0[27].as_slice())?;
        writer.write_all(self.0[28].as_slice())?;
        writer.write_all(self.0[29].as_slice())?;
        writer.write_all(self.0[30].as_slice())?;
        writer.write_all(self.0[31].as_slice())?;
        writer.write_all(self.0[32].as_slice())?;
        writer.write_all(self.0[33].as_slice())?;
        writer.write_all(self.0[34].as_slice())?;
        writer.write_all(self.0[35].as_slice())?;
        writer.write_all(self.0[36].as_slice())?;
        writer.write_all(self.0[37].as_slice())?;
        writer.write_all(self.0[38].as_slice())?;
        writer.write_all(self.0[39].as_slice())?;
        writer.write_all(self.0[40].as_slice())?;
        writer.write_all(self.0[41].as_slice())?;
        writer.write_all(self.0[42].as_slice())?;
        writer.write_all(self.0[43].as_slice())?;
        writer.write_all(self.0[44].as_slice())?;
        writer.write_all(self.0[45].as_slice())?;
        writer.write_all(self.0[46].as_slice())?;
        writer.write_all(self.0[47].as_slice())?;
        writer.write_all(self.0[48].as_slice())?;
        writer.write_all(self.0[49].as_slice())?;
        writer.write_all(self.0[50].as_slice())?;
        writer.write_all(self.0[51].as_slice())?;
        writer.write_all(self.0[52].as_slice())?;
        writer.write_all(self.0[53].as_slice())?;
        writer.write_all(self.0[54].as_slice())?;
        writer.write_all(self.0[55].as_slice())?;
        writer.write_all(self.0[56].as_slice())?;
        writer.write_all(self.0[57].as_slice())?;
        writer.write_all(self.0[58].as_slice())?;
        writer.write_all(self.0[59].as_slice())?;
        writer.write_all(self.0[60].as_slice())?;
        writer.write_all(self.0[61].as_slice())?;
        writer.write_all(self.0[62].as_slice())?;
        writer.write_all(self.0[63].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        EcdsaSignature::new_unchecked(inner.into())
    }
}
impl From<[Byte; 64usize]> for EcdsaSignature {
    fn from(value: [Byte; 64usize]) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl ::core::convert::TryFrom<&[Byte]> for EcdsaSignature {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[Byte]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(Self::new_builder()
            .set(<&[Byte; 64usize]>::try_from(value)?.clone())
            .build())
    }
}
impl From<EcdsaSignature> for [Byte; 64usize] {
    #[track_caller]
    fn from(value: EcdsaSignature) -> Self {
        [
            value.nth0(),
            value.nth1(),
            value.nth2(),
            value.nth3(),
            value.nth4(),
            value.nth5(),
            value.nth6(),
            value.nth7(),
            value.nth8(),
            value.nth9(),
            value.nth10(),
            value.nth11(),
            value.nth12(),
            value.nth13(),
            value.nth14(),
            value.nth15(),
            value.nth16(),
            value.nth17(),
            value.nth18(),
            value.nth19(),
            value.nth20(),
            value.nth21(),
            value.nth22(),
            value.nth23(),
            value.nth24(),
            value.nth25(),
            value.nth26(),
            value.nth27(),
            value.nth28(),
            value.nth29(),
            value.nth30(),
            value.nth31(),
            value.nth32(),
            value.nth33(),
            value.nth34(),
            value.nth35(),
            value.nth36(),
            value.nth37(),
            value.nth38(),
            value.nth39(),
            value.nth40(),
            value.nth41(),
            value.nth42(),
            value.nth43(),
            value.nth44(),
            value.nth45(),
            value.nth46(),
            value.nth47(),
            value.nth48(),
            value.nth49(),
            value.nth50(),
            value.nth51(),
            value.nth52(),
            value.nth53(),
            value.nth54(),
            value.nth55(),
            value.nth56(),
            value.nth57(),
            value.nth58(),
            value.nth59(),
            value.nth60(),
            value.nth61(),
            value.nth62(),
            value.nth63(),
        ]
    }
}
impl From<[u8; 64usize]> for EcdsaSignature {
    fn from(value: [u8; 64usize]) -> Self {
        EcdsaSignatureReader::new_unchecked(&value).to_entity()
    }
}
impl ::core::convert::TryFrom<&[u8]> for EcdsaSignature {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[u8]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(<[u8; 64usize]>::try_from(value)?.into())
    }
}
impl From<EcdsaSignature> for [u8; 64usize] {
    #[track_caller]
    fn from(value: EcdsaSignature) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<EcdsaSignatureReader<'a>> for &'a [u8; 64usize] {
    #[track_caller]
    fn from(value: EcdsaSignatureReader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<&'a EcdsaSignatureReader<'a>> for &'a [u8; 64usize] {
    #[track_caller]
    fn from(value: &'a EcdsaSignatureReader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
#[derive(Clone)]
pub struct PubNonce(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for PubNonce {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for PubNonce {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for PubNonce {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for PubNonce {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        PubNonce::new_unchecked(v)
    }
}
impl PubNonce {
    const DEFAULT_VALUE: [u8; 66] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0,
    ];
    pub const TOTAL_SIZE: usize = 66;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 66;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn nth9(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(9..10))
    }
    pub fn nth10(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(10..11))
    }
    pub fn nth11(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(11..12))
    }
    pub fn nth12(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(12..13))
    }
    pub fn nth13(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(13..14))
    }
    pub fn nth14(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(14..15))
    }
    pub fn nth15(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(15..16))
    }
    pub fn nth16(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(16..17))
    }
    pub fn nth17(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(17..18))
    }
    pub fn nth18(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(18..19))
    }
    pub fn nth19(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(19..20))
    }
    pub fn nth20(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(20..21))
    }
    pub fn nth21(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(21..22))
    }
    pub fn nth22(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(22..23))
    }
    pub fn nth23(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(23..24))
    }
    pub fn nth24(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(24..25))
    }
    pub fn nth25(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(25..26))
    }
    pub fn nth26(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(26..27))
    }
    pub fn nth27(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(27..28))
    }
    pub fn nth28(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(28..29))
    }
    pub fn nth29(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(29..30))
    }
    pub fn nth30(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(30..31))
    }
    pub fn nth31(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(31..32))
    }
    pub fn nth32(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(32..33))
    }
    pub fn nth33(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(33..34))
    }
    pub fn nth34(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(34..35))
    }
    pub fn nth35(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(35..36))
    }
    pub fn nth36(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(36..37))
    }
    pub fn nth37(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(37..38))
    }
    pub fn nth38(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(38..39))
    }
    pub fn nth39(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(39..40))
    }
    pub fn nth40(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(40..41))
    }
    pub fn nth41(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(41..42))
    }
    pub fn nth42(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(42..43))
    }
    pub fn nth43(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(43..44))
    }
    pub fn nth44(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(44..45))
    }
    pub fn nth45(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(45..46))
    }
    pub fn nth46(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(46..47))
    }
    pub fn nth47(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(47..48))
    }
    pub fn nth48(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(48..49))
    }
    pub fn nth49(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(49..50))
    }
    pub fn nth50(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(50..51))
    }
    pub fn nth51(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(51..52))
    }
    pub fn nth52(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(52..53))
    }
    pub fn nth53(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(53..54))
    }
    pub fn nth54(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(54..55))
    }
    pub fn nth55(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(55..56))
    }
    pub fn nth56(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(56..57))
    }
    pub fn nth57(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(57..58))
    }
    pub fn nth58(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(58..59))
    }
    pub fn nth59(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(59..60))
    }
    pub fn nth60(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(60..61))
    }
    pub fn nth61(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(61..62))
    }
    pub fn nth62(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(62..63))
    }
    pub fn nth63(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(63..64))
    }
    pub fn nth64(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(64..65))
    }
    pub fn nth65(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(65..66))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> PubNonceReader<'r> {
        PubNonceReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for PubNonce {
    type Builder = PubNonceBuilder;
    const NAME: &'static str = "PubNonce";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        PubNonce(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PubNonceReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PubNonceReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
            self.nth10(),
            self.nth11(),
            self.nth12(),
            self.nth13(),
            self.nth14(),
            self.nth15(),
            self.nth16(),
            self.nth17(),
            self.nth18(),
            self.nth19(),
            self.nth20(),
            self.nth21(),
            self.nth22(),
            self.nth23(),
            self.nth24(),
            self.nth25(),
            self.nth26(),
            self.nth27(),
            self.nth28(),
            self.nth29(),
            self.nth30(),
            self.nth31(),
            self.nth32(),
            self.nth33(),
            self.nth34(),
            self.nth35(),
            self.nth36(),
            self.nth37(),
            self.nth38(),
            self.nth39(),
            self.nth40(),
            self.nth41(),
            self.nth42(),
            self.nth43(),
            self.nth44(),
            self.nth45(),
            self.nth46(),
            self.nth47(),
            self.nth48(),
            self.nth49(),
            self.nth50(),
            self.nth51(),
            self.nth52(),
            self.nth53(),
            self.nth54(),
            self.nth55(),
            self.nth56(),
            self.nth57(),
            self.nth58(),
            self.nth59(),
            self.nth60(),
            self.nth61(),
            self.nth62(),
            self.nth63(),
            self.nth64(),
            self.nth65(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct PubNonceReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for PubNonceReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for PubNonceReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for PubNonceReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> PubNonceReader<'r> {
    pub const TOTAL_SIZE: usize = 66;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 66;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn nth9(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[9..10])
    }
    pub fn nth10(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[10..11])
    }
    pub fn nth11(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[11..12])
    }
    pub fn nth12(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[12..13])
    }
    pub fn nth13(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[13..14])
    }
    pub fn nth14(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[14..15])
    }
    pub fn nth15(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[15..16])
    }
    pub fn nth16(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[16..17])
    }
    pub fn nth17(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[17..18])
    }
    pub fn nth18(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[18..19])
    }
    pub fn nth19(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[19..20])
    }
    pub fn nth20(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[20..21])
    }
    pub fn nth21(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[21..22])
    }
    pub fn nth22(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[22..23])
    }
    pub fn nth23(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[23..24])
    }
    pub fn nth24(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[24..25])
    }
    pub fn nth25(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[25..26])
    }
    pub fn nth26(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[26..27])
    }
    pub fn nth27(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[27..28])
    }
    pub fn nth28(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[28..29])
    }
    pub fn nth29(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[29..30])
    }
    pub fn nth30(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[30..31])
    }
    pub fn nth31(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[31..32])
    }
    pub fn nth32(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[32..33])
    }
    pub fn nth33(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[33..34])
    }
    pub fn nth34(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[34..35])
    }
    pub fn nth35(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[35..36])
    }
    pub fn nth36(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[36..37])
    }
    pub fn nth37(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[37..38])
    }
    pub fn nth38(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[38..39])
    }
    pub fn nth39(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[39..40])
    }
    pub fn nth40(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[40..41])
    }
    pub fn nth41(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[41..42])
    }
    pub fn nth42(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[42..43])
    }
    pub fn nth43(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[43..44])
    }
    pub fn nth44(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[44..45])
    }
    pub fn nth45(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[45..46])
    }
    pub fn nth46(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[46..47])
    }
    pub fn nth47(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[47..48])
    }
    pub fn nth48(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[48..49])
    }
    pub fn nth49(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[49..50])
    }
    pub fn nth50(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[50..51])
    }
    pub fn nth51(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[51..52])
    }
    pub fn nth52(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[52..53])
    }
    pub fn nth53(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[53..54])
    }
    pub fn nth54(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[54..55])
    }
    pub fn nth55(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[55..56])
    }
    pub fn nth56(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[56..57])
    }
    pub fn nth57(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[57..58])
    }
    pub fn nth58(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[58..59])
    }
    pub fn nth59(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[59..60])
    }
    pub fn nth60(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[60..61])
    }
    pub fn nth61(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[61..62])
    }
    pub fn nth62(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[62..63])
    }
    pub fn nth63(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[63..64])
    }
    pub fn nth64(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[64..65])
    }
    pub fn nth65(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[65..66])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for PubNonceReader<'r> {
    type Entity = PubNonce;
    const NAME: &'static str = "PubNonceReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        PubNonceReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct PubNonceBuilder(pub(crate) [Byte; 66]);
impl ::core::fmt::Debug for PubNonceBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for PubNonceBuilder {
    fn default() -> Self {
        PubNonceBuilder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl PubNonceBuilder {
    pub const TOTAL_SIZE: usize = 66;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 66;
    pub fn set(mut self, v: [Byte; 66]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Byte) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: Byte) -> Self {
        self.0[7] = v;
        self
    }
    pub fn nth8(mut self, v: Byte) -> Self {
        self.0[8] = v;
        self
    }
    pub fn nth9(mut self, v: Byte) -> Self {
        self.0[9] = v;
        self
    }
    pub fn nth10(mut self, v: Byte) -> Self {
        self.0[10] = v;
        self
    }
    pub fn nth11(mut self, v: Byte) -> Self {
        self.0[11] = v;
        self
    }
    pub fn nth12(mut self, v: Byte) -> Self {
        self.0[12] = v;
        self
    }
    pub fn nth13(mut self, v: Byte) -> Self {
        self.0[13] = v;
        self
    }
    pub fn nth14(mut self, v: Byte) -> Self {
        self.0[14] = v;
        self
    }
    pub fn nth15(mut self, v: Byte) -> Self {
        self.0[15] = v;
        self
    }
    pub fn nth16(mut self, v: Byte) -> Self {
        self.0[16] = v;
        self
    }
    pub fn nth17(mut self, v: Byte) -> Self {
        self.0[17] = v;
        self
    }
    pub fn nth18(mut self, v: Byte) -> Self {
        self.0[18] = v;
        self
    }
    pub fn nth19(mut self, v: Byte) -> Self {
        self.0[19] = v;
        self
    }
    pub fn nth20(mut self, v: Byte) -> Self {
        self.0[20] = v;
        self
    }
    pub fn nth21(mut self, v: Byte) -> Self {
        self.0[21] = v;
        self
    }
    pub fn nth22(mut self, v: Byte) -> Self {
        self.0[22] = v;
        self
    }
    pub fn nth23(mut self, v: Byte) -> Self {
        self.0[23] = v;
        self
    }
    pub fn nth24(mut self, v: Byte) -> Self {
        self.0[24] = v;
        self
    }
    pub fn nth25(mut self, v: Byte) -> Self {
        self.0[25] = v;
        self
    }
    pub fn nth26(mut self, v: Byte) -> Self {
        self.0[26] = v;
        self
    }
    pub fn nth27(mut self, v: Byte) -> Self {
        self.0[27] = v;
        self
    }
    pub fn nth28(mut self, v: Byte) -> Self {
        self.0[28] = v;
        self
    }
    pub fn nth29(mut self, v: Byte) -> Self {
        self.0[29] = v;
        self
    }
    pub fn nth30(mut self, v: Byte) -> Self {
        self.0[30] = v;
        self
    }
    pub fn nth31(mut self, v: Byte) -> Self {
        self.0[31] = v;
        self
    }
    pub fn nth32(mut self, v: Byte) -> Self {
        self.0[32] = v;
        self
    }
    pub fn nth33(mut self, v: Byte) -> Self {
        self.0[33] = v;
        self
    }
    pub fn nth34(mut self, v: Byte) -> Self {
        self.0[34] = v;
        self
    }
    pub fn nth35(mut self, v: Byte) -> Self {
        self.0[35] = v;
        self
    }
    pub fn nth36(mut self, v: Byte) -> Self {
        self.0[36] = v;
        self
    }
    pub fn nth37(mut self, v: Byte) -> Self {
        self.0[37] = v;
        self
    }
    pub fn nth38(mut self, v: Byte) -> Self {
        self.0[38] = v;
        self
    }
    pub fn nth39(mut self, v: Byte) -> Self {
        self.0[39] = v;
        self
    }
    pub fn nth40(mut self, v: Byte) -> Self {
        self.0[40] = v;
        self
    }
    pub fn nth41(mut self, v: Byte) -> Self {
        self.0[41] = v;
        self
    }
    pub fn nth42(mut self, v: Byte) -> Self {
        self.0[42] = v;
        self
    }
    pub fn nth43(mut self, v: Byte) -> Self {
        self.0[43] = v;
        self
    }
    pub fn nth44(mut self, v: Byte) -> Self {
        self.0[44] = v;
        self
    }
    pub fn nth45(mut self, v: Byte) -> Self {
        self.0[45] = v;
        self
    }
    pub fn nth46(mut self, v: Byte) -> Self {
        self.0[46] = v;
        self
    }
    pub fn nth47(mut self, v: Byte) -> Self {
        self.0[47] = v;
        self
    }
    pub fn nth48(mut self, v: Byte) -> Self {
        self.0[48] = v;
        self
    }
    pub fn nth49(mut self, v: Byte) -> Self {
        self.0[49] = v;
        self
    }
    pub fn nth50(mut self, v: Byte) -> Self {
        self.0[50] = v;
        self
    }
    pub fn nth51(mut self, v: Byte) -> Self {
        self.0[51] = v;
        self
    }
    pub fn nth52(mut self, v: Byte) -> Self {
        self.0[52] = v;
        self
    }
    pub fn nth53(mut self, v: Byte) -> Self {
        self.0[53] = v;
        self
    }
    pub fn nth54(mut self, v: Byte) -> Self {
        self.0[54] = v;
        self
    }
    pub fn nth55(mut self, v: Byte) -> Self {
        self.0[55] = v;
        self
    }
    pub fn nth56(mut self, v: Byte) -> Self {
        self.0[56] = v;
        self
    }
    pub fn nth57(mut self, v: Byte) -> Self {
        self.0[57] = v;
        self
    }
    pub fn nth58(mut self, v: Byte) -> Self {
        self.0[58] = v;
        self
    }
    pub fn nth59(mut self, v: Byte) -> Self {
        self.0[59] = v;
        self
    }
    pub fn nth60(mut self, v: Byte) -> Self {
        self.0[60] = v;
        self
    }
    pub fn nth61(mut self, v: Byte) -> Self {
        self.0[61] = v;
        self
    }
    pub fn nth62(mut self, v: Byte) -> Self {
        self.0[62] = v;
        self
    }
    pub fn nth63(mut self, v: Byte) -> Self {
        self.0[63] = v;
        self
    }
    pub fn nth64(mut self, v: Byte) -> Self {
        self.0[64] = v;
        self
    }
    pub fn nth65(mut self, v: Byte) -> Self {
        self.0[65] = v;
        self
    }
}
impl molecule::prelude::Builder for PubNonceBuilder {
    type Entity = PubNonce;
    const NAME: &'static str = "PubNonceBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        writer.write_all(self.0[10].as_slice())?;
        writer.write_all(self.0[11].as_slice())?;
        writer.write_all(self.0[12].as_slice())?;
        writer.write_all(self.0[13].as_slice())?;
        writer.write_all(self.0[14].as_slice())?;
        writer.write_all(self.0[15].as_slice())?;
        writer.write_all(self.0[16].as_slice())?;
        writer.write_all(self.0[17].as_slice())?;
        writer.write_all(self.0[18].as_slice())?;
        writer.write_all(self.0[19].as_slice())?;
        writer.write_all(self.0[20].as_slice())?;
        writer.write_all(self.0[21].as_slice())?;
        writer.write_all(self.0[22].as_slice())?;
        writer.write_all(self.0[23].as_slice())?;
        writer.write_all(self.0[24].as_slice())?;
        writer.write_all(self.0[25].as_slice())?;
        writer.write_all(self.0[26].as_slice())?;
        writer.write_all(self.0[27].as_slice())?;
        writer.write_all(self.0[28].as_slice())?;
        writer.write_all(self.0[29].as_slice())?;
        writer.write_all(self.0[30].as_slice())?;
        writer.write_all(self.0[31].as_slice())?;
        writer.write_all(self.0[32].as_slice())?;
        writer.write_all(self.0[33].as_slice())?;
        writer.write_all(self.0[34].as_slice())?;
        writer.write_all(self.0[35].as_slice())?;
        writer.write_all(self.0[36].as_slice())?;
        writer.write_all(self.0[37].as_slice())?;
        writer.write_all(self.0[38].as_slice())?;
        writer.write_all(self.0[39].as_slice())?;
        writer.write_all(self.0[40].as_slice())?;
        writer.write_all(self.0[41].as_slice())?;
        writer.write_all(self.0[42].as_slice())?;
        writer.write_all(self.0[43].as_slice())?;
        writer.write_all(self.0[44].as_slice())?;
        writer.write_all(self.0[45].as_slice())?;
        writer.write_all(self.0[46].as_slice())?;
        writer.write_all(self.0[47].as_slice())?;
        writer.write_all(self.0[48].as_slice())?;
        writer.write_all(self.0[49].as_slice())?;
        writer.write_all(self.0[50].as_slice())?;
        writer.write_all(self.0[51].as_slice())?;
        writer.write_all(self.0[52].as_slice())?;
        writer.write_all(self.0[53].as_slice())?;
        writer.write_all(self.0[54].as_slice())?;
        writer.write_all(self.0[55].as_slice())?;
        writer.write_all(self.0[56].as_slice())?;
        writer.write_all(self.0[57].as_slice())?;
        writer.write_all(self.0[58].as_slice())?;
        writer.write_all(self.0[59].as_slice())?;
        writer.write_all(self.0[60].as_slice())?;
        writer.write_all(self.0[61].as_slice())?;
        writer.write_all(self.0[62].as_slice())?;
        writer.write_all(self.0[63].as_slice())?;
        writer.write_all(self.0[64].as_slice())?;
        writer.write_all(self.0[65].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        PubNonce::new_unchecked(inner.into())
    }
}
impl From<[Byte; 66usize]> for PubNonce {
    fn from(value: [Byte; 66usize]) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl ::core::convert::TryFrom<&[Byte]> for PubNonce {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[Byte]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(Self::new_builder()
            .set(<&[Byte; 66usize]>::try_from(value)?.clone())
            .build())
    }
}
impl From<PubNonce> for [Byte; 66usize] {
    #[track_caller]
    fn from(value: PubNonce) -> Self {
        [
            value.nth0(),
            value.nth1(),
            value.nth2(),
            value.nth3(),
            value.nth4(),
            value.nth5(),
            value.nth6(),
            value.nth7(),
            value.nth8(),
            value.nth9(),
            value.nth10(),
            value.nth11(),
            value.nth12(),
            value.nth13(),
            value.nth14(),
            value.nth15(),
            value.nth16(),
            value.nth17(),
            value.nth18(),
            value.nth19(),
            value.nth20(),
            value.nth21(),
            value.nth22(),
            value.nth23(),
            value.nth24(),
            value.nth25(),
            value.nth26(),
            value.nth27(),
            value.nth28(),
            value.nth29(),
            value.nth30(),
            value.nth31(),
            value.nth32(),
            value.nth33(),
            value.nth34(),
            value.nth35(),
            value.nth36(),
            value.nth37(),
            value.nth38(),
            value.nth39(),
            value.nth40(),
            value.nth41(),
            value.nth42(),
            value.nth43(),
            value.nth44(),
            value.nth45(),
            value.nth46(),
            value.nth47(),
            value.nth48(),
            value.nth49(),
            value.nth50(),
            value.nth51(),
            value.nth52(),
            value.nth53(),
            value.nth54(),
            value.nth55(),
            value.nth56(),
            value.nth57(),
            value.nth58(),
            value.nth59(),
            value.nth60(),
            value.nth61(),
            value.nth62(),
            value.nth63(),
            value.nth64(),
            value.nth65(),
        ]
    }
}
impl From<[u8; 66usize]> for PubNonce {
    fn from(value: [u8; 66usize]) -> Self {
        PubNonceReader::new_unchecked(&value).to_entity()
    }
}
impl ::core::convert::TryFrom<&[u8]> for PubNonce {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[u8]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(<[u8; 66usize]>::try_from(value)?.into())
    }
}
impl From<PubNonce> for [u8; 66usize] {
    #[track_caller]
    fn from(value: PubNonce) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<PubNonceReader<'a>> for &'a [u8; 66usize] {
    #[track_caller]
    fn from(value: PubNonceReader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<&'a PubNonceReader<'a>> for &'a [u8; 66usize] {
    #[track_caller]
    fn from(value: &'a PubNonceReader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
#[derive(Clone)]
pub struct PubNonceOpt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for PubNonceOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for PubNonceOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for PubNonceOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for PubNonceOpt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        PubNonceOpt::new_unchecked(v)
    }
}
impl PubNonceOpt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<PubNonce> {
        if self.is_none() {
            None
        } else {
            Some(PubNonce::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> PubNonceOptReader<'r> {
        PubNonceOptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for PubNonceOpt {
    type Builder = PubNonceOptBuilder;
    const NAME: &'static str = "PubNonceOpt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        PubNonceOpt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PubNonceOptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PubNonceOptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct PubNonceOptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for PubNonceOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for PubNonceOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for PubNonceOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> PubNonceOptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<PubNonceReader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(PubNonceReader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for PubNonceOptReader<'r> {
    type Entity = PubNonceOpt;
    const NAME: &'static str = "PubNonceOptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        PubNonceOptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            PubNonceReader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct PubNonceOptBuilder(pub(crate) Option<PubNonce>);
impl PubNonceOptBuilder {
    pub fn set(mut self, v: Option<PubNonce>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for PubNonceOptBuilder {
    type Entity = PubNonceOpt;
    const NAME: &'static str = "PubNonceOptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        PubNonceOpt::new_unchecked(inner.into())
    }
}
impl From<PubNonce> for PubNonceOpt {
    fn from(value: PubNonce) -> Self {
        Self::new_builder().set(Some(value)).build()
    }
}
#[derive(Clone)]
pub struct Pubkey(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Pubkey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Pubkey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Pubkey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Pubkey {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Pubkey::new_unchecked(v)
    }
}
impl Pubkey {
    const DEFAULT_VALUE: [u8; 33] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0,
    ];
    pub const TOTAL_SIZE: usize = 33;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 33;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn nth9(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(9..10))
    }
    pub fn nth10(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(10..11))
    }
    pub fn nth11(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(11..12))
    }
    pub fn nth12(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(12..13))
    }
    pub fn nth13(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(13..14))
    }
    pub fn nth14(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(14..15))
    }
    pub fn nth15(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(15..16))
    }
    pub fn nth16(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(16..17))
    }
    pub fn nth17(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(17..18))
    }
    pub fn nth18(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(18..19))
    }
    pub fn nth19(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(19..20))
    }
    pub fn nth20(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(20..21))
    }
    pub fn nth21(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(21..22))
    }
    pub fn nth22(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(22..23))
    }
    pub fn nth23(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(23..24))
    }
    pub fn nth24(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(24..25))
    }
    pub fn nth25(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(25..26))
    }
    pub fn nth26(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(26..27))
    }
    pub fn nth27(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(27..28))
    }
    pub fn nth28(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(28..29))
    }
    pub fn nth29(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(29..30))
    }
    pub fn nth30(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(30..31))
    }
    pub fn nth31(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(31..32))
    }
    pub fn nth32(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(32..33))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> PubkeyReader<'r> {
        PubkeyReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Pubkey {
    type Builder = PubkeyBuilder;
    const NAME: &'static str = "Pubkey";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Pubkey(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PubkeyReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PubkeyReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
            self.nth10(),
            self.nth11(),
            self.nth12(),
            self.nth13(),
            self.nth14(),
            self.nth15(),
            self.nth16(),
            self.nth17(),
            self.nth18(),
            self.nth19(),
            self.nth20(),
            self.nth21(),
            self.nth22(),
            self.nth23(),
            self.nth24(),
            self.nth25(),
            self.nth26(),
            self.nth27(),
            self.nth28(),
            self.nth29(),
            self.nth30(),
            self.nth31(),
            self.nth32(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct PubkeyReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for PubkeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for PubkeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for PubkeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> PubkeyReader<'r> {
    pub const TOTAL_SIZE: usize = 33;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 33;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn nth9(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[9..10])
    }
    pub fn nth10(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[10..11])
    }
    pub fn nth11(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[11..12])
    }
    pub fn nth12(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[12..13])
    }
    pub fn nth13(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[13..14])
    }
    pub fn nth14(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[14..15])
    }
    pub fn nth15(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[15..16])
    }
    pub fn nth16(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[16..17])
    }
    pub fn nth17(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[17..18])
    }
    pub fn nth18(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[18..19])
    }
    pub fn nth19(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[19..20])
    }
    pub fn nth20(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[20..21])
    }
    pub fn nth21(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[21..22])
    }
    pub fn nth22(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[22..23])
    }
    pub fn nth23(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[23..24])
    }
    pub fn nth24(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[24..25])
    }
    pub fn nth25(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[25..26])
    }
    pub fn nth26(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[26..27])
    }
    pub fn nth27(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[27..28])
    }
    pub fn nth28(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[28..29])
    }
    pub fn nth29(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[29..30])
    }
    pub fn nth30(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[30..31])
    }
    pub fn nth31(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[31..32])
    }
    pub fn nth32(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[32..33])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for PubkeyReader<'r> {
    type Entity = Pubkey;
    const NAME: &'static str = "PubkeyReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        PubkeyReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct PubkeyBuilder(pub(crate) [Byte; 33]);
impl ::core::fmt::Debug for PubkeyBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for PubkeyBuilder {
    fn default() -> Self {
        PubkeyBuilder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl PubkeyBuilder {
    pub const TOTAL_SIZE: usize = 33;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 33;
    pub fn set(mut self, v: [Byte; 33]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Byte) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: Byte) -> Self {
        self.0[7] = v;
        self
    }
    pub fn nth8(mut self, v: Byte) -> Self {
        self.0[8] = v;
        self
    }
    pub fn nth9(mut self, v: Byte) -> Self {
        self.0[9] = v;
        self
    }
    pub fn nth10(mut self, v: Byte) -> Self {
        self.0[10] = v;
        self
    }
    pub fn nth11(mut self, v: Byte) -> Self {
        self.0[11] = v;
        self
    }
    pub fn nth12(mut self, v: Byte) -> Self {
        self.0[12] = v;
        self
    }
    pub fn nth13(mut self, v: Byte) -> Self {
        self.0[13] = v;
        self
    }
    pub fn nth14(mut self, v: Byte) -> Self {
        self.0[14] = v;
        self
    }
    pub fn nth15(mut self, v: Byte) -> Self {
        self.0[15] = v;
        self
    }
    pub fn nth16(mut self, v: Byte) -> Self {
        self.0[16] = v;
        self
    }
    pub fn nth17(mut self, v: Byte) -> Self {
        self.0[17] = v;
        self
    }
    pub fn nth18(mut self, v: Byte) -> Self {
        self.0[18] = v;
        self
    }
    pub fn nth19(mut self, v: Byte) -> Self {
        self.0[19] = v;
        self
    }
    pub fn nth20(mut self, v: Byte) -> Self {
        self.0[20] = v;
        self
    }
    pub fn nth21(mut self, v: Byte) -> Self {
        self.0[21] = v;
        self
    }
    pub fn nth22(mut self, v: Byte) -> Self {
        self.0[22] = v;
        self
    }
    pub fn nth23(mut self, v: Byte) -> Self {
        self.0[23] = v;
        self
    }
    pub fn nth24(mut self, v: Byte) -> Self {
        self.0[24] = v;
        self
    }
    pub fn nth25(mut self, v: Byte) -> Self {
        self.0[25] = v;
        self
    }
    pub fn nth26(mut self, v: Byte) -> Self {
        self.0[26] = v;
        self
    }
    pub fn nth27(mut self, v: Byte) -> Self {
        self.0[27] = v;
        self
    }
    pub fn nth28(mut self, v: Byte) -> Self {
        self.0[28] = v;
        self
    }
    pub fn nth29(mut self, v: Byte) -> Self {
        self.0[29] = v;
        self
    }
    pub fn nth30(mut self, v: Byte) -> Self {
        self.0[30] = v;
        self
    }
    pub fn nth31(mut self, v: Byte) -> Self {
        self.0[31] = v;
        self
    }
    pub fn nth32(mut self, v: Byte) -> Self {
        self.0[32] = v;
        self
    }
}
impl molecule::prelude::Builder for PubkeyBuilder {
    type Entity = Pubkey;
    const NAME: &'static str = "PubkeyBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        writer.write_all(self.0[10].as_slice())?;
        writer.write_all(self.0[11].as_slice())?;
        writer.write_all(self.0[12].as_slice())?;
        writer.write_all(self.0[13].as_slice())?;
        writer.write_all(self.0[14].as_slice())?;
        writer.write_all(self.0[15].as_slice())?;
        writer.write_all(self.0[16].as_slice())?;
        writer.write_all(self.0[17].as_slice())?;
        writer.write_all(self.0[18].as_slice())?;
        writer.write_all(self.0[19].as_slice())?;
        writer.write_all(self.0[20].as_slice())?;
        writer.write_all(self.0[21].as_slice())?;
        writer.write_all(self.0[22].as_slice())?;
        writer.write_all(self.0[23].as_slice())?;
        writer.write_all(self.0[24].as_slice())?;
        writer.write_all(self.0[25].as_slice())?;
        writer.write_all(self.0[26].as_slice())?;
        writer.write_all(self.0[27].as_slice())?;
        writer.write_all(self.0[28].as_slice())?;
        writer.write_all(self.0[29].as_slice())?;
        writer.write_all(self.0[30].as_slice())?;
        writer.write_all(self.0[31].as_slice())?;
        writer.write_all(self.0[32].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Pubkey::new_unchecked(inner.into())
    }
}
impl From<[Byte; 33usize]> for Pubkey {
    fn from(value: [Byte; 33usize]) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl ::core::convert::TryFrom<&[Byte]> for Pubkey {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[Byte]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(Self::new_builder()
            .set(<&[Byte; 33usize]>::try_from(value)?.clone())
            .build())
    }
}
impl From<Pubkey> for [Byte; 33usize] {
    #[track_caller]
    fn from(value: Pubkey) -> Self {
        [
            value.nth0(),
            value.nth1(),
            value.nth2(),
            value.nth3(),
            value.nth4(),
            value.nth5(),
            value.nth6(),
            value.nth7(),
            value.nth8(),
            value.nth9(),
            value.nth10(),
            value.nth11(),
            value.nth12(),
            value.nth13(),
            value.nth14(),
            value.nth15(),
            value.nth16(),
            value.nth17(),
            value.nth18(),
            value.nth19(),
            value.nth20(),
            value.nth21(),
            value.nth22(),
            value.nth23(),
            value.nth24(),
            value.nth25(),
            value.nth26(),
            value.nth27(),
            value.nth28(),
            value.nth29(),
            value.nth30(),
            value.nth31(),
            value.nth32(),
        ]
    }
}
impl From<[u8; 33usize]> for Pubkey {
    fn from(value: [u8; 33usize]) -> Self {
        PubkeyReader::new_unchecked(&value).to_entity()
    }
}
impl ::core::convert::TryFrom<&[u8]> for Pubkey {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[u8]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(<[u8; 33usize]>::try_from(value)?.into())
    }
}
impl From<Pubkey> for [u8; 33usize] {
    #[track_caller]
    fn from(value: Pubkey) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<PubkeyReader<'a>> for &'a [u8; 33usize] {
    #[track_caller]
    fn from(value: PubkeyReader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<&'a PubkeyReader<'a>> for &'a [u8; 33usize] {
    #[track_caller]
    fn from(value: &'a PubkeyReader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
#[derive(Clone)]
pub struct Uint64Opt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Uint64Opt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Uint64Opt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Uint64Opt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for Uint64Opt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Uint64Opt::new_unchecked(v)
    }
}
impl Uint64Opt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Uint64> {
        if self.is_none() {
            None
        } else {
            Some(Uint64::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> Uint64OptReader<'r> {
        Uint64OptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Uint64Opt {
    type Builder = Uint64OptBuilder;
    const NAME: &'static str = "Uint64Opt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Uint64Opt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint64OptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint64OptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct Uint64OptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Uint64OptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Uint64OptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Uint64OptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> Uint64OptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Uint64Reader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(Uint64Reader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for Uint64OptReader<'r> {
    type Entity = Uint64Opt;
    const NAME: &'static str = "Uint64OptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Uint64OptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            Uint64Reader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct Uint64OptBuilder(pub(crate) Option<Uint64>);
impl Uint64OptBuilder {
    pub fn set(mut self, v: Option<Uint64>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for Uint64OptBuilder {
    type Entity = Uint64Opt;
    const NAME: &'static str = "Uint64OptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Uint64Opt::new_unchecked(inner.into())
    }
}
impl From<Uint64> for Uint64Opt {
    fn from(value: Uint64) -> Self {
        Self::new_builder().set(Some(value)).build()
    }
}
#[derive(Clone)]
pub struct Uint128Opt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Uint128Opt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Uint128Opt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Uint128Opt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for Uint128Opt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Uint128Opt::new_unchecked(v)
    }
}
impl Uint128Opt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Uint128> {
        if self.is_none() {
            None
        } else {
            Some(Uint128::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> Uint128OptReader<'r> {
        Uint128OptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Uint128Opt {
    type Builder = Uint128OptBuilder;
    const NAME: &'static str = "Uint128Opt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Uint128Opt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint128OptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint128OptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct Uint128OptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Uint128OptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Uint128OptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Uint128OptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> Uint128OptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Uint128Reader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(Uint128Reader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for Uint128OptReader<'r> {
    type Entity = Uint128Opt;
    const NAME: &'static str = "Uint128OptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Uint128OptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            Uint128Reader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct Uint128OptBuilder(pub(crate) Option<Uint128>);
impl Uint128OptBuilder {
    pub fn set(mut self, v: Option<Uint128>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for Uint128OptBuilder {
    type Entity = Uint128Opt;
    const NAME: &'static str = "Uint128OptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Uint128Opt::new_unchecked(inner.into())
    }
}
impl From<Uint128> for Uint128Opt {
    fn from(value: Uint128) -> Self {
        Self::new_builder().set(Some(value)).build()
    }
}
#[derive(Clone)]
pub struct OpenChannel(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for OpenChannel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for OpenChannel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for OpenChannel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "chain_hash", self.chain_hash())?;
        write!(f, ", {}: {}", "channel_id", self.channel_id())?;
        write!(
            f,
            ", {}: {}",
            "funding_udt_type_script",
            self.funding_udt_type_script()
        )?;
        write!(f, ", {}: {}", "funding_amount", self.funding_amount())?;
        write!(f, ", {}: {}", "shutdown_script", self.shutdown_script())?;
        write!(
            f,
            ", {}: {}",
            "reserved_ckb_amount",
            self.reserved_ckb_amount()
        )?;
        write!(f, ", {}: {}", "funding_fee_rate", self.funding_fee_rate())?;
        write!(
            f,
            ", {}: {}",
            "commitment_fee_rate",
            self.commitment_fee_rate()
        )?;
        write!(
            f,
            ", {}: {}",
            "max_tlc_value_in_flight",
            self.max_tlc_value_in_flight()
        )?;
        write!(
            f,
            ", {}: {}",
            "max_tlc_number_in_flight",
            self.max_tlc_number_in_flight()
        )?;
        write!(
            f,
            ", {}: {}",
            "commitment_delay_epoch",
            self.commitment_delay_epoch()
        )?;
        write!(f, ", {}: {}", "funding_pubkey", self.funding_pubkey())?;
        write!(f, ", {}: {}", "tlc_basepoint", self.tlc_basepoint())?;
        write!(
            f,
            ", {}: {}",
            "first_per_commitment_point",
            self.first_per_commitment_point()
        )?;
        write!(
            f,
            ", {}: {}",
            "second_per_commitment_point",
            self.second_per_commitment_point()
        )?;
        write!(
            f,
            ", {}: {}",
            "channel_annoucement_nonce",
            self.channel_annoucement_nonce()
        )?;
        write!(f, ", {}: {}", "next_local_nonce", self.next_local_nonce())?;
        write!(f, ", {}: {}", "channel_flags", self.channel_flags())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for OpenChannel {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        OpenChannel::new_unchecked(v)
    }
}
impl OpenChannel {
    const DEFAULT_VALUE: [u8; 464] = [
        208, 1, 0, 0, 76, 0, 0, 0, 108, 0, 0, 0, 140, 0, 0, 0, 140, 0, 0, 0, 156, 0, 0, 0, 209, 0,
        0, 0, 217, 0, 0, 0, 225, 0, 0, 0, 233, 0, 0, 0, 249, 0, 0, 0, 1, 1, 0, 0, 9, 1, 0, 0, 42,
        1, 0, 0, 75, 1, 0, 0, 108, 1, 0, 0, 141, 1, 0, 0, 141, 1, 0, 0, 207, 1, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 18;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn chain_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn channel_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn funding_udt_type_script(&self) -> ScriptOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        ScriptOpt::new_unchecked(self.0.slice(start..end))
    }
    pub fn funding_amount(&self) -> Uint128 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint128::new_unchecked(self.0.slice(start..end))
    }
    pub fn shutdown_script(&self) -> Script {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Script::new_unchecked(self.0.slice(start..end))
    }
    pub fn reserved_ckb_amount(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn funding_fee_rate(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn commitment_fee_rate(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn max_tlc_value_in_flight(&self) -> Uint128 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        Uint128::new_unchecked(self.0.slice(start..end))
    }
    pub fn max_tlc_number_in_flight(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        let end = molecule::unpack_number(&slice[44..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn commitment_delay_epoch(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[44..]) as usize;
        let end = molecule::unpack_number(&slice[48..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn funding_pubkey(&self) -> Pubkey {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[48..]) as usize;
        let end = molecule::unpack_number(&slice[52..]) as usize;
        Pubkey::new_unchecked(self.0.slice(start..end))
    }
    pub fn tlc_basepoint(&self) -> Pubkey {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[52..]) as usize;
        let end = molecule::unpack_number(&slice[56..]) as usize;
        Pubkey::new_unchecked(self.0.slice(start..end))
    }
    pub fn first_per_commitment_point(&self) -> Pubkey {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[56..]) as usize;
        let end = molecule::unpack_number(&slice[60..]) as usize;
        Pubkey::new_unchecked(self.0.slice(start..end))
    }
    pub fn second_per_commitment_point(&self) -> Pubkey {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[60..]) as usize;
        let end = molecule::unpack_number(&slice[64..]) as usize;
        Pubkey::new_unchecked(self.0.slice(start..end))
    }
    pub fn channel_annoucement_nonce(&self) -> PubNonceOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[64..]) as usize;
        let end = molecule::unpack_number(&slice[68..]) as usize;
        PubNonceOpt::new_unchecked(self.0.slice(start..end))
    }
    pub fn next_local_nonce(&self) -> PubNonce {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[68..]) as usize;
        let end = molecule::unpack_number(&slice[72..]) as usize;
        PubNonce::new_unchecked(self.0.slice(start..end))
    }
    pub fn channel_flags(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[72..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[76..]) as usize;
            Byte::new_unchecked(self.0.slice(start..end))
        } else {
            Byte::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> OpenChannelReader<'r> {
        OpenChannelReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for OpenChannel {
    type Builder = OpenChannelBuilder;
    const NAME: &'static str = "OpenChannel";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        OpenChannel(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        OpenChannelReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        OpenChannelReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .chain_hash(self.chain_hash())
            .channel_id(self.channel_id())
            .funding_udt_type_script(self.funding_udt_type_script())
            .funding_amount(self.funding_amount())
            .shutdown_script(self.shutdown_script())
            .reserved_ckb_amount(self.reserved_ckb_amount())
            .funding_fee_rate(self.funding_fee_rate())
            .commitment_fee_rate(self.commitment_fee_rate())
            .max_tlc_value_in_flight(self.max_tlc_value_in_flight())
            .max_tlc_number_in_flight(self.max_tlc_number_in_flight())
            .commitment_delay_epoch(self.commitment_delay_epoch())
            .funding_pubkey(self.funding_pubkey())
            .tlc_basepoint(self.tlc_basepoint())
            .first_per_commitment_point(self.first_per_commitment_point())
            .second_per_commitment_point(self.second_per_commitment_point())
            .channel_annoucement_nonce(self.channel_annoucement_nonce())
            .next_local_nonce(self.next_local_nonce())
            .channel_flags(self.channel_flags())
    }
}
#[derive(Clone, Copy)]
pub struct OpenChannelReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for OpenChannelReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for OpenChannelReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for OpenChannelReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "chain_hash", self.chain_hash())?;
        write!(f, ", {}: {}", "channel_id", self.channel_id())?;
        write!(
            f,
            ", {}: {}",
            "funding_udt_type_script",
            self.funding_udt_type_script()
        )?;
        write!(f, ", {}: {}", "funding_amount", self.funding_amount())?;
        write!(f, ", {}: {}", "shutdown_script", self.shutdown_script())?;
        write!(
            f,
            ", {}: {}",
            "reserved_ckb_amount",
            self.reserved_ckb_amount()
        )?;
        write!(f, ", {}: {}", "funding_fee_rate", self.funding_fee_rate())?;
        write!(
            f,
            ", {}: {}",
            "commitment_fee_rate",
            self.commitment_fee_rate()
        )?;
        write!(
            f,
            ", {}: {}",
            "max_tlc_value_in_flight",
            self.max_tlc_value_in_flight()
        )?;
        write!(
            f,
            ", {}: {}",
            "max_tlc_number_in_flight",
            self.max_tlc_number_in_flight()
        )?;
        write!(
            f,
            ", {}: {}",
            "commitment_delay_epoch",
            self.commitment_delay_epoch()
        )?;
        write!(f, ", {}: {}", "funding_pubkey", self.funding_pubkey())?;
        write!(f, ", {}: {}", "tlc_basepoint", self.tlc_basepoint())?;
        write!(
            f,
            ", {}: {}",
            "first_per_commitment_point",
            self.first_per_commitment_point()
        )?;
        write!(
            f,
            ", {}: {}",
            "second_per_commitment_point",
            self.second_per_commitment_point()
        )?;
        write!(
            f,
            ", {}: {}",
            "channel_annoucement_nonce",
            self.channel_annoucement_nonce()
        )?;
        write!(f, ", {}: {}", "next_local_nonce", self.next_local_nonce())?;
        write!(f, ", {}: {}", "channel_flags", self.channel_flags())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> OpenChannelReader<'r> {
    pub const FIELD_COUNT: usize = 18;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn chain_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn channel_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn funding_udt_type_script(&self) -> ScriptOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        ScriptOptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn funding_amount(&self) -> Uint128Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint128Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn shutdown_script(&self) -> ScriptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        ScriptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn reserved_ckb_amount(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn funding_fee_rate(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn commitment_fee_rate(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn max_tlc_value_in_flight(&self) -> Uint128Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        Uint128Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn max_tlc_number_in_flight(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        let end = molecule::unpack_number(&slice[44..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn commitment_delay_epoch(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[44..]) as usize;
        let end = molecule::unpack_number(&slice[48..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn funding_pubkey(&self) -> PubkeyReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[48..]) as usize;
        let end = molecule::unpack_number(&slice[52..]) as usize;
        PubkeyReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn tlc_basepoint(&self) -> PubkeyReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[52..]) as usize;
        let end = molecule::unpack_number(&slice[56..]) as usize;
        PubkeyReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn first_per_commitment_point(&self) -> PubkeyReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[56..]) as usize;
        let end = molecule::unpack_number(&slice[60..]) as usize;
        PubkeyReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn second_per_commitment_point(&self) -> PubkeyReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[60..]) as usize;
        let end = molecule::unpack_number(&slice[64..]) as usize;
        PubkeyReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn channel_annoucement_nonce(&self) -> PubNonceOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[64..]) as usize;
        let end = molecule::unpack_number(&slice[68..]) as usize;
        PubNonceOptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn next_local_nonce(&self) -> PubNonceReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[68..]) as usize;
        let end = molecule::unpack_number(&slice[72..]) as usize;
        PubNonceReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn channel_flags(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[72..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[76..]) as usize;
            ByteReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            ByteReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for OpenChannelReader<'r> {
    type Entity = OpenChannel;
    const NAME: &'static str = "OpenChannelReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        OpenChannelReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        ScriptOptReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Uint128Reader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        ScriptReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        Uint64Reader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Uint64Reader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        Uint64Reader::verify(&slice[offsets[7]..offsets[8]], compatible)?;
        Uint128Reader::verify(&slice[offsets[8]..offsets[9]], compatible)?;
        Uint64Reader::verify(&slice[offsets[9]..offsets[10]], compatible)?;
        Uint64Reader::verify(&slice[offsets[10]..offsets[11]], compatible)?;
        PubkeyReader::verify(&slice[offsets[11]..offsets[12]], compatible)?;
        PubkeyReader::verify(&slice[offsets[12]..offsets[13]], compatible)?;
        PubkeyReader::verify(&slice[offsets[13]..offsets[14]], compatible)?;
        PubkeyReader::verify(&slice[offsets[14]..offsets[15]], compatible)?;
        PubNonceOptReader::verify(&slice[offsets[15]..offsets[16]], compatible)?;
        PubNonceReader::verify(&slice[offsets[16]..offsets[17]], compatible)?;
        ByteReader::verify(&slice[offsets[17]..offsets[18]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct OpenChannelBuilder {
    pub(crate) chain_hash: Byte32,
    pub(crate) channel_id: Byte32,
    pub(crate) funding_udt_type_script: ScriptOpt,
    pub(crate) funding_amount: Uint128,
    pub(crate) shutdown_script: Script,
    pub(crate) reserved_ckb_amount: Uint64,
    pub(crate) funding_fee_rate: Uint64,
    pub(crate) commitment_fee_rate: Uint64,
    pub(crate) max_tlc_value_in_flight: Uint128,
    pub(crate) max_tlc_number_in_flight: Uint64,
    pub(crate) commitment_delay_epoch: Uint64,
    pub(crate) funding_pubkey: Pubkey,
    pub(crate) tlc_basepoint: Pubkey,
    pub(crate) first_per_commitment_point: Pubkey,
    pub(crate) second_per_commitment_point: Pubkey,
    pub(crate) channel_annoucement_nonce: PubNonceOpt,
    pub(crate) next_local_nonce: PubNonce,
    pub(crate) channel_flags: Byte,
}
impl OpenChannelBuilder {
    pub const FIELD_COUNT: usize = 18;
    pub fn chain_hash(mut self, v: Byte32) -> Self {
        self.chain_hash = v;
        self
    }
    pub fn channel_id(mut self, v: Byte32) -> Self {
        self.channel_id = v;
        self
    }
    pub fn funding_udt_type_script(mut self, v: ScriptOpt) -> Self {
        self.funding_udt_type_script = v;
        self
    }
    pub fn funding_amount(mut self, v: Uint128) -> Self {
        self.funding_amount = v;
        self
    }
    pub fn shutdown_script(mut self, v: Script) -> Self {
        self.shutdown_script = v;
        self
    }
    pub fn reserved_ckb_amount(mut self, v: Uint64) -> Self {
        self.reserved_ckb_amount = v;
        self
    }
    pub fn funding_fee_rate(mut self, v: Uint64) -> Self {
        self.funding_fee_rate = v;
        self
    }
    pub fn commitment_fee_rate(mut self, v: Uint64) -> Self {
        self.commitment_fee_rate = v;
        self
    }
    pub fn max_tlc_value_in_flight(mut self, v: Uint128) -> Self {
        self.max_tlc_value_in_flight = v;
        self
    }
    pub fn max_tlc_number_in_flight(mut self, v: Uint64) -> Self {
        self.max_tlc_number_in_flight = v;
        self
    }
    pub fn commitment_delay_epoch(mut self, v: Uint64) -> Self {
        self.commitment_delay_epoch = v;
        self
    }
    pub fn funding_pubkey(mut self, v: Pubkey) -> Self {
        self.funding_pubkey = v;
        self
    }
    pub fn tlc_basepoint(mut self, v: Pubkey) -> Self {
        self.tlc_basepoint = v;
        self
    }
    pub fn first_per_commitment_point(mut self, v: Pubkey) -> Self {
        self.first_per_commitment_point = v;
        self
    }
    pub fn second_per_commitment_point(mut self, v: Pubkey) -> Self {
        self.second_per_commitment_point = v;
        self
    }
    pub fn channel_annoucement_nonce(mut self, v: PubNonceOpt) -> Self {
        self.channel_annoucement_nonce = v;
        self
    }
    pub fn next_local_nonce(mut self, v: PubNonce) -> Self {
        self.next_local_nonce = v;
        self
    }
    pub fn channel_flags(mut self, v: Byte) -> Self {
        self.channel_flags = v;
        self
    }
}
impl molecule::prelude::Builder for OpenChannelBuilder {
    type Entity = OpenChannel;
    const NAME: &'static str = "OpenChannelBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.chain_hash.as_slice().len()
            + self.channel_id.as_slice().len()
            + self.funding_udt_type_script.as_slice().len()
            + self.funding_amount.as_slice().len()
            + self.shutdown_script.as_slice().len()
            + self.reserved_ckb_amount.as_slice().len()
            + self.funding_fee_rate.as_slice().len()
            + self.commitment_fee_rate.as_slice().len()
            + self.max_tlc_value_in_flight.as_slice().len()
            + self.max_tlc_number_in_flight.as_slice().len()
            + self.commitment_delay_epoch.as_slice().len()
            + self.funding_pubkey.as_slice().len()
            + self.tlc_basepoint.as_slice().len()
            + self.first_per_commitment_point.as_slice().len()
            + self.second_per_commitment_point.as_slice().len()
            + self.channel_annoucement_nonce.as_slice().len()
            + self.next_local_nonce.as_slice().len()
            + self.channel_flags.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.chain_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.channel_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.funding_udt_type_script.as_slice().len();
        offsets.push(total_size);
        total_size += self.funding_amount.as_slice().len();
        offsets.push(total_size);
        total_size += self.shutdown_script.as_slice().len();
        offsets.push(total_size);
        total_size += self.reserved_ckb_amount.as_slice().len();
        offsets.push(total_size);
        total_size += self.funding_fee_rate.as_slice().len();
        offsets.push(total_size);
        total_size += self.commitment_fee_rate.as_slice().len();
        offsets.push(total_size);
        total_size += self.max_tlc_value_in_flight.as_slice().len();
        offsets.push(total_size);
        total_size += self.max_tlc_number_in_flight.as_slice().len();
        offsets.push(total_size);
        total_size += self.commitment_delay_epoch.as_slice().len();
        offsets.push(total_size);
        total_size += self.funding_pubkey.as_slice().len();
        offsets.push(total_size);
        total_size += self.tlc_basepoint.as_slice().len();
        offsets.push(total_size);
        total_size += self.first_per_commitment_point.as_slice().len();
        offsets.push(total_size);
        total_size += self.second_per_commitment_point.as_slice().len();
        offsets.push(total_size);
        total_size += self.channel_annoucement_nonce.as_slice().len();
        offsets.push(total_size);
        total_size += self.next_local_nonce.as_slice().len();
        offsets.push(total_size);
        total_size += self.channel_flags.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.chain_hash.as_slice())?;
        writer.write_all(self.channel_id.as_slice())?;
        writer.write_all(self.funding_udt_type_script.as_slice())?;
        writer.write_all(self.funding_amount.as_slice())?;
        writer.write_all(self.shutdown_script.as_slice())?;
        writer.write_all(self.reserved_ckb_amount.as_slice())?;
        writer.write_all(self.funding_fee_rate.as_slice())?;
        writer.write_all(self.commitment_fee_rate.as_slice())?;
        writer.write_all(self.max_tlc_value_in_flight.as_slice())?;
        writer.write_all(self.max_tlc_number_in_flight.as_slice())?;
        writer.write_all(self.commitment_delay_epoch.as_slice())?;
        writer.write_all(self.funding_pubkey.as_slice())?;
        writer.write_all(self.tlc_basepoint.as_slice())?;
        writer.write_all(self.first_per_commitment_point.as_slice())?;
        writer.write_all(self.second_per_commitment_point.as_slice())?;
        writer.write_all(self.channel_annoucement_nonce.as_slice())?;
        writer.write_all(self.next_local_nonce.as_slice())?;
        writer.write_all(self.channel_flags.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        OpenChannel::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct AcceptChannel(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for AcceptChannel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for AcceptChannel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for AcceptChannel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, ", {}: {}", "funding_amount", self.funding_amount())?;
        write!(f, ", {}: {}", "shutdown_script", self.shutdown_script())?;
        write!(
            f,
            ", {}: {}",
            "reserved_ckb_amount",
            self.reserved_ckb_amount()
        )?;
        write!(
            f,
            ", {}: {}",
            "max_tlc_value_in_flight",
            self.max_tlc_value_in_flight()
        )?;
        write!(
            f,
            ", {}: {}",
            "max_tlc_number_in_flight",
            self.max_tlc_number_in_flight()
        )?;
        write!(f, ", {}: {}", "funding_pubkey", self.funding_pubkey())?;
        write!(f, ", {}: {}", "tlc_basepoint", self.tlc_basepoint())?;
        write!(
            f,
            ", {}: {}",
            "first_per_commitment_point",
            self.first_per_commitment_point()
        )?;
        write!(
            f,
            ", {}: {}",
            "second_per_commitment_point",
            self.second_per_commitment_point()
        )?;
        write!(
            f,
            ", {}: {}",
            "channel_annoucement_nonce",
            self.channel_annoucement_nonce()
        )?;
        write!(f, ", {}: {}", "next_local_nonce", self.next_local_nonce())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for AcceptChannel {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        AcceptChannel::new_unchecked(v)
    }
}
impl AcceptChannel {
    const DEFAULT_VALUE: [u8; 383] = [
        127, 1, 0, 0, 52, 0, 0, 0, 84, 0, 0, 0, 100, 0, 0, 0, 153, 0, 0, 0, 161, 0, 0, 0, 177, 0,
        0, 0, 185, 0, 0, 0, 218, 0, 0, 0, 251, 0, 0, 0, 28, 1, 0, 0, 61, 1, 0, 0, 61, 1, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0,
        49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0,
    ];
    pub const FIELD_COUNT: usize = 12;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn funding_amount(&self) -> Uint128 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint128::new_unchecked(self.0.slice(start..end))
    }
    pub fn shutdown_script(&self) -> Script {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Script::new_unchecked(self.0.slice(start..end))
    }
    pub fn reserved_ckb_amount(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn max_tlc_value_in_flight(&self) -> Uint128 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint128::new_unchecked(self.0.slice(start..end))
    }
    pub fn max_tlc_number_in_flight(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn funding_pubkey(&self) -> Pubkey {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Pubkey::new_unchecked(self.0.slice(start..end))
    }
    pub fn tlc_basepoint(&self) -> Pubkey {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        Pubkey::new_unchecked(self.0.slice(start..end))
    }
    pub fn first_per_commitment_point(&self) -> Pubkey {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        Pubkey::new_unchecked(self.0.slice(start..end))
    }
    pub fn second_per_commitment_point(&self) -> Pubkey {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        let end = molecule::unpack_number(&slice[44..]) as usize;
        Pubkey::new_unchecked(self.0.slice(start..end))
    }
    pub fn channel_annoucement_nonce(&self) -> PubNonceOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[44..]) as usize;
        let end = molecule::unpack_number(&slice[48..]) as usize;
        PubNonceOpt::new_unchecked(self.0.slice(start..end))
    }
    pub fn next_local_nonce(&self) -> PubNonce {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[48..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[52..]) as usize;
            PubNonce::new_unchecked(self.0.slice(start..end))
        } else {
            PubNonce::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> AcceptChannelReader<'r> {
        AcceptChannelReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for AcceptChannel {
    type Builder = AcceptChannelBuilder;
    const NAME: &'static str = "AcceptChannel";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        AcceptChannel(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AcceptChannelReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AcceptChannelReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .channel_id(self.channel_id())
            .funding_amount(self.funding_amount())
            .shutdown_script(self.shutdown_script())
            .reserved_ckb_amount(self.reserved_ckb_amount())
            .max_tlc_value_in_flight(self.max_tlc_value_in_flight())
            .max_tlc_number_in_flight(self.max_tlc_number_in_flight())
            .funding_pubkey(self.funding_pubkey())
            .tlc_basepoint(self.tlc_basepoint())
            .first_per_commitment_point(self.first_per_commitment_point())
            .second_per_commitment_point(self.second_per_commitment_point())
            .channel_annoucement_nonce(self.channel_annoucement_nonce())
            .next_local_nonce(self.next_local_nonce())
    }
}
#[derive(Clone, Copy)]
pub struct AcceptChannelReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for AcceptChannelReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for AcceptChannelReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for AcceptChannelReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, ", {}: {}", "funding_amount", self.funding_amount())?;
        write!(f, ", {}: {}", "shutdown_script", self.shutdown_script())?;
        write!(
            f,
            ", {}: {}",
            "reserved_ckb_amount",
            self.reserved_ckb_amount()
        )?;
        write!(
            f,
            ", {}: {}",
            "max_tlc_value_in_flight",
            self.max_tlc_value_in_flight()
        )?;
        write!(
            f,
            ", {}: {}",
            "max_tlc_number_in_flight",
            self.max_tlc_number_in_flight()
        )?;
        write!(f, ", {}: {}", "funding_pubkey", self.funding_pubkey())?;
        write!(f, ", {}: {}", "tlc_basepoint", self.tlc_basepoint())?;
        write!(
            f,
            ", {}: {}",
            "first_per_commitment_point",
            self.first_per_commitment_point()
        )?;
        write!(
            f,
            ", {}: {}",
            "second_per_commitment_point",
            self.second_per_commitment_point()
        )?;
        write!(
            f,
            ", {}: {}",
            "channel_annoucement_nonce",
            self.channel_annoucement_nonce()
        )?;
        write!(f, ", {}: {}", "next_local_nonce", self.next_local_nonce())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> AcceptChannelReader<'r> {
    pub const FIELD_COUNT: usize = 12;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn funding_amount(&self) -> Uint128Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint128Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn shutdown_script(&self) -> ScriptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        ScriptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn reserved_ckb_amount(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn max_tlc_value_in_flight(&self) -> Uint128Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint128Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn max_tlc_number_in_flight(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn funding_pubkey(&self) -> PubkeyReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        PubkeyReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn tlc_basepoint(&self) -> PubkeyReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        PubkeyReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn first_per_commitment_point(&self) -> PubkeyReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        PubkeyReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn second_per_commitment_point(&self) -> PubkeyReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        let end = molecule::unpack_number(&slice[44..]) as usize;
        PubkeyReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn channel_annoucement_nonce(&self) -> PubNonceOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[44..]) as usize;
        let end = molecule::unpack_number(&slice[48..]) as usize;
        PubNonceOptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn next_local_nonce(&self) -> PubNonceReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[48..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[52..]) as usize;
            PubNonceReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            PubNonceReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for AcceptChannelReader<'r> {
    type Entity = AcceptChannel;
    const NAME: &'static str = "AcceptChannelReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        AcceptChannelReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint128Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        ScriptReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Uint64Reader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Uint128Reader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        Uint64Reader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        PubkeyReader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        PubkeyReader::verify(&slice[offsets[7]..offsets[8]], compatible)?;
        PubkeyReader::verify(&slice[offsets[8]..offsets[9]], compatible)?;
        PubkeyReader::verify(&slice[offsets[9]..offsets[10]], compatible)?;
        PubNonceOptReader::verify(&slice[offsets[10]..offsets[11]], compatible)?;
        PubNonceReader::verify(&slice[offsets[11]..offsets[12]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct AcceptChannelBuilder {
    pub(crate) channel_id: Byte32,
    pub(crate) funding_amount: Uint128,
    pub(crate) shutdown_script: Script,
    pub(crate) reserved_ckb_amount: Uint64,
    pub(crate) max_tlc_value_in_flight: Uint128,
    pub(crate) max_tlc_number_in_flight: Uint64,
    pub(crate) funding_pubkey: Pubkey,
    pub(crate) tlc_basepoint: Pubkey,
    pub(crate) first_per_commitment_point: Pubkey,
    pub(crate) second_per_commitment_point: Pubkey,
    pub(crate) channel_annoucement_nonce: PubNonceOpt,
    pub(crate) next_local_nonce: PubNonce,
}
impl AcceptChannelBuilder {
    pub const FIELD_COUNT: usize = 12;
    pub fn channel_id(mut self, v: Byte32) -> Self {
        self.channel_id = v;
        self
    }
    pub fn funding_amount(mut self, v: Uint128) -> Self {
        self.funding_amount = v;
        self
    }
    pub fn shutdown_script(mut self, v: Script) -> Self {
        self.shutdown_script = v;
        self
    }
    pub fn reserved_ckb_amount(mut self, v: Uint64) -> Self {
        self.reserved_ckb_amount = v;
        self
    }
    pub fn max_tlc_value_in_flight(mut self, v: Uint128) -> Self {
        self.max_tlc_value_in_flight = v;
        self
    }
    pub fn max_tlc_number_in_flight(mut self, v: Uint64) -> Self {
        self.max_tlc_number_in_flight = v;
        self
    }
    pub fn funding_pubkey(mut self, v: Pubkey) -> Self {
        self.funding_pubkey = v;
        self
    }
    pub fn tlc_basepoint(mut self, v: Pubkey) -> Self {
        self.tlc_basepoint = v;
        self
    }
    pub fn first_per_commitment_point(mut self, v: Pubkey) -> Self {
        self.first_per_commitment_point = v;
        self
    }
    pub fn second_per_commitment_point(mut self, v: Pubkey) -> Self {
        self.second_per_commitment_point = v;
        self
    }
    pub fn channel_annoucement_nonce(mut self, v: PubNonceOpt) -> Self {
        self.channel_annoucement_nonce = v;
        self
    }
    pub fn next_local_nonce(mut self, v: PubNonce) -> Self {
        self.next_local_nonce = v;
        self
    }
}
impl molecule::prelude::Builder for AcceptChannelBuilder {
    type Entity = AcceptChannel;
    const NAME: &'static str = "AcceptChannelBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.channel_id.as_slice().len()
            + self.funding_amount.as_slice().len()
            + self.shutdown_script.as_slice().len()
            + self.reserved_ckb_amount.as_slice().len()
            + self.max_tlc_value_in_flight.as_slice().len()
            + self.max_tlc_number_in_flight.as_slice().len()
            + self.funding_pubkey.as_slice().len()
            + self.tlc_basepoint.as_slice().len()
            + self.first_per_commitment_point.as_slice().len()
            + self.second_per_commitment_point.as_slice().len()
            + self.channel_annoucement_nonce.as_slice().len()
            + self.next_local_nonce.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.channel_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.funding_amount.as_slice().len();
        offsets.push(total_size);
        total_size += self.shutdown_script.as_slice().len();
        offsets.push(total_size);
        total_size += self.reserved_ckb_amount.as_slice().len();
        offsets.push(total_size);
        total_size += self.max_tlc_value_in_flight.as_slice().len();
        offsets.push(total_size);
        total_size += self.max_tlc_number_in_flight.as_slice().len();
        offsets.push(total_size);
        total_size += self.funding_pubkey.as_slice().len();
        offsets.push(total_size);
        total_size += self.tlc_basepoint.as_slice().len();
        offsets.push(total_size);
        total_size += self.first_per_commitment_point.as_slice().len();
        offsets.push(total_size);
        total_size += self.second_per_commitment_point.as_slice().len();
        offsets.push(total_size);
        total_size += self.channel_annoucement_nonce.as_slice().len();
        offsets.push(total_size);
        total_size += self.next_local_nonce.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.channel_id.as_slice())?;
        writer.write_all(self.funding_amount.as_slice())?;
        writer.write_all(self.shutdown_script.as_slice())?;
        writer.write_all(self.reserved_ckb_amount.as_slice())?;
        writer.write_all(self.max_tlc_value_in_flight.as_slice())?;
        writer.write_all(self.max_tlc_number_in_flight.as_slice())?;
        writer.write_all(self.funding_pubkey.as_slice())?;
        writer.write_all(self.tlc_basepoint.as_slice())?;
        writer.write_all(self.first_per_commitment_point.as_slice())?;
        writer.write_all(self.second_per_commitment_point.as_slice())?;
        writer.write_all(self.channel_annoucement_nonce.as_slice())?;
        writer.write_all(self.next_local_nonce.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        AcceptChannel::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct CommitmentSigned(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for CommitmentSigned {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for CommitmentSigned {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for CommitmentSigned {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(
            f,
            ", {}: {}",
            "funding_tx_partial_signature",
            self.funding_tx_partial_signature()
        )?;
        write!(
            f,
            ", {}: {}",
            "commitment_tx_partial_signature",
            self.commitment_tx_partial_signature()
        )?;
        write!(f, ", {}: {}", "next_local_nonce", self.next_local_nonce())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for CommitmentSigned {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        CommitmentSigned::new_unchecked(v)
    }
}
impl CommitmentSigned {
    const DEFAULT_VALUE: [u8; 162] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const TOTAL_SIZE: usize = 162;
    pub const FIELD_SIZES: [usize; 4] = [32, 32, 32, 66];
    pub const FIELD_COUNT: usize = 4;
    pub fn channel_id(&self) -> Byte32 {
        Byte32::new_unchecked(self.0.slice(0..32))
    }
    pub fn funding_tx_partial_signature(&self) -> Byte32 {
        Byte32::new_unchecked(self.0.slice(32..64))
    }
    pub fn commitment_tx_partial_signature(&self) -> Byte32 {
        Byte32::new_unchecked(self.0.slice(64..96))
    }
    pub fn next_local_nonce(&self) -> PubNonce {
        PubNonce::new_unchecked(self.0.slice(96..162))
    }
    pub fn as_reader<'r>(&'r self) -> CommitmentSignedReader<'r> {
        CommitmentSignedReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for CommitmentSigned {
    type Builder = CommitmentSignedBuilder;
    const NAME: &'static str = "CommitmentSigned";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        CommitmentSigned(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CommitmentSignedReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CommitmentSignedReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .channel_id(self.channel_id())
            .funding_tx_partial_signature(self.funding_tx_partial_signature())
            .commitment_tx_partial_signature(self.commitment_tx_partial_signature())
            .next_local_nonce(self.next_local_nonce())
    }
}
#[derive(Clone, Copy)]
pub struct CommitmentSignedReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for CommitmentSignedReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for CommitmentSignedReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for CommitmentSignedReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(
            f,
            ", {}: {}",
            "funding_tx_partial_signature",
            self.funding_tx_partial_signature()
        )?;
        write!(
            f,
            ", {}: {}",
            "commitment_tx_partial_signature",
            self.commitment_tx_partial_signature()
        )?;
        write!(f, ", {}: {}", "next_local_nonce", self.next_local_nonce())?;
        write!(f, " }}")
    }
}
impl<'r> CommitmentSignedReader<'r> {
    pub const TOTAL_SIZE: usize = 162;
    pub const FIELD_SIZES: [usize; 4] = [32, 32, 32, 66];
    pub const FIELD_COUNT: usize = 4;
    pub fn channel_id(&self) -> Byte32Reader<'r> {
        Byte32Reader::new_unchecked(&self.as_slice()[0..32])
    }
    pub fn funding_tx_partial_signature(&self) -> Byte32Reader<'r> {
        Byte32Reader::new_unchecked(&self.as_slice()[32..64])
    }
    pub fn commitment_tx_partial_signature(&self) -> Byte32Reader<'r> {
        Byte32Reader::new_unchecked(&self.as_slice()[64..96])
    }
    pub fn next_local_nonce(&self) -> PubNonceReader<'r> {
        PubNonceReader::new_unchecked(&self.as_slice()[96..162])
    }
}
impl<'r> molecule::prelude::Reader<'r> for CommitmentSignedReader<'r> {
    type Entity = CommitmentSigned;
    const NAME: &'static str = "CommitmentSignedReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        CommitmentSignedReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct CommitmentSignedBuilder {
    pub(crate) channel_id: Byte32,
    pub(crate) funding_tx_partial_signature: Byte32,
    pub(crate) commitment_tx_partial_signature: Byte32,
    pub(crate) next_local_nonce: PubNonce,
}
impl CommitmentSignedBuilder {
    pub const TOTAL_SIZE: usize = 162;
    pub const FIELD_SIZES: [usize; 4] = [32, 32, 32, 66];
    pub const FIELD_COUNT: usize = 4;
    pub fn channel_id(mut self, v: Byte32) -> Self {
        self.channel_id = v;
        self
    }
    pub fn funding_tx_partial_signature(mut self, v: Byte32) -> Self {
        self.funding_tx_partial_signature = v;
        self
    }
    pub fn commitment_tx_partial_signature(mut self, v: Byte32) -> Self {
        self.commitment_tx_partial_signature = v;
        self
    }
    pub fn next_local_nonce(mut self, v: PubNonce) -> Self {
        self.next_local_nonce = v;
        self
    }
}
impl molecule::prelude::Builder for CommitmentSignedBuilder {
    type Entity = CommitmentSigned;
    const NAME: &'static str = "CommitmentSignedBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.channel_id.as_slice())?;
        writer.write_all(self.funding_tx_partial_signature.as_slice())?;
        writer.write_all(self.commitment_tx_partial_signature.as_slice())?;
        writer.write_all(self.next_local_nonce.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        CommitmentSigned::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TxSignatures(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TxSignatures {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TxSignatures {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TxSignatures {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, ", {}: {}", "witnesses", self.witnesses())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TxSignatures {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TxSignatures::new_unchecked(v)
    }
}
impl TxSignatures {
    const DEFAULT_VALUE: [u8; 48] = [
        48, 0, 0, 0, 12, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn witnesses(&self) -> BytesVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            BytesVec::new_unchecked(self.0.slice(start..end))
        } else {
            BytesVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TxSignaturesReader<'r> {
        TxSignaturesReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TxSignatures {
    type Builder = TxSignaturesBuilder;
    const NAME: &'static str = "TxSignatures";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TxSignatures(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TxSignaturesReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TxSignaturesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .channel_id(self.channel_id())
            .witnesses(self.witnesses())
    }
}
#[derive(Clone, Copy)]
pub struct TxSignaturesReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TxSignaturesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TxSignaturesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TxSignaturesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, ", {}: {}", "witnesses", self.witnesses())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TxSignaturesReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn witnesses(&self) -> BytesVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            BytesVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TxSignaturesReader<'r> {
    type Entity = TxSignatures;
    const NAME: &'static str = "TxSignaturesReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TxSignaturesReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        BytesVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TxSignaturesBuilder {
    pub(crate) channel_id: Byte32,
    pub(crate) witnesses: BytesVec,
}
impl TxSignaturesBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn channel_id(mut self, v: Byte32) -> Self {
        self.channel_id = v;
        self
    }
    pub fn witnesses(mut self, v: BytesVec) -> Self {
        self.witnesses = v;
        self
    }
}
impl molecule::prelude::Builder for TxSignaturesBuilder {
    type Entity = TxSignatures;
    const NAME: &'static str = "TxSignaturesBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.channel_id.as_slice().len()
            + self.witnesses.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.channel_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.witnesses.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.channel_id.as_slice())?;
        writer.write_all(self.witnesses.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TxSignatures::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ChannelReady(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ChannelReady {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ChannelReady {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ChannelReady {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for ChannelReady {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        ChannelReady::new_unchecked(v)
    }
}
impl ChannelReady {
    const DEFAULT_VALUE: [u8; 32] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0,
    ];
    pub const TOTAL_SIZE: usize = 32;
    pub const FIELD_SIZES: [usize; 1] = [32];
    pub const FIELD_COUNT: usize = 1;
    pub fn channel_id(&self) -> Byte32 {
        Byte32::new_unchecked(self.0.slice(0..32))
    }
    pub fn as_reader<'r>(&'r self) -> ChannelReadyReader<'r> {
        ChannelReadyReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ChannelReady {
    type Builder = ChannelReadyBuilder;
    const NAME: &'static str = "ChannelReady";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ChannelReady(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelReadyReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelReadyReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().channel_id(self.channel_id())
    }
}
#[derive(Clone, Copy)]
pub struct ChannelReadyReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ChannelReadyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ChannelReadyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ChannelReadyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, " }}")
    }
}
impl<'r> ChannelReadyReader<'r> {
    pub const TOTAL_SIZE: usize = 32;
    pub const FIELD_SIZES: [usize; 1] = [32];
    pub const FIELD_COUNT: usize = 1;
    pub fn channel_id(&self) -> Byte32Reader<'r> {
        Byte32Reader::new_unchecked(&self.as_slice()[0..32])
    }
}
impl<'r> molecule::prelude::Reader<'r> for ChannelReadyReader<'r> {
    type Entity = ChannelReady;
    const NAME: &'static str = "ChannelReadyReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ChannelReadyReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct ChannelReadyBuilder {
    pub(crate) channel_id: Byte32,
}
impl ChannelReadyBuilder {
    pub const TOTAL_SIZE: usize = 32;
    pub const FIELD_SIZES: [usize; 1] = [32];
    pub const FIELD_COUNT: usize = 1;
    pub fn channel_id(mut self, v: Byte32) -> Self {
        self.channel_id = v;
        self
    }
}
impl molecule::prelude::Builder for ChannelReadyBuilder {
    type Entity = ChannelReady;
    const NAME: &'static str = "ChannelReadyBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.channel_id.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ChannelReady::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TxUpdate(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TxUpdate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TxUpdate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TxUpdate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, ", {}: {}", "tx", self.tx())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TxUpdate {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TxUpdate::new_unchecked(v)
    }
}
impl TxUpdate {
    const DEFAULT_VALUE: [u8; 112] = [
        112, 0, 0, 0, 12, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68, 0, 0, 0, 12, 0, 0, 0, 64, 0, 0, 0, 52, 0,
        0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn tx(&self) -> Transaction {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Transaction::new_unchecked(self.0.slice(start..end))
        } else {
            Transaction::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TxUpdateReader<'r> {
        TxUpdateReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TxUpdate {
    type Builder = TxUpdateBuilder;
    const NAME: &'static str = "TxUpdate";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TxUpdate(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TxUpdateReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TxUpdateReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .channel_id(self.channel_id())
            .tx(self.tx())
    }
}
#[derive(Clone, Copy)]
pub struct TxUpdateReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TxUpdateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TxUpdateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TxUpdateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, ", {}: {}", "tx", self.tx())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TxUpdateReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn tx(&self) -> TransactionReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            TransactionReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            TransactionReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TxUpdateReader<'r> {
    type Entity = TxUpdate;
    const NAME: &'static str = "TxUpdateReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TxUpdateReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        TransactionReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TxUpdateBuilder {
    pub(crate) channel_id: Byte32,
    pub(crate) tx: Transaction,
}
impl TxUpdateBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn channel_id(mut self, v: Byte32) -> Self {
        self.channel_id = v;
        self
    }
    pub fn tx(mut self, v: Transaction) -> Self {
        self.tx = v;
        self
    }
}
impl molecule::prelude::Builder for TxUpdateBuilder {
    type Entity = TxUpdate;
    const NAME: &'static str = "TxUpdateBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.channel_id.as_slice().len()
            + self.tx.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.channel_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.tx.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.channel_id.as_slice())?;
        writer.write_all(self.tx.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TxUpdate::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TxComplete(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TxComplete {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TxComplete {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TxComplete {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(
            f,
            ", {}: {}",
            "commitment_tx_partial_signature",
            self.commitment_tx_partial_signature()
        )?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for TxComplete {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TxComplete::new_unchecked(v)
    }
}
impl TxComplete {
    const DEFAULT_VALUE: [u8; 64] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0,
    ];
    pub const TOTAL_SIZE: usize = 64;
    pub const FIELD_SIZES: [usize; 2] = [32, 32];
    pub const FIELD_COUNT: usize = 2;
    pub fn channel_id(&self) -> Byte32 {
        Byte32::new_unchecked(self.0.slice(0..32))
    }
    pub fn commitment_tx_partial_signature(&self) -> Byte32 {
        Byte32::new_unchecked(self.0.slice(32..64))
    }
    pub fn as_reader<'r>(&'r self) -> TxCompleteReader<'r> {
        TxCompleteReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TxComplete {
    type Builder = TxCompleteBuilder;
    const NAME: &'static str = "TxComplete";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TxComplete(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TxCompleteReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TxCompleteReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .channel_id(self.channel_id())
            .commitment_tx_partial_signature(self.commitment_tx_partial_signature())
    }
}
#[derive(Clone, Copy)]
pub struct TxCompleteReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TxCompleteReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TxCompleteReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TxCompleteReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(
            f,
            ", {}: {}",
            "commitment_tx_partial_signature",
            self.commitment_tx_partial_signature()
        )?;
        write!(f, " }}")
    }
}
impl<'r> TxCompleteReader<'r> {
    pub const TOTAL_SIZE: usize = 64;
    pub const FIELD_SIZES: [usize; 2] = [32, 32];
    pub const FIELD_COUNT: usize = 2;
    pub fn channel_id(&self) -> Byte32Reader<'r> {
        Byte32Reader::new_unchecked(&self.as_slice()[0..32])
    }
    pub fn commitment_tx_partial_signature(&self) -> Byte32Reader<'r> {
        Byte32Reader::new_unchecked(&self.as_slice()[32..64])
    }
}
impl<'r> molecule::prelude::Reader<'r> for TxCompleteReader<'r> {
    type Entity = TxComplete;
    const NAME: &'static str = "TxCompleteReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TxCompleteReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TxCompleteBuilder {
    pub(crate) channel_id: Byte32,
    pub(crate) commitment_tx_partial_signature: Byte32,
}
impl TxCompleteBuilder {
    pub const TOTAL_SIZE: usize = 64;
    pub const FIELD_SIZES: [usize; 2] = [32, 32];
    pub const FIELD_COUNT: usize = 2;
    pub fn channel_id(mut self, v: Byte32) -> Self {
        self.channel_id = v;
        self
    }
    pub fn commitment_tx_partial_signature(mut self, v: Byte32) -> Self {
        self.commitment_tx_partial_signature = v;
        self
    }
}
impl molecule::prelude::Builder for TxCompleteBuilder {
    type Entity = TxComplete;
    const NAME: &'static str = "TxCompleteBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.channel_id.as_slice())?;
        writer.write_all(self.commitment_tx_partial_signature.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TxComplete::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TxAbort(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TxAbort {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TxAbort {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TxAbort {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, ", {}: {}", "message", self.message())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TxAbort {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TxAbort::new_unchecked(v)
    }
}
impl TxAbort {
    const DEFAULT_VALUE: [u8; 48] = [
        48, 0, 0, 0, 12, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn message(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Bytes::new_unchecked(self.0.slice(start..end))
        } else {
            Bytes::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TxAbortReader<'r> {
        TxAbortReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TxAbort {
    type Builder = TxAbortBuilder;
    const NAME: &'static str = "TxAbort";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TxAbort(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TxAbortReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TxAbortReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .channel_id(self.channel_id())
            .message(self.message())
    }
}
#[derive(Clone, Copy)]
pub struct TxAbortReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TxAbortReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TxAbortReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TxAbortReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, ", {}: {}", "message", self.message())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TxAbortReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn message(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TxAbortReader<'r> {
    type Entity = TxAbort;
    const NAME: &'static str = "TxAbortReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TxAbortReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        BytesReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TxAbortBuilder {
    pub(crate) channel_id: Byte32,
    pub(crate) message: Bytes,
}
impl TxAbortBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn channel_id(mut self, v: Byte32) -> Self {
        self.channel_id = v;
        self
    }
    pub fn message(mut self, v: Bytes) -> Self {
        self.message = v;
        self
    }
}
impl molecule::prelude::Builder for TxAbortBuilder {
    type Entity = TxAbort;
    const NAME: &'static str = "TxAbortBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.channel_id.as_slice().len()
            + self.message.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.channel_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.message.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.channel_id.as_slice())?;
        writer.write_all(self.message.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TxAbort::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TxInitRBF(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TxInitRBF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TxInitRBF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TxInitRBF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, ", {}: {}", "fee_rate", self.fee_rate())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TxInitRBF {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TxInitRBF::new_unchecked(v)
    }
}
impl TxInitRBF {
    const DEFAULT_VALUE: [u8; 52] = [
        52, 0, 0, 0, 12, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn fee_rate(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Uint64::new_unchecked(self.0.slice(start..end))
        } else {
            Uint64::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TxInitRBFReader<'r> {
        TxInitRBFReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TxInitRBF {
    type Builder = TxInitRBFBuilder;
    const NAME: &'static str = "TxInitRBF";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TxInitRBF(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TxInitRBFReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TxInitRBFReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .channel_id(self.channel_id())
            .fee_rate(self.fee_rate())
    }
}
#[derive(Clone, Copy)]
pub struct TxInitRBFReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TxInitRBFReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TxInitRBFReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TxInitRBFReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, ", {}: {}", "fee_rate", self.fee_rate())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TxInitRBFReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn fee_rate(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Uint64Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Uint64Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TxInitRBFReader<'r> {
    type Entity = TxInitRBF;
    const NAME: &'static str = "TxInitRBFReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TxInitRBFReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint64Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TxInitRBFBuilder {
    pub(crate) channel_id: Byte32,
    pub(crate) fee_rate: Uint64,
}
impl TxInitRBFBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn channel_id(mut self, v: Byte32) -> Self {
        self.channel_id = v;
        self
    }
    pub fn fee_rate(mut self, v: Uint64) -> Self {
        self.fee_rate = v;
        self
    }
}
impl molecule::prelude::Builder for TxInitRBFBuilder {
    type Entity = TxInitRBF;
    const NAME: &'static str = "TxInitRBFBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.channel_id.as_slice().len()
            + self.fee_rate.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.channel_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.fee_rate.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.channel_id.as_slice())?;
        writer.write_all(self.fee_rate.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TxInitRBF::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TxAckRBF(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TxAckRBF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TxAckRBF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TxAckRBF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TxAckRBF {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TxAckRBF::new_unchecked(v)
    }
}
impl TxAckRBF {
    const DEFAULT_VALUE: [u8; 40] = [
        40, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Byte32::new_unchecked(self.0.slice(start..end))
        } else {
            Byte32::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TxAckRBFReader<'r> {
        TxAckRBFReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TxAckRBF {
    type Builder = TxAckRBFBuilder;
    const NAME: &'static str = "TxAckRBF";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TxAckRBF(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TxAckRBFReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TxAckRBFReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().channel_id(self.channel_id())
    }
}
#[derive(Clone, Copy)]
pub struct TxAckRBFReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TxAckRBFReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TxAckRBFReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TxAckRBFReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TxAckRBFReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Byte32Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Byte32Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TxAckRBFReader<'r> {
    type Entity = TxAckRBF;
    const NAME: &'static str = "TxAckRBFReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TxAckRBFReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TxAckRBFBuilder {
    pub(crate) channel_id: Byte32,
}
impl TxAckRBFBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn channel_id(mut self, v: Byte32) -> Self {
        self.channel_id = v;
        self
    }
}
impl molecule::prelude::Builder for TxAckRBFBuilder {
    type Entity = TxAckRBF;
    const NAME: &'static str = "TxAckRBFBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.channel_id.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.channel_id.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.channel_id.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TxAckRBF::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Shutdown(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Shutdown {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Shutdown {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Shutdown {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, ", {}: {}", "fee_rate", self.fee_rate())?;
        write!(f, ", {}: {}", "close_script", self.close_script())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Shutdown {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Shutdown::new_unchecked(v)
    }
}
impl Shutdown {
    const DEFAULT_VALUE: [u8; 109] = [
        109, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0,
        0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn fee_rate(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn close_script(&self) -> Script {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Script::new_unchecked(self.0.slice(start..end))
        } else {
            Script::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ShutdownReader<'r> {
        ShutdownReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Shutdown {
    type Builder = ShutdownBuilder;
    const NAME: &'static str = "Shutdown";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Shutdown(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ShutdownReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ShutdownReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .channel_id(self.channel_id())
            .fee_rate(self.fee_rate())
            .close_script(self.close_script())
    }
}
#[derive(Clone, Copy)]
pub struct ShutdownReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ShutdownReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ShutdownReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ShutdownReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, ", {}: {}", "fee_rate", self.fee_rate())?;
        write!(f, ", {}: {}", "close_script", self.close_script())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ShutdownReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn fee_rate(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn close_script(&self) -> ScriptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            ScriptReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            ScriptReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ShutdownReader<'r> {
    type Entity = Shutdown;
    const NAME: &'static str = "ShutdownReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ShutdownReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint64Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        ScriptReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct ShutdownBuilder {
    pub(crate) channel_id: Byte32,
    pub(crate) fee_rate: Uint64,
    pub(crate) close_script: Script,
}
impl ShutdownBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn channel_id(mut self, v: Byte32) -> Self {
        self.channel_id = v;
        self
    }
    pub fn fee_rate(mut self, v: Uint64) -> Self {
        self.fee_rate = v;
        self
    }
    pub fn close_script(mut self, v: Script) -> Self {
        self.close_script = v;
        self
    }
}
impl molecule::prelude::Builder for ShutdownBuilder {
    type Entity = Shutdown;
    const NAME: &'static str = "ShutdownBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.channel_id.as_slice().len()
            + self.fee_rate.as_slice().len()
            + self.close_script.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.channel_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.fee_rate.as_slice().len();
        offsets.push(total_size);
        total_size += self.close_script.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.channel_id.as_slice())?;
        writer.write_all(self.fee_rate.as_slice())?;
        writer.write_all(self.close_script.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Shutdown::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ClosingSigned(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ClosingSigned {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ClosingSigned {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ClosingSigned {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, ", {}: {}", "partial_signature", self.partial_signature())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for ClosingSigned {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        ClosingSigned::new_unchecked(v)
    }
}
impl ClosingSigned {
    const DEFAULT_VALUE: [u8; 64] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0,
    ];
    pub const TOTAL_SIZE: usize = 64;
    pub const FIELD_SIZES: [usize; 2] = [32, 32];
    pub const FIELD_COUNT: usize = 2;
    pub fn channel_id(&self) -> Byte32 {
        Byte32::new_unchecked(self.0.slice(0..32))
    }
    pub fn partial_signature(&self) -> Byte32 {
        Byte32::new_unchecked(self.0.slice(32..64))
    }
    pub fn as_reader<'r>(&'r self) -> ClosingSignedReader<'r> {
        ClosingSignedReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ClosingSigned {
    type Builder = ClosingSignedBuilder;
    const NAME: &'static str = "ClosingSigned";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ClosingSigned(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ClosingSignedReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ClosingSignedReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .channel_id(self.channel_id())
            .partial_signature(self.partial_signature())
    }
}
#[derive(Clone, Copy)]
pub struct ClosingSignedReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ClosingSignedReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ClosingSignedReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ClosingSignedReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, ", {}: {}", "partial_signature", self.partial_signature())?;
        write!(f, " }}")
    }
}
impl<'r> ClosingSignedReader<'r> {
    pub const TOTAL_SIZE: usize = 64;
    pub const FIELD_SIZES: [usize; 2] = [32, 32];
    pub const FIELD_COUNT: usize = 2;
    pub fn channel_id(&self) -> Byte32Reader<'r> {
        Byte32Reader::new_unchecked(&self.as_slice()[0..32])
    }
    pub fn partial_signature(&self) -> Byte32Reader<'r> {
        Byte32Reader::new_unchecked(&self.as_slice()[32..64])
    }
}
impl<'r> molecule::prelude::Reader<'r> for ClosingSignedReader<'r> {
    type Entity = ClosingSigned;
    const NAME: &'static str = "ClosingSignedReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ClosingSignedReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct ClosingSignedBuilder {
    pub(crate) channel_id: Byte32,
    pub(crate) partial_signature: Byte32,
}
impl ClosingSignedBuilder {
    pub const TOTAL_SIZE: usize = 64;
    pub const FIELD_SIZES: [usize; 2] = [32, 32];
    pub const FIELD_COUNT: usize = 2;
    pub fn channel_id(mut self, v: Byte32) -> Self {
        self.channel_id = v;
        self
    }
    pub fn partial_signature(mut self, v: Byte32) -> Self {
        self.partial_signature = v;
        self
    }
}
impl molecule::prelude::Builder for ClosingSignedBuilder {
    type Entity = ClosingSigned;
    const NAME: &'static str = "ClosingSignedBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.channel_id.as_slice())?;
        writer.write_all(self.partial_signature.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ClosingSigned::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct UpdateTlcInfo(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for UpdateTlcInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for UpdateTlcInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for UpdateTlcInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, ", {}: {}", "timestamp", self.timestamp())?;
        write!(f, ", {}: {}", "channel_flags", self.channel_flags())?;
        write!(f, ", {}: {}", "tlc_expiry_delta", self.tlc_expiry_delta())?;
        write!(f, ", {}: {}", "tlc_minimum_value", self.tlc_minimum_value())?;
        write!(f, ", {}: {}", "tlc_maximum_value", self.tlc_maximum_value())?;
        write!(
            f,
            ", {}: {}",
            "tlc_fee_proportional_millionths",
            self.tlc_fee_proportional_millionths()
        )?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for UpdateTlcInfo {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        UpdateTlcInfo::new_unchecked(v)
    }
}
impl UpdateTlcInfo {
    const DEFAULT_VALUE: [u8; 100] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const TOTAL_SIZE: usize = 100;
    pub const FIELD_SIZES: [usize; 7] = [32, 8, 4, 8, 16, 16, 16];
    pub const FIELD_COUNT: usize = 7;
    pub fn channel_id(&self) -> Byte32 {
        Byte32::new_unchecked(self.0.slice(0..32))
    }
    pub fn timestamp(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(32..40))
    }
    pub fn channel_flags(&self) -> Uint32 {
        Uint32::new_unchecked(self.0.slice(40..44))
    }
    pub fn tlc_expiry_delta(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(44..52))
    }
    pub fn tlc_minimum_value(&self) -> Uint128 {
        Uint128::new_unchecked(self.0.slice(52..68))
    }
    pub fn tlc_maximum_value(&self) -> Uint128 {
        Uint128::new_unchecked(self.0.slice(68..84))
    }
    pub fn tlc_fee_proportional_millionths(&self) -> Uint128 {
        Uint128::new_unchecked(self.0.slice(84..100))
    }
    pub fn as_reader<'r>(&'r self) -> UpdateTlcInfoReader<'r> {
        UpdateTlcInfoReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for UpdateTlcInfo {
    type Builder = UpdateTlcInfoBuilder;
    const NAME: &'static str = "UpdateTlcInfo";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        UpdateTlcInfo(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UpdateTlcInfoReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UpdateTlcInfoReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .channel_id(self.channel_id())
            .timestamp(self.timestamp())
            .channel_flags(self.channel_flags())
            .tlc_expiry_delta(self.tlc_expiry_delta())
            .tlc_minimum_value(self.tlc_minimum_value())
            .tlc_maximum_value(self.tlc_maximum_value())
            .tlc_fee_proportional_millionths(self.tlc_fee_proportional_millionths())
    }
}
#[derive(Clone, Copy)]
pub struct UpdateTlcInfoReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for UpdateTlcInfoReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for UpdateTlcInfoReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for UpdateTlcInfoReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, ", {}: {}", "timestamp", self.timestamp())?;
        write!(f, ", {}: {}", "channel_flags", self.channel_flags())?;
        write!(f, ", {}: {}", "tlc_expiry_delta", self.tlc_expiry_delta())?;
        write!(f, ", {}: {}", "tlc_minimum_value", self.tlc_minimum_value())?;
        write!(f, ", {}: {}", "tlc_maximum_value", self.tlc_maximum_value())?;
        write!(
            f,
            ", {}: {}",
            "tlc_fee_proportional_millionths",
            self.tlc_fee_proportional_millionths()
        )?;
        write!(f, " }}")
    }
}
impl<'r> UpdateTlcInfoReader<'r> {
    pub const TOTAL_SIZE: usize = 100;
    pub const FIELD_SIZES: [usize; 7] = [32, 8, 4, 8, 16, 16, 16];
    pub const FIELD_COUNT: usize = 7;
    pub fn channel_id(&self) -> Byte32Reader<'r> {
        Byte32Reader::new_unchecked(&self.as_slice()[0..32])
    }
    pub fn timestamp(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[32..40])
    }
    pub fn channel_flags(&self) -> Uint32Reader<'r> {
        Uint32Reader::new_unchecked(&self.as_slice()[40..44])
    }
    pub fn tlc_expiry_delta(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[44..52])
    }
    pub fn tlc_minimum_value(&self) -> Uint128Reader<'r> {
        Uint128Reader::new_unchecked(&self.as_slice()[52..68])
    }
    pub fn tlc_maximum_value(&self) -> Uint128Reader<'r> {
        Uint128Reader::new_unchecked(&self.as_slice()[68..84])
    }
    pub fn tlc_fee_proportional_millionths(&self) -> Uint128Reader<'r> {
        Uint128Reader::new_unchecked(&self.as_slice()[84..100])
    }
}
impl<'r> molecule::prelude::Reader<'r> for UpdateTlcInfoReader<'r> {
    type Entity = UpdateTlcInfo;
    const NAME: &'static str = "UpdateTlcInfoReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        UpdateTlcInfoReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct UpdateTlcInfoBuilder {
    pub(crate) channel_id: Byte32,
    pub(crate) timestamp: Uint64,
    pub(crate) channel_flags: Uint32,
    pub(crate) tlc_expiry_delta: Uint64,
    pub(crate) tlc_minimum_value: Uint128,
    pub(crate) tlc_maximum_value: Uint128,
    pub(crate) tlc_fee_proportional_millionths: Uint128,
}
impl UpdateTlcInfoBuilder {
    pub const TOTAL_SIZE: usize = 100;
    pub const FIELD_SIZES: [usize; 7] = [32, 8, 4, 8, 16, 16, 16];
    pub const FIELD_COUNT: usize = 7;
    pub fn channel_id(mut self, v: Byte32) -> Self {
        self.channel_id = v;
        self
    }
    pub fn timestamp(mut self, v: Uint64) -> Self {
        self.timestamp = v;
        self
    }
    pub fn channel_flags(mut self, v: Uint32) -> Self {
        self.channel_flags = v;
        self
    }
    pub fn tlc_expiry_delta(mut self, v: Uint64) -> Self {
        self.tlc_expiry_delta = v;
        self
    }
    pub fn tlc_minimum_value(mut self, v: Uint128) -> Self {
        self.tlc_minimum_value = v;
        self
    }
    pub fn tlc_maximum_value(mut self, v: Uint128) -> Self {
        self.tlc_maximum_value = v;
        self
    }
    pub fn tlc_fee_proportional_millionths(mut self, v: Uint128) -> Self {
        self.tlc_fee_proportional_millionths = v;
        self
    }
}
impl molecule::prelude::Builder for UpdateTlcInfoBuilder {
    type Entity = UpdateTlcInfo;
    const NAME: &'static str = "UpdateTlcInfoBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.channel_id.as_slice())?;
        writer.write_all(self.timestamp.as_slice())?;
        writer.write_all(self.channel_flags.as_slice())?;
        writer.write_all(self.tlc_expiry_delta.as_slice())?;
        writer.write_all(self.tlc_minimum_value.as_slice())?;
        writer.write_all(self.tlc_maximum_value.as_slice())?;
        writer.write_all(self.tlc_fee_proportional_millionths.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        UpdateTlcInfo::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct AddTlc(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for AddTlc {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for AddTlc {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for AddTlc {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, ", {}: {}", "tlc_id", self.tlc_id())?;
        write!(f, ", {}: {}", "amount", self.amount())?;
        write!(f, ", {}: {}", "payment_hash", self.payment_hash())?;
        write!(f, ", {}: {}", "expiry", self.expiry())?;
        write!(f, ", {}: {}", "hash_algorithm", self.hash_algorithm())?;
        write!(f, ", {}: {}", "onion_packet", self.onion_packet())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for AddTlc {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        AddTlc::new_unchecked(v)
    }
}
impl AddTlc {
    const DEFAULT_VALUE: [u8; 133] = [
        133, 0, 0, 0, 32, 0, 0, 0, 64, 0, 0, 0, 72, 0, 0, 0, 88, 0, 0, 0, 120, 0, 0, 0, 128, 0, 0,
        0, 129, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 7;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn tlc_id(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn amount(&self) -> Uint128 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint128::new_unchecked(self.0.slice(start..end))
    }
    pub fn payment_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn expiry(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn hash_algorithm(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn onion_packet(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[32..]) as usize;
            Bytes::new_unchecked(self.0.slice(start..end))
        } else {
            Bytes::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> AddTlcReader<'r> {
        AddTlcReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for AddTlc {
    type Builder = AddTlcBuilder;
    const NAME: &'static str = "AddTlc";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        AddTlc(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AddTlcReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AddTlcReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .channel_id(self.channel_id())
            .tlc_id(self.tlc_id())
            .amount(self.amount())
            .payment_hash(self.payment_hash())
            .expiry(self.expiry())
            .hash_algorithm(self.hash_algorithm())
            .onion_packet(self.onion_packet())
    }
}
#[derive(Clone, Copy)]
pub struct AddTlcReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for AddTlcReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for AddTlcReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for AddTlcReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, ", {}: {}", "tlc_id", self.tlc_id())?;
        write!(f, ", {}: {}", "amount", self.amount())?;
        write!(f, ", {}: {}", "payment_hash", self.payment_hash())?;
        write!(f, ", {}: {}", "expiry", self.expiry())?;
        write!(f, ", {}: {}", "hash_algorithm", self.hash_algorithm())?;
        write!(f, ", {}: {}", "onion_packet", self.onion_packet())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> AddTlcReader<'r> {
    pub const FIELD_COUNT: usize = 7;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn tlc_id(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn amount(&self) -> Uint128Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint128Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn payment_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn expiry(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn hash_algorithm(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn onion_packet(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[32..]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for AddTlcReader<'r> {
    type Entity = AddTlc;
    const NAME: &'static str = "AddTlcReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        AddTlcReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint64Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Uint128Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Byte32Reader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Uint64Reader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        ByteReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        BytesReader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct AddTlcBuilder {
    pub(crate) channel_id: Byte32,
    pub(crate) tlc_id: Uint64,
    pub(crate) amount: Uint128,
    pub(crate) payment_hash: Byte32,
    pub(crate) expiry: Uint64,
    pub(crate) hash_algorithm: Byte,
    pub(crate) onion_packet: Bytes,
}
impl AddTlcBuilder {
    pub const FIELD_COUNT: usize = 7;
    pub fn channel_id(mut self, v: Byte32) -> Self {
        self.channel_id = v;
        self
    }
    pub fn tlc_id(mut self, v: Uint64) -> Self {
        self.tlc_id = v;
        self
    }
    pub fn amount(mut self, v: Uint128) -> Self {
        self.amount = v;
        self
    }
    pub fn payment_hash(mut self, v: Byte32) -> Self {
        self.payment_hash = v;
        self
    }
    pub fn expiry(mut self, v: Uint64) -> Self {
        self.expiry = v;
        self
    }
    pub fn hash_algorithm(mut self, v: Byte) -> Self {
        self.hash_algorithm = v;
        self
    }
    pub fn onion_packet(mut self, v: Bytes) -> Self {
        self.onion_packet = v;
        self
    }
}
impl molecule::prelude::Builder for AddTlcBuilder {
    type Entity = AddTlc;
    const NAME: &'static str = "AddTlcBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.channel_id.as_slice().len()
            + self.tlc_id.as_slice().len()
            + self.amount.as_slice().len()
            + self.payment_hash.as_slice().len()
            + self.expiry.as_slice().len()
            + self.hash_algorithm.as_slice().len()
            + self.onion_packet.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.channel_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.tlc_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.amount.as_slice().len();
        offsets.push(total_size);
        total_size += self.payment_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.expiry.as_slice().len();
        offsets.push(total_size);
        total_size += self.hash_algorithm.as_slice().len();
        offsets.push(total_size);
        total_size += self.onion_packet.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.channel_id.as_slice())?;
        writer.write_all(self.tlc_id.as_slice())?;
        writer.write_all(self.amount.as_slice())?;
        writer.write_all(self.payment_hash.as_slice())?;
        writer.write_all(self.expiry.as_slice())?;
        writer.write_all(self.hash_algorithm.as_slice())?;
        writer.write_all(self.onion_packet.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        AddTlc::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct RevokeAndAck(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for RevokeAndAck {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for RevokeAndAck {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for RevokeAndAck {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(
            f,
            ", {}: {}",
            "revocation_partial_signature",
            self.revocation_partial_signature()
        )?;
        write!(
            f,
            ", {}: {}",
            "commitment_tx_partial_signature",
            self.commitment_tx_partial_signature()
        )?;
        write!(
            f,
            ", {}: {}",
            "next_per_commitment_point",
            self.next_per_commitment_point()
        )?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for RevokeAndAck {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        RevokeAndAck::new_unchecked(v)
    }
}
impl RevokeAndAck {
    const DEFAULT_VALUE: [u8; 129] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const TOTAL_SIZE: usize = 129;
    pub const FIELD_SIZES: [usize; 4] = [32, 32, 32, 33];
    pub const FIELD_COUNT: usize = 4;
    pub fn channel_id(&self) -> Byte32 {
        Byte32::new_unchecked(self.0.slice(0..32))
    }
    pub fn revocation_partial_signature(&self) -> Byte32 {
        Byte32::new_unchecked(self.0.slice(32..64))
    }
    pub fn commitment_tx_partial_signature(&self) -> Byte32 {
        Byte32::new_unchecked(self.0.slice(64..96))
    }
    pub fn next_per_commitment_point(&self) -> Pubkey {
        Pubkey::new_unchecked(self.0.slice(96..129))
    }
    pub fn as_reader<'r>(&'r self) -> RevokeAndAckReader<'r> {
        RevokeAndAckReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for RevokeAndAck {
    type Builder = RevokeAndAckBuilder;
    const NAME: &'static str = "RevokeAndAck";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        RevokeAndAck(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RevokeAndAckReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RevokeAndAckReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .channel_id(self.channel_id())
            .revocation_partial_signature(self.revocation_partial_signature())
            .commitment_tx_partial_signature(self.commitment_tx_partial_signature())
            .next_per_commitment_point(self.next_per_commitment_point())
    }
}
#[derive(Clone, Copy)]
pub struct RevokeAndAckReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for RevokeAndAckReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for RevokeAndAckReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for RevokeAndAckReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(
            f,
            ", {}: {}",
            "revocation_partial_signature",
            self.revocation_partial_signature()
        )?;
        write!(
            f,
            ", {}: {}",
            "commitment_tx_partial_signature",
            self.commitment_tx_partial_signature()
        )?;
        write!(
            f,
            ", {}: {}",
            "next_per_commitment_point",
            self.next_per_commitment_point()
        )?;
        write!(f, " }}")
    }
}
impl<'r> RevokeAndAckReader<'r> {
    pub const TOTAL_SIZE: usize = 129;
    pub const FIELD_SIZES: [usize; 4] = [32, 32, 32, 33];
    pub const FIELD_COUNT: usize = 4;
    pub fn channel_id(&self) -> Byte32Reader<'r> {
        Byte32Reader::new_unchecked(&self.as_slice()[0..32])
    }
    pub fn revocation_partial_signature(&self) -> Byte32Reader<'r> {
        Byte32Reader::new_unchecked(&self.as_slice()[32..64])
    }
    pub fn commitment_tx_partial_signature(&self) -> Byte32Reader<'r> {
        Byte32Reader::new_unchecked(&self.as_slice()[64..96])
    }
    pub fn next_per_commitment_point(&self) -> PubkeyReader<'r> {
        PubkeyReader::new_unchecked(&self.as_slice()[96..129])
    }
}
impl<'r> molecule::prelude::Reader<'r> for RevokeAndAckReader<'r> {
    type Entity = RevokeAndAck;
    const NAME: &'static str = "RevokeAndAckReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        RevokeAndAckReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct RevokeAndAckBuilder {
    pub(crate) channel_id: Byte32,
    pub(crate) revocation_partial_signature: Byte32,
    pub(crate) commitment_tx_partial_signature: Byte32,
    pub(crate) next_per_commitment_point: Pubkey,
}
impl RevokeAndAckBuilder {
    pub const TOTAL_SIZE: usize = 129;
    pub const FIELD_SIZES: [usize; 4] = [32, 32, 32, 33];
    pub const FIELD_COUNT: usize = 4;
    pub fn channel_id(mut self, v: Byte32) -> Self {
        self.channel_id = v;
        self
    }
    pub fn revocation_partial_signature(mut self, v: Byte32) -> Self {
        self.revocation_partial_signature = v;
        self
    }
    pub fn commitment_tx_partial_signature(mut self, v: Byte32) -> Self {
        self.commitment_tx_partial_signature = v;
        self
    }
    pub fn next_per_commitment_point(mut self, v: Pubkey) -> Self {
        self.next_per_commitment_point = v;
        self
    }
}
impl molecule::prelude::Builder for RevokeAndAckBuilder {
    type Entity = RevokeAndAck;
    const NAME: &'static str = "RevokeAndAckBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.channel_id.as_slice())?;
        writer.write_all(self.revocation_partial_signature.as_slice())?;
        writer.write_all(self.commitment_tx_partial_signature.as_slice())?;
        writer.write_all(self.next_per_commitment_point.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        RevokeAndAck::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct RemoveTlcFulfill(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for RemoveTlcFulfill {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for RemoveTlcFulfill {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for RemoveTlcFulfill {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "payment_preimage", self.payment_preimage())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for RemoveTlcFulfill {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        RemoveTlcFulfill::new_unchecked(v)
    }
}
impl RemoveTlcFulfill {
    const DEFAULT_VALUE: [u8; 32] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0,
    ];
    pub const TOTAL_SIZE: usize = 32;
    pub const FIELD_SIZES: [usize; 1] = [32];
    pub const FIELD_COUNT: usize = 1;
    pub fn payment_preimage(&self) -> Byte32 {
        Byte32::new_unchecked(self.0.slice(0..32))
    }
    pub fn as_reader<'r>(&'r self) -> RemoveTlcFulfillReader<'r> {
        RemoveTlcFulfillReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for RemoveTlcFulfill {
    type Builder = RemoveTlcFulfillBuilder;
    const NAME: &'static str = "RemoveTlcFulfill";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        RemoveTlcFulfill(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RemoveTlcFulfillReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RemoveTlcFulfillReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().payment_preimage(self.payment_preimage())
    }
}
#[derive(Clone, Copy)]
pub struct RemoveTlcFulfillReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for RemoveTlcFulfillReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for RemoveTlcFulfillReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for RemoveTlcFulfillReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "payment_preimage", self.payment_preimage())?;
        write!(f, " }}")
    }
}
impl<'r> RemoveTlcFulfillReader<'r> {
    pub const TOTAL_SIZE: usize = 32;
    pub const FIELD_SIZES: [usize; 1] = [32];
    pub const FIELD_COUNT: usize = 1;
    pub fn payment_preimage(&self) -> Byte32Reader<'r> {
        Byte32Reader::new_unchecked(&self.as_slice()[0..32])
    }
}
impl<'r> molecule::prelude::Reader<'r> for RemoveTlcFulfillReader<'r> {
    type Entity = RemoveTlcFulfill;
    const NAME: &'static str = "RemoveTlcFulfillReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        RemoveTlcFulfillReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct RemoveTlcFulfillBuilder {
    pub(crate) payment_preimage: Byte32,
}
impl RemoveTlcFulfillBuilder {
    pub const TOTAL_SIZE: usize = 32;
    pub const FIELD_SIZES: [usize; 1] = [32];
    pub const FIELD_COUNT: usize = 1;
    pub fn payment_preimage(mut self, v: Byte32) -> Self {
        self.payment_preimage = v;
        self
    }
}
impl molecule::prelude::Builder for RemoveTlcFulfillBuilder {
    type Entity = RemoveTlcFulfill;
    const NAME: &'static str = "RemoveTlcFulfillBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.payment_preimage.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        RemoveTlcFulfill::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TlcErrPacket(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TlcErrPacket {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TlcErrPacket {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TlcErrPacket {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "onion_packet", self.onion_packet())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TlcErrPacket {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TlcErrPacket::new_unchecked(v)
    }
}
impl TlcErrPacket {
    const DEFAULT_VALUE: [u8; 12] = [12, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0];
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn onion_packet(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Bytes::new_unchecked(self.0.slice(start..end))
        } else {
            Bytes::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TlcErrPacketReader<'r> {
        TlcErrPacketReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TlcErrPacket {
    type Builder = TlcErrPacketBuilder;
    const NAME: &'static str = "TlcErrPacket";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TlcErrPacket(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TlcErrPacketReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TlcErrPacketReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().onion_packet(self.onion_packet())
    }
}
#[derive(Clone, Copy)]
pub struct TlcErrPacketReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TlcErrPacketReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TlcErrPacketReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TlcErrPacketReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "onion_packet", self.onion_packet())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TlcErrPacketReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn onion_packet(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TlcErrPacketReader<'r> {
    type Entity = TlcErrPacket;
    const NAME: &'static str = "TlcErrPacketReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TlcErrPacketReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        BytesReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TlcErrPacketBuilder {
    pub(crate) onion_packet: Bytes,
}
impl TlcErrPacketBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn onion_packet(mut self, v: Bytes) -> Self {
        self.onion_packet = v;
        self
    }
}
impl molecule::prelude::Builder for TlcErrPacketBuilder {
    type Entity = TlcErrPacket;
    const NAME: &'static str = "TlcErrPacketBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.onion_packet.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.onion_packet.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.onion_packet.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TlcErrPacket::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct RemoveTlcReason(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for RemoveTlcReason {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for RemoveTlcReason {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for RemoveTlcReason {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for RemoveTlcReason {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        RemoveTlcReason::new_unchecked(v)
    }
}
impl RemoveTlcReason {
    const DEFAULT_VALUE: [u8; 36] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0,
    ];
    pub const ITEMS_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> RemoveTlcReasonUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => RemoveTlcFulfill::new_unchecked(inner).into(),
            1 => TlcErrPacket::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> RemoveTlcReasonReader<'r> {
        RemoveTlcReasonReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for RemoveTlcReason {
    type Builder = RemoveTlcReasonBuilder;
    const NAME: &'static str = "RemoveTlcReason";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        RemoveTlcReason(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RemoveTlcReasonReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RemoveTlcReasonReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct RemoveTlcReasonReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for RemoveTlcReasonReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for RemoveTlcReasonReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for RemoveTlcReasonReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> RemoveTlcReasonReader<'r> {
    pub const ITEMS_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> RemoveTlcReasonUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => RemoveTlcFulfillReader::new_unchecked(inner).into(),
            1 => TlcErrPacketReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for RemoveTlcReasonReader<'r> {
    type Entity = RemoveTlcReason;
    const NAME: &'static str = "RemoveTlcReasonReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        RemoveTlcReasonReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => RemoveTlcFulfillReader::verify(inner_slice, compatible),
            1 => TlcErrPacketReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct RemoveTlcReasonBuilder(pub(crate) RemoveTlcReasonUnion);
impl RemoveTlcReasonBuilder {
    pub const ITEMS_COUNT: usize = 2;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<RemoveTlcReasonUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for RemoveTlcReasonBuilder {
    type Entity = RemoveTlcReason;
    const NAME: &'static str = "RemoveTlcReasonBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        RemoveTlcReason::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum RemoveTlcReasonUnion {
    RemoveTlcFulfill(RemoveTlcFulfill),
    TlcErrPacket(TlcErrPacket),
}
#[derive(Debug, Clone, Copy)]
pub enum RemoveTlcReasonUnionReader<'r> {
    RemoveTlcFulfill(RemoveTlcFulfillReader<'r>),
    TlcErrPacket(TlcErrPacketReader<'r>),
}
impl ::core::default::Default for RemoveTlcReasonUnion {
    fn default() -> Self {
        RemoveTlcReasonUnion::RemoveTlcFulfill(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for RemoveTlcReasonUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            RemoveTlcReasonUnion::RemoveTlcFulfill(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, RemoveTlcFulfill::NAME, item)
            }
            RemoveTlcReasonUnion::TlcErrPacket(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TlcErrPacket::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for RemoveTlcReasonUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            RemoveTlcReasonUnionReader::RemoveTlcFulfill(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, RemoveTlcFulfill::NAME, item)
            }
            RemoveTlcReasonUnionReader::TlcErrPacket(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TlcErrPacket::NAME, item)
            }
        }
    }
}
impl RemoveTlcReasonUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            RemoveTlcReasonUnion::RemoveTlcFulfill(ref item) => write!(f, "{}", item),
            RemoveTlcReasonUnion::TlcErrPacket(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> RemoveTlcReasonUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            RemoveTlcReasonUnionReader::RemoveTlcFulfill(ref item) => write!(f, "{}", item),
            RemoveTlcReasonUnionReader::TlcErrPacket(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<RemoveTlcFulfill> for RemoveTlcReasonUnion {
    fn from(item: RemoveTlcFulfill) -> Self {
        RemoveTlcReasonUnion::RemoveTlcFulfill(item)
    }
}
impl ::core::convert::From<TlcErrPacket> for RemoveTlcReasonUnion {
    fn from(item: TlcErrPacket) -> Self {
        RemoveTlcReasonUnion::TlcErrPacket(item)
    }
}
impl<'r> ::core::convert::From<RemoveTlcFulfillReader<'r>> for RemoveTlcReasonUnionReader<'r> {
    fn from(item: RemoveTlcFulfillReader<'r>) -> Self {
        RemoveTlcReasonUnionReader::RemoveTlcFulfill(item)
    }
}
impl<'r> ::core::convert::From<TlcErrPacketReader<'r>> for RemoveTlcReasonUnionReader<'r> {
    fn from(item: TlcErrPacketReader<'r>) -> Self {
        RemoveTlcReasonUnionReader::TlcErrPacket(item)
    }
}
impl RemoveTlcReasonUnion {
    pub const NAME: &'static str = "RemoveTlcReasonUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            RemoveTlcReasonUnion::RemoveTlcFulfill(item) => item.as_bytes(),
            RemoveTlcReasonUnion::TlcErrPacket(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            RemoveTlcReasonUnion::RemoveTlcFulfill(item) => item.as_slice(),
            RemoveTlcReasonUnion::TlcErrPacket(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            RemoveTlcReasonUnion::RemoveTlcFulfill(_) => 0,
            RemoveTlcReasonUnion::TlcErrPacket(_) => 1,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            RemoveTlcReasonUnion::RemoveTlcFulfill(_) => "RemoveTlcFulfill",
            RemoveTlcReasonUnion::TlcErrPacket(_) => "TlcErrPacket",
        }
    }
    pub fn as_reader<'r>(&'r self) -> RemoveTlcReasonUnionReader<'r> {
        match self {
            RemoveTlcReasonUnion::RemoveTlcFulfill(item) => item.as_reader().into(),
            RemoveTlcReasonUnion::TlcErrPacket(item) => item.as_reader().into(),
        }
    }
}
impl<'r> RemoveTlcReasonUnionReader<'r> {
    pub const NAME: &'r str = "RemoveTlcReasonUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            RemoveTlcReasonUnionReader::RemoveTlcFulfill(item) => item.as_slice(),
            RemoveTlcReasonUnionReader::TlcErrPacket(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            RemoveTlcReasonUnionReader::RemoveTlcFulfill(_) => 0,
            RemoveTlcReasonUnionReader::TlcErrPacket(_) => 1,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            RemoveTlcReasonUnionReader::RemoveTlcFulfill(_) => "RemoveTlcFulfill",
            RemoveTlcReasonUnionReader::TlcErrPacket(_) => "TlcErrPacket",
        }
    }
}
impl From<RemoveTlcFulfill> for RemoveTlcReason {
    fn from(value: RemoveTlcFulfill) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<TlcErrPacket> for RemoveTlcReason {
    fn from(value: TlcErrPacket) -> Self {
        Self::new_builder().set(value).build()
    }
}
#[derive(Clone)]
pub struct RemoveTlc(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for RemoveTlc {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for RemoveTlc {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for RemoveTlc {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, ", {}: {}", "tlc_id", self.tlc_id())?;
        write!(f, ", {}: {}", "reason", self.reason())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for RemoveTlc {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        RemoveTlc::new_unchecked(v)
    }
}
impl RemoveTlc {
    const DEFAULT_VALUE: [u8; 92] = [
        92, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn tlc_id(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn reason(&self) -> RemoveTlcReason {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            RemoveTlcReason::new_unchecked(self.0.slice(start..end))
        } else {
            RemoveTlcReason::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> RemoveTlcReader<'r> {
        RemoveTlcReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for RemoveTlc {
    type Builder = RemoveTlcBuilder;
    const NAME: &'static str = "RemoveTlc";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        RemoveTlc(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RemoveTlcReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RemoveTlcReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .channel_id(self.channel_id())
            .tlc_id(self.tlc_id())
            .reason(self.reason())
    }
}
#[derive(Clone, Copy)]
pub struct RemoveTlcReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for RemoveTlcReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for RemoveTlcReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for RemoveTlcReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, ", {}: {}", "tlc_id", self.tlc_id())?;
        write!(f, ", {}: {}", "reason", self.reason())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> RemoveTlcReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn tlc_id(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn reason(&self) -> RemoveTlcReasonReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            RemoveTlcReasonReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            RemoveTlcReasonReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for RemoveTlcReader<'r> {
    type Entity = RemoveTlc;
    const NAME: &'static str = "RemoveTlcReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        RemoveTlcReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint64Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        RemoveTlcReasonReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct RemoveTlcBuilder {
    pub(crate) channel_id: Byte32,
    pub(crate) tlc_id: Uint64,
    pub(crate) reason: RemoveTlcReason,
}
impl RemoveTlcBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn channel_id(mut self, v: Byte32) -> Self {
        self.channel_id = v;
        self
    }
    pub fn tlc_id(mut self, v: Uint64) -> Self {
        self.tlc_id = v;
        self
    }
    pub fn reason(mut self, v: RemoveTlcReason) -> Self {
        self.reason = v;
        self
    }
}
impl molecule::prelude::Builder for RemoveTlcBuilder {
    type Entity = RemoveTlc;
    const NAME: &'static str = "RemoveTlcBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.channel_id.as_slice().len()
            + self.tlc_id.as_slice().len()
            + self.reason.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.channel_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.tlc_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.reason.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.channel_id.as_slice())?;
        writer.write_all(self.tlc_id.as_slice())?;
        writer.write_all(self.reason.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        RemoveTlc::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ReestablishChannel(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ReestablishChannel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ReestablishChannel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ReestablishChannel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(
            f,
            ", {}: {}",
            "local_commitment_number",
            self.local_commitment_number()
        )?;
        write!(
            f,
            ", {}: {}",
            "remote_commitment_number",
            self.remote_commitment_number()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ReestablishChannel {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        ReestablishChannel::new_unchecked(v)
    }
}
impl ReestablishChannel {
    const DEFAULT_VALUE: [u8; 64] = [
        64, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn local_commitment_number(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn remote_commitment_number(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Uint64::new_unchecked(self.0.slice(start..end))
        } else {
            Uint64::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ReestablishChannelReader<'r> {
        ReestablishChannelReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ReestablishChannel {
    type Builder = ReestablishChannelBuilder;
    const NAME: &'static str = "ReestablishChannel";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ReestablishChannel(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ReestablishChannelReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ReestablishChannelReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .channel_id(self.channel_id())
            .local_commitment_number(self.local_commitment_number())
            .remote_commitment_number(self.remote_commitment_number())
    }
}
#[derive(Clone, Copy)]
pub struct ReestablishChannelReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ReestablishChannelReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ReestablishChannelReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ReestablishChannelReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(
            f,
            ", {}: {}",
            "local_commitment_number",
            self.local_commitment_number()
        )?;
        write!(
            f,
            ", {}: {}",
            "remote_commitment_number",
            self.remote_commitment_number()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ReestablishChannelReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn local_commitment_number(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn remote_commitment_number(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Uint64Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Uint64Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ReestablishChannelReader<'r> {
    type Entity = ReestablishChannel;
    const NAME: &'static str = "ReestablishChannelReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ReestablishChannelReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint64Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Uint64Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct ReestablishChannelBuilder {
    pub(crate) channel_id: Byte32,
    pub(crate) local_commitment_number: Uint64,
    pub(crate) remote_commitment_number: Uint64,
}
impl ReestablishChannelBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn channel_id(mut self, v: Byte32) -> Self {
        self.channel_id = v;
        self
    }
    pub fn local_commitment_number(mut self, v: Uint64) -> Self {
        self.local_commitment_number = v;
        self
    }
    pub fn remote_commitment_number(mut self, v: Uint64) -> Self {
        self.remote_commitment_number = v;
        self
    }
}
impl molecule::prelude::Builder for ReestablishChannelBuilder {
    type Entity = ReestablishChannel;
    const NAME: &'static str = "ReestablishChannelBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.channel_id.as_slice().len()
            + self.local_commitment_number.as_slice().len()
            + self.remote_commitment_number.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.channel_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.local_commitment_number.as_slice().len();
        offsets.push(total_size);
        total_size += self.remote_commitment_number.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.channel_id.as_slice())?;
        writer.write_all(self.local_commitment_number.as_slice())?;
        writer.write_all(self.remote_commitment_number.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ReestablishChannel::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct AnnouncementSignatures(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for AnnouncementSignatures {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for AnnouncementSignatures {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for AnnouncementSignatures {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, ", {}: {}", "channel_outpoint", self.channel_outpoint())?;
        write!(f, ", {}: {}", "node_signature", self.node_signature())?;
        write!(f, ", {}: {}", "partial_signature", self.partial_signature())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for AnnouncementSignatures {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        AnnouncementSignatures::new_unchecked(v)
    }
}
impl AnnouncementSignatures {
    const DEFAULT_VALUE: [u8; 184] = [
        184, 0, 0, 0, 20, 0, 0, 0, 52, 0, 0, 0, 88, 0, 0, 0, 152, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn channel_outpoint(&self) -> OutPoint {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        OutPoint::new_unchecked(self.0.slice(start..end))
    }
    pub fn node_signature(&self) -> EcdsaSignature {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        EcdsaSignature::new_unchecked(self.0.slice(start..end))
    }
    pub fn partial_signature(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            Byte32::new_unchecked(self.0.slice(start..end))
        } else {
            Byte32::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> AnnouncementSignaturesReader<'r> {
        AnnouncementSignaturesReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for AnnouncementSignatures {
    type Builder = AnnouncementSignaturesBuilder;
    const NAME: &'static str = "AnnouncementSignatures";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        AnnouncementSignatures(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AnnouncementSignaturesReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AnnouncementSignaturesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .channel_id(self.channel_id())
            .channel_outpoint(self.channel_outpoint())
            .node_signature(self.node_signature())
            .partial_signature(self.partial_signature())
    }
}
#[derive(Clone, Copy)]
pub struct AnnouncementSignaturesReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for AnnouncementSignaturesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for AnnouncementSignaturesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for AnnouncementSignaturesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, ", {}: {}", "channel_outpoint", self.channel_outpoint())?;
        write!(f, ", {}: {}", "node_signature", self.node_signature())?;
        write!(f, ", {}: {}", "partial_signature", self.partial_signature())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> AnnouncementSignaturesReader<'r> {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn channel_outpoint(&self) -> OutPointReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        OutPointReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn node_signature(&self) -> EcdsaSignatureReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        EcdsaSignatureReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn partial_signature(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            Byte32Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Byte32Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for AnnouncementSignaturesReader<'r> {
    type Entity = AnnouncementSignatures;
    const NAME: &'static str = "AnnouncementSignaturesReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        AnnouncementSignaturesReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        OutPointReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        EcdsaSignatureReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Byte32Reader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct AnnouncementSignaturesBuilder {
    pub(crate) channel_id: Byte32,
    pub(crate) channel_outpoint: OutPoint,
    pub(crate) node_signature: EcdsaSignature,
    pub(crate) partial_signature: Byte32,
}
impl AnnouncementSignaturesBuilder {
    pub const FIELD_COUNT: usize = 4;
    pub fn channel_id(mut self, v: Byte32) -> Self {
        self.channel_id = v;
        self
    }
    pub fn channel_outpoint(mut self, v: OutPoint) -> Self {
        self.channel_outpoint = v;
        self
    }
    pub fn node_signature(mut self, v: EcdsaSignature) -> Self {
        self.node_signature = v;
        self
    }
    pub fn partial_signature(mut self, v: Byte32) -> Self {
        self.partial_signature = v;
        self
    }
}
impl molecule::prelude::Builder for AnnouncementSignaturesBuilder {
    type Entity = AnnouncementSignatures;
    const NAME: &'static str = "AnnouncementSignaturesBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.channel_id.as_slice().len()
            + self.channel_outpoint.as_slice().len()
            + self.node_signature.as_slice().len()
            + self.partial_signature.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.channel_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.channel_outpoint.as_slice().len();
        offsets.push(total_size);
        total_size += self.node_signature.as_slice().len();
        offsets.push(total_size);
        total_size += self.partial_signature.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.channel_id.as_slice())?;
        writer.write_all(self.channel_outpoint.as_slice())?;
        writer.write_all(self.node_signature.as_slice())?;
        writer.write_all(self.partial_signature.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        AnnouncementSignatures::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct UdtCellDep(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for UdtCellDep {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for UdtCellDep {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for UdtCellDep {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "dep_type", self.dep_type())?;
        write!(f, ", {}: {}", "tx_hash", self.tx_hash())?;
        write!(f, ", {}: {}", "index", self.index())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for UdtCellDep {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        UdtCellDep::new_unchecked(v)
    }
}
impl UdtCellDep {
    const DEFAULT_VALUE: [u8; 53] = [
        53, 0, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn dep_type(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn tx_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn index(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Uint32::new_unchecked(self.0.slice(start..end))
        } else {
            Uint32::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> UdtCellDepReader<'r> {
        UdtCellDepReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for UdtCellDep {
    type Builder = UdtCellDepBuilder;
    const NAME: &'static str = "UdtCellDep";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        UdtCellDep(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UdtCellDepReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UdtCellDepReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .dep_type(self.dep_type())
            .tx_hash(self.tx_hash())
            .index(self.index())
    }
}
#[derive(Clone, Copy)]
pub struct UdtCellDepReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for UdtCellDepReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for UdtCellDepReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for UdtCellDepReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "dep_type", self.dep_type())?;
        write!(f, ", {}: {}", "tx_hash", self.tx_hash())?;
        write!(f, ", {}: {}", "index", self.index())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> UdtCellDepReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn dep_type(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn tx_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn index(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Uint32Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Uint32Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for UdtCellDepReader<'r> {
    type Entity = UdtCellDep;
    const NAME: &'static str = "UdtCellDepReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        UdtCellDepReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ByteReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Uint32Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct UdtCellDepBuilder {
    pub(crate) dep_type: Byte,
    pub(crate) tx_hash: Byte32,
    pub(crate) index: Uint32,
}
impl UdtCellDepBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn dep_type(mut self, v: Byte) -> Self {
        self.dep_type = v;
        self
    }
    pub fn tx_hash(mut self, v: Byte32) -> Self {
        self.tx_hash = v;
        self
    }
    pub fn index(mut self, v: Uint32) -> Self {
        self.index = v;
        self
    }
}
impl molecule::prelude::Builder for UdtCellDepBuilder {
    type Entity = UdtCellDep;
    const NAME: &'static str = "UdtCellDepBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.dep_type.as_slice().len()
            + self.tx_hash.as_slice().len()
            + self.index.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.dep_type.as_slice().len();
        offsets.push(total_size);
        total_size += self.tx_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.index.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.dep_type.as_slice())?;
        writer.write_all(self.tx_hash.as_slice())?;
        writer.write_all(self.index.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        UdtCellDep::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct UdtScript(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for UdtScript {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for UdtScript {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for UdtScript {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "code_hash", self.code_hash())?;
        write!(f, ", {}: {}", "hash_type", self.hash_type())?;
        write!(f, ", {}: {}", "args", self.args())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for UdtScript {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        UdtScript::new_unchecked(v)
    }
}
impl UdtScript {
    const DEFAULT_VALUE: [u8; 53] = [
        53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn code_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn hash_type(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn args(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Bytes::new_unchecked(self.0.slice(start..end))
        } else {
            Bytes::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> UdtScriptReader<'r> {
        UdtScriptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for UdtScript {
    type Builder = UdtScriptBuilder;
    const NAME: &'static str = "UdtScript";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        UdtScript(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UdtScriptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UdtScriptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .code_hash(self.code_hash())
            .hash_type(self.hash_type())
            .args(self.args())
    }
}
#[derive(Clone, Copy)]
pub struct UdtScriptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for UdtScriptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for UdtScriptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for UdtScriptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "code_hash", self.code_hash())?;
        write!(f, ", {}: {}", "hash_type", self.hash_type())?;
        write!(f, ", {}: {}", "args", self.args())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> UdtScriptReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn code_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn hash_type(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn args(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for UdtScriptReader<'r> {
    type Entity = UdtScript;
    const NAME: &'static str = "UdtScriptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        UdtScriptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        ByteReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        BytesReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct UdtScriptBuilder {
    pub(crate) code_hash: Byte32,
    pub(crate) hash_type: Byte,
    pub(crate) args: Bytes,
}
impl UdtScriptBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn code_hash(mut self, v: Byte32) -> Self {
        self.code_hash = v;
        self
    }
    pub fn hash_type(mut self, v: Byte) -> Self {
        self.hash_type = v;
        self
    }
    pub fn args(mut self, v: Bytes) -> Self {
        self.args = v;
        self
    }
}
impl molecule::prelude::Builder for UdtScriptBuilder {
    type Entity = UdtScript;
    const NAME: &'static str = "UdtScriptBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.code_hash.as_slice().len()
            + self.hash_type.as_slice().len()
            + self.args.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.code_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.hash_type.as_slice().len();
        offsets.push(total_size);
        total_size += self.args.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.code_hash.as_slice())?;
        writer.write_all(self.hash_type.as_slice())?;
        writer.write_all(self.args.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        UdtScript::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct UdtCellDeps(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for UdtCellDeps {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for UdtCellDeps {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for UdtCellDeps {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for UdtCellDeps {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        UdtCellDeps::new_unchecked(v)
    }
}
impl UdtCellDeps {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<UdtCellDep> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> UdtCellDep {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            UdtCellDep::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            UdtCellDep::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> UdtCellDepsReader<'r> {
        UdtCellDepsReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for UdtCellDeps {
    type Builder = UdtCellDepsBuilder;
    const NAME: &'static str = "UdtCellDeps";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        UdtCellDeps(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UdtCellDepsReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UdtCellDepsReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct UdtCellDepsReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for UdtCellDepsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for UdtCellDepsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for UdtCellDepsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> UdtCellDepsReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<UdtCellDepReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> UdtCellDepReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            UdtCellDepReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            UdtCellDepReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for UdtCellDepsReader<'r> {
    type Entity = UdtCellDeps;
    const NAME: &'static str = "UdtCellDepsReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        UdtCellDepsReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            UdtCellDepReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct UdtCellDepsBuilder(pub(crate) Vec<UdtCellDep>);
impl UdtCellDepsBuilder {
    pub fn set(mut self, v: Vec<UdtCellDep>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: UdtCellDep) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = UdtCellDep>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: UdtCellDep) -> Option<UdtCellDep> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for UdtCellDepsBuilder {
    type Entity = UdtCellDeps;
    const NAME: &'static str = "UdtCellDepsBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        UdtCellDeps::new_unchecked(inner.into())
    }
}
pub struct UdtCellDepsIterator(UdtCellDeps, usize, usize);
impl ::core::iter::Iterator for UdtCellDepsIterator {
    type Item = UdtCellDep;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for UdtCellDepsIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for UdtCellDeps {
    type Item = UdtCellDep;
    type IntoIter = UdtCellDepsIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        UdtCellDepsIterator(self, 0, len)
    }
}
impl<'r> UdtCellDepsReader<'r> {
    pub fn iter<'t>(&'t self) -> UdtCellDepsReaderIterator<'t, 'r> {
        UdtCellDepsReaderIterator(&self, 0, self.len())
    }
}
pub struct UdtCellDepsReaderIterator<'t, 'r>(&'t UdtCellDepsReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for UdtCellDepsReaderIterator<'t, 'r> {
    type Item = UdtCellDepReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for UdtCellDepsReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::FromIterator<UdtCellDep> for UdtCellDeps {
    fn from_iter<T: IntoIterator<Item = UdtCellDep>>(iter: T) -> Self {
        Self::new_builder().extend(iter).build()
    }
}
#[derive(Clone)]
pub struct UdtArgInfo(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for UdtArgInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for UdtArgInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for UdtArgInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "name", self.name())?;
        write!(f, ", {}: {}", "script", self.script())?;
        write!(
            f,
            ", {}: {}",
            "auto_accept_amount",
            self.auto_accept_amount()
        )?;
        write!(f, ", {}: {}", "cell_deps", self.cell_deps())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for UdtArgInfo {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        UdtArgInfo::new_unchecked(v)
    }
}
impl UdtArgInfo {
    const DEFAULT_VALUE: [u8; 81] = [
        81, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 77, 0, 0, 0, 77, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0,
        16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn name(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn script(&self) -> UdtScript {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        UdtScript::new_unchecked(self.0.slice(start..end))
    }
    pub fn auto_accept_amount(&self) -> Uint128Opt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint128Opt::new_unchecked(self.0.slice(start..end))
    }
    pub fn cell_deps(&self) -> UdtCellDeps {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            UdtCellDeps::new_unchecked(self.0.slice(start..end))
        } else {
            UdtCellDeps::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> UdtArgInfoReader<'r> {
        UdtArgInfoReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for UdtArgInfo {
    type Builder = UdtArgInfoBuilder;
    const NAME: &'static str = "UdtArgInfo";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        UdtArgInfo(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UdtArgInfoReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UdtArgInfoReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .name(self.name())
            .script(self.script())
            .auto_accept_amount(self.auto_accept_amount())
            .cell_deps(self.cell_deps())
    }
}
#[derive(Clone, Copy)]
pub struct UdtArgInfoReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for UdtArgInfoReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for UdtArgInfoReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for UdtArgInfoReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "name", self.name())?;
        write!(f, ", {}: {}", "script", self.script())?;
        write!(
            f,
            ", {}: {}",
            "auto_accept_amount",
            self.auto_accept_amount()
        )?;
        write!(f, ", {}: {}", "cell_deps", self.cell_deps())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> UdtArgInfoReader<'r> {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn name(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn script(&self) -> UdtScriptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        UdtScriptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn auto_accept_amount(&self) -> Uint128OptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint128OptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn cell_deps(&self) -> UdtCellDepsReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            UdtCellDepsReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            UdtCellDepsReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for UdtArgInfoReader<'r> {
    type Entity = UdtArgInfo;
    const NAME: &'static str = "UdtArgInfoReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        UdtArgInfoReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        BytesReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        UdtScriptReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Uint128OptReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        UdtCellDepsReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct UdtArgInfoBuilder {
    pub(crate) name: Bytes,
    pub(crate) script: UdtScript,
    pub(crate) auto_accept_amount: Uint128Opt,
    pub(crate) cell_deps: UdtCellDeps,
}
impl UdtArgInfoBuilder {
    pub const FIELD_COUNT: usize = 4;
    pub fn name(mut self, v: Bytes) -> Self {
        self.name = v;
        self
    }
    pub fn script(mut self, v: UdtScript) -> Self {
        self.script = v;
        self
    }
    pub fn auto_accept_amount(mut self, v: Uint128Opt) -> Self {
        self.auto_accept_amount = v;
        self
    }
    pub fn cell_deps(mut self, v: UdtCellDeps) -> Self {
        self.cell_deps = v;
        self
    }
}
impl molecule::prelude::Builder for UdtArgInfoBuilder {
    type Entity = UdtArgInfo;
    const NAME: &'static str = "UdtArgInfoBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.name.as_slice().len()
            + self.script.as_slice().len()
            + self.auto_accept_amount.as_slice().len()
            + self.cell_deps.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.name.as_slice().len();
        offsets.push(total_size);
        total_size += self.script.as_slice().len();
        offsets.push(total_size);
        total_size += self.auto_accept_amount.as_slice().len();
        offsets.push(total_size);
        total_size += self.cell_deps.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.name.as_slice())?;
        writer.write_all(self.script.as_slice())?;
        writer.write_all(self.auto_accept_amount.as_slice())?;
        writer.write_all(self.cell_deps.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        UdtArgInfo::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct UdtCfgInfos(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for UdtCfgInfos {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for UdtCfgInfos {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for UdtCfgInfos {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for UdtCfgInfos {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        UdtCfgInfos::new_unchecked(v)
    }
}
impl UdtCfgInfos {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<UdtArgInfo> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> UdtArgInfo {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            UdtArgInfo::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            UdtArgInfo::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> UdtCfgInfosReader<'r> {
        UdtCfgInfosReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for UdtCfgInfos {
    type Builder = UdtCfgInfosBuilder;
    const NAME: &'static str = "UdtCfgInfos";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        UdtCfgInfos(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UdtCfgInfosReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UdtCfgInfosReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct UdtCfgInfosReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for UdtCfgInfosReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for UdtCfgInfosReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for UdtCfgInfosReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> UdtCfgInfosReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<UdtArgInfoReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> UdtArgInfoReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            UdtArgInfoReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            UdtArgInfoReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for UdtCfgInfosReader<'r> {
    type Entity = UdtCfgInfos;
    const NAME: &'static str = "UdtCfgInfosReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        UdtCfgInfosReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            UdtArgInfoReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct UdtCfgInfosBuilder(pub(crate) Vec<UdtArgInfo>);
impl UdtCfgInfosBuilder {
    pub fn set(mut self, v: Vec<UdtArgInfo>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: UdtArgInfo) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = UdtArgInfo>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: UdtArgInfo) -> Option<UdtArgInfo> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for UdtCfgInfosBuilder {
    type Entity = UdtCfgInfos;
    const NAME: &'static str = "UdtCfgInfosBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        UdtCfgInfos::new_unchecked(inner.into())
    }
}
pub struct UdtCfgInfosIterator(UdtCfgInfos, usize, usize);
impl ::core::iter::Iterator for UdtCfgInfosIterator {
    type Item = UdtArgInfo;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for UdtCfgInfosIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for UdtCfgInfos {
    type Item = UdtArgInfo;
    type IntoIter = UdtCfgInfosIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        UdtCfgInfosIterator(self, 0, len)
    }
}
impl<'r> UdtCfgInfosReader<'r> {
    pub fn iter<'t>(&'t self) -> UdtCfgInfosReaderIterator<'t, 'r> {
        UdtCfgInfosReaderIterator(&self, 0, self.len())
    }
}
pub struct UdtCfgInfosReaderIterator<'t, 'r>(&'t UdtCfgInfosReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for UdtCfgInfosReaderIterator<'t, 'r> {
    type Item = UdtArgInfoReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for UdtCfgInfosReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::FromIterator<UdtArgInfo> for UdtCfgInfos {
    fn from_iter<T: IntoIterator<Item = UdtArgInfo>>(iter: T) -> Self {
        Self::new_builder().extend(iter).build()
    }
}
#[derive(Clone)]
pub struct FiberMessage(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for FiberMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for FiberMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for FiberMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for FiberMessage {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        FiberMessage::new_unchecked(v)
    }
}
impl FiberMessage {
    const DEFAULT_VALUE: [u8; 468] = [
        0, 0, 0, 0, 208, 1, 0, 0, 76, 0, 0, 0, 108, 0, 0, 0, 140, 0, 0, 0, 140, 0, 0, 0, 156, 0, 0,
        0, 209, 0, 0, 0, 217, 0, 0, 0, 225, 0, 0, 0, 233, 0, 0, 0, 249, 0, 0, 0, 1, 1, 0, 0, 9, 1,
        0, 0, 42, 1, 0, 0, 75, 1, 0, 0, 108, 1, 0, 0, 141, 1, 0, 0, 141, 1, 0, 0, 207, 1, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0,
        0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const ITEMS_COUNT: usize = 18;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> FiberMessageUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => OpenChannel::new_unchecked(inner).into(),
            1 => AcceptChannel::new_unchecked(inner).into(),
            2 => TxSignatures::new_unchecked(inner).into(),
            3 => TxUpdate::new_unchecked(inner).into(),
            4 => TxComplete::new_unchecked(inner).into(),
            5 => TxAbort::new_unchecked(inner).into(),
            6 => TxInitRBF::new_unchecked(inner).into(),
            7 => TxAckRBF::new_unchecked(inner).into(),
            8 => CommitmentSigned::new_unchecked(inner).into(),
            9 => ChannelReady::new_unchecked(inner).into(),
            10 => UpdateTlcInfo::new_unchecked(inner).into(),
            11 => AddTlc::new_unchecked(inner).into(),
            12 => RemoveTlc::new_unchecked(inner).into(),
            13 => RevokeAndAck::new_unchecked(inner).into(),
            14 => Shutdown::new_unchecked(inner).into(),
            15 => ClosingSigned::new_unchecked(inner).into(),
            16 => ReestablishChannel::new_unchecked(inner).into(),
            17 => AnnouncementSignatures::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> FiberMessageReader<'r> {
        FiberMessageReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for FiberMessage {
    type Builder = FiberMessageBuilder;
    const NAME: &'static str = "FiberMessage";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        FiberMessage(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FiberMessageReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FiberMessageReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct FiberMessageReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for FiberMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for FiberMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for FiberMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> FiberMessageReader<'r> {
    pub const ITEMS_COUNT: usize = 18;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> FiberMessageUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => OpenChannelReader::new_unchecked(inner).into(),
            1 => AcceptChannelReader::new_unchecked(inner).into(),
            2 => TxSignaturesReader::new_unchecked(inner).into(),
            3 => TxUpdateReader::new_unchecked(inner).into(),
            4 => TxCompleteReader::new_unchecked(inner).into(),
            5 => TxAbortReader::new_unchecked(inner).into(),
            6 => TxInitRBFReader::new_unchecked(inner).into(),
            7 => TxAckRBFReader::new_unchecked(inner).into(),
            8 => CommitmentSignedReader::new_unchecked(inner).into(),
            9 => ChannelReadyReader::new_unchecked(inner).into(),
            10 => UpdateTlcInfoReader::new_unchecked(inner).into(),
            11 => AddTlcReader::new_unchecked(inner).into(),
            12 => RemoveTlcReader::new_unchecked(inner).into(),
            13 => RevokeAndAckReader::new_unchecked(inner).into(),
            14 => ShutdownReader::new_unchecked(inner).into(),
            15 => ClosingSignedReader::new_unchecked(inner).into(),
            16 => ReestablishChannelReader::new_unchecked(inner).into(),
            17 => AnnouncementSignaturesReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for FiberMessageReader<'r> {
    type Entity = FiberMessage;
    const NAME: &'static str = "FiberMessageReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        FiberMessageReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => OpenChannelReader::verify(inner_slice, compatible),
            1 => AcceptChannelReader::verify(inner_slice, compatible),
            2 => TxSignaturesReader::verify(inner_slice, compatible),
            3 => TxUpdateReader::verify(inner_slice, compatible),
            4 => TxCompleteReader::verify(inner_slice, compatible),
            5 => TxAbortReader::verify(inner_slice, compatible),
            6 => TxInitRBFReader::verify(inner_slice, compatible),
            7 => TxAckRBFReader::verify(inner_slice, compatible),
            8 => CommitmentSignedReader::verify(inner_slice, compatible),
            9 => ChannelReadyReader::verify(inner_slice, compatible),
            10 => UpdateTlcInfoReader::verify(inner_slice, compatible),
            11 => AddTlcReader::verify(inner_slice, compatible),
            12 => RemoveTlcReader::verify(inner_slice, compatible),
            13 => RevokeAndAckReader::verify(inner_slice, compatible),
            14 => ShutdownReader::verify(inner_slice, compatible),
            15 => ClosingSignedReader::verify(inner_slice, compatible),
            16 => ReestablishChannelReader::verify(inner_slice, compatible),
            17 => AnnouncementSignaturesReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct FiberMessageBuilder(pub(crate) FiberMessageUnion);
impl FiberMessageBuilder {
    pub const ITEMS_COUNT: usize = 18;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<FiberMessageUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for FiberMessageBuilder {
    type Entity = FiberMessage;
    const NAME: &'static str = "FiberMessageBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        FiberMessage::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum FiberMessageUnion {
    OpenChannel(OpenChannel),
    AcceptChannel(AcceptChannel),
    TxSignatures(TxSignatures),
    TxUpdate(TxUpdate),
    TxComplete(TxComplete),
    TxAbort(TxAbort),
    TxInitRBF(TxInitRBF),
    TxAckRBF(TxAckRBF),
    CommitmentSigned(CommitmentSigned),
    ChannelReady(ChannelReady),
    UpdateTlcInfo(UpdateTlcInfo),
    AddTlc(AddTlc),
    RemoveTlc(RemoveTlc),
    RevokeAndAck(RevokeAndAck),
    Shutdown(Shutdown),
    ClosingSigned(ClosingSigned),
    ReestablishChannel(ReestablishChannel),
    AnnouncementSignatures(AnnouncementSignatures),
}
#[derive(Debug, Clone, Copy)]
pub enum FiberMessageUnionReader<'r> {
    OpenChannel(OpenChannelReader<'r>),
    AcceptChannel(AcceptChannelReader<'r>),
    TxSignatures(TxSignaturesReader<'r>),
    TxUpdate(TxUpdateReader<'r>),
    TxComplete(TxCompleteReader<'r>),
    TxAbort(TxAbortReader<'r>),
    TxInitRBF(TxInitRBFReader<'r>),
    TxAckRBF(TxAckRBFReader<'r>),
    CommitmentSigned(CommitmentSignedReader<'r>),
    ChannelReady(ChannelReadyReader<'r>),
    UpdateTlcInfo(UpdateTlcInfoReader<'r>),
    AddTlc(AddTlcReader<'r>),
    RemoveTlc(RemoveTlcReader<'r>),
    RevokeAndAck(RevokeAndAckReader<'r>),
    Shutdown(ShutdownReader<'r>),
    ClosingSigned(ClosingSignedReader<'r>),
    ReestablishChannel(ReestablishChannelReader<'r>),
    AnnouncementSignatures(AnnouncementSignaturesReader<'r>),
}
impl ::core::default::Default for FiberMessageUnion {
    fn default() -> Self {
        FiberMessageUnion::OpenChannel(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for FiberMessageUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            FiberMessageUnion::OpenChannel(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, OpenChannel::NAME, item)
            }
            FiberMessageUnion::AcceptChannel(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, AcceptChannel::NAME, item)
            }
            FiberMessageUnion::TxSignatures(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TxSignatures::NAME, item)
            }
            FiberMessageUnion::TxUpdate(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TxUpdate::NAME, item)
            }
            FiberMessageUnion::TxComplete(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TxComplete::NAME, item)
            }
            FiberMessageUnion::TxAbort(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TxAbort::NAME, item)
            }
            FiberMessageUnion::TxInitRBF(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TxInitRBF::NAME, item)
            }
            FiberMessageUnion::TxAckRBF(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TxAckRBF::NAME, item)
            }
            FiberMessageUnion::CommitmentSigned(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, CommitmentSigned::NAME, item)
            }
            FiberMessageUnion::ChannelReady(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ChannelReady::NAME, item)
            }
            FiberMessageUnion::UpdateTlcInfo(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, UpdateTlcInfo::NAME, item)
            }
            FiberMessageUnion::AddTlc(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, AddTlc::NAME, item)
            }
            FiberMessageUnion::RemoveTlc(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, RemoveTlc::NAME, item)
            }
            FiberMessageUnion::RevokeAndAck(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, RevokeAndAck::NAME, item)
            }
            FiberMessageUnion::Shutdown(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Shutdown::NAME, item)
            }
            FiberMessageUnion::ClosingSigned(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ClosingSigned::NAME, item)
            }
            FiberMessageUnion::ReestablishChannel(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ReestablishChannel::NAME, item)
            }
            FiberMessageUnion::AnnouncementSignatures(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    AnnouncementSignatures::NAME,
                    item
                )
            }
        }
    }
}
impl<'r> ::core::fmt::Display for FiberMessageUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            FiberMessageUnionReader::OpenChannel(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, OpenChannel::NAME, item)
            }
            FiberMessageUnionReader::AcceptChannel(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, AcceptChannel::NAME, item)
            }
            FiberMessageUnionReader::TxSignatures(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TxSignatures::NAME, item)
            }
            FiberMessageUnionReader::TxUpdate(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TxUpdate::NAME, item)
            }
            FiberMessageUnionReader::TxComplete(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TxComplete::NAME, item)
            }
            FiberMessageUnionReader::TxAbort(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TxAbort::NAME, item)
            }
            FiberMessageUnionReader::TxInitRBF(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TxInitRBF::NAME, item)
            }
            FiberMessageUnionReader::TxAckRBF(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TxAckRBF::NAME, item)
            }
            FiberMessageUnionReader::CommitmentSigned(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, CommitmentSigned::NAME, item)
            }
            FiberMessageUnionReader::ChannelReady(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ChannelReady::NAME, item)
            }
            FiberMessageUnionReader::UpdateTlcInfo(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, UpdateTlcInfo::NAME, item)
            }
            FiberMessageUnionReader::AddTlc(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, AddTlc::NAME, item)
            }
            FiberMessageUnionReader::RemoveTlc(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, RemoveTlc::NAME, item)
            }
            FiberMessageUnionReader::RevokeAndAck(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, RevokeAndAck::NAME, item)
            }
            FiberMessageUnionReader::Shutdown(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Shutdown::NAME, item)
            }
            FiberMessageUnionReader::ClosingSigned(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ClosingSigned::NAME, item)
            }
            FiberMessageUnionReader::ReestablishChannel(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ReestablishChannel::NAME, item)
            }
            FiberMessageUnionReader::AnnouncementSignatures(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    AnnouncementSignatures::NAME,
                    item
                )
            }
        }
    }
}
impl FiberMessageUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            FiberMessageUnion::OpenChannel(ref item) => write!(f, "{}", item),
            FiberMessageUnion::AcceptChannel(ref item) => write!(f, "{}", item),
            FiberMessageUnion::TxSignatures(ref item) => write!(f, "{}", item),
            FiberMessageUnion::TxUpdate(ref item) => write!(f, "{}", item),
            FiberMessageUnion::TxComplete(ref item) => write!(f, "{}", item),
            FiberMessageUnion::TxAbort(ref item) => write!(f, "{}", item),
            FiberMessageUnion::TxInitRBF(ref item) => write!(f, "{}", item),
            FiberMessageUnion::TxAckRBF(ref item) => write!(f, "{}", item),
            FiberMessageUnion::CommitmentSigned(ref item) => write!(f, "{}", item),
            FiberMessageUnion::ChannelReady(ref item) => write!(f, "{}", item),
            FiberMessageUnion::UpdateTlcInfo(ref item) => write!(f, "{}", item),
            FiberMessageUnion::AddTlc(ref item) => write!(f, "{}", item),
            FiberMessageUnion::RemoveTlc(ref item) => write!(f, "{}", item),
            FiberMessageUnion::RevokeAndAck(ref item) => write!(f, "{}", item),
            FiberMessageUnion::Shutdown(ref item) => write!(f, "{}", item),
            FiberMessageUnion::ClosingSigned(ref item) => write!(f, "{}", item),
            FiberMessageUnion::ReestablishChannel(ref item) => write!(f, "{}", item),
            FiberMessageUnion::AnnouncementSignatures(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> FiberMessageUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            FiberMessageUnionReader::OpenChannel(ref item) => write!(f, "{}", item),
            FiberMessageUnionReader::AcceptChannel(ref item) => write!(f, "{}", item),
            FiberMessageUnionReader::TxSignatures(ref item) => write!(f, "{}", item),
            FiberMessageUnionReader::TxUpdate(ref item) => write!(f, "{}", item),
            FiberMessageUnionReader::TxComplete(ref item) => write!(f, "{}", item),
            FiberMessageUnionReader::TxAbort(ref item) => write!(f, "{}", item),
            FiberMessageUnionReader::TxInitRBF(ref item) => write!(f, "{}", item),
            FiberMessageUnionReader::TxAckRBF(ref item) => write!(f, "{}", item),
            FiberMessageUnionReader::CommitmentSigned(ref item) => write!(f, "{}", item),
            FiberMessageUnionReader::ChannelReady(ref item) => write!(f, "{}", item),
            FiberMessageUnionReader::UpdateTlcInfo(ref item) => write!(f, "{}", item),
            FiberMessageUnionReader::AddTlc(ref item) => write!(f, "{}", item),
            FiberMessageUnionReader::RemoveTlc(ref item) => write!(f, "{}", item),
            FiberMessageUnionReader::RevokeAndAck(ref item) => write!(f, "{}", item),
            FiberMessageUnionReader::Shutdown(ref item) => write!(f, "{}", item),
            FiberMessageUnionReader::ClosingSigned(ref item) => write!(f, "{}", item),
            FiberMessageUnionReader::ReestablishChannel(ref item) => write!(f, "{}", item),
            FiberMessageUnionReader::AnnouncementSignatures(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<OpenChannel> for FiberMessageUnion {
    fn from(item: OpenChannel) -> Self {
        FiberMessageUnion::OpenChannel(item)
    }
}
impl ::core::convert::From<AcceptChannel> for FiberMessageUnion {
    fn from(item: AcceptChannel) -> Self {
        FiberMessageUnion::AcceptChannel(item)
    }
}
impl ::core::convert::From<TxSignatures> for FiberMessageUnion {
    fn from(item: TxSignatures) -> Self {
        FiberMessageUnion::TxSignatures(item)
    }
}
impl ::core::convert::From<TxUpdate> for FiberMessageUnion {
    fn from(item: TxUpdate) -> Self {
        FiberMessageUnion::TxUpdate(item)
    }
}
impl ::core::convert::From<TxComplete> for FiberMessageUnion {
    fn from(item: TxComplete) -> Self {
        FiberMessageUnion::TxComplete(item)
    }
}
impl ::core::convert::From<TxAbort> for FiberMessageUnion {
    fn from(item: TxAbort) -> Self {
        FiberMessageUnion::TxAbort(item)
    }
}
impl ::core::convert::From<TxInitRBF> for FiberMessageUnion {
    fn from(item: TxInitRBF) -> Self {
        FiberMessageUnion::TxInitRBF(item)
    }
}
impl ::core::convert::From<TxAckRBF> for FiberMessageUnion {
    fn from(item: TxAckRBF) -> Self {
        FiberMessageUnion::TxAckRBF(item)
    }
}
impl ::core::convert::From<CommitmentSigned> for FiberMessageUnion {
    fn from(item: CommitmentSigned) -> Self {
        FiberMessageUnion::CommitmentSigned(item)
    }
}
impl ::core::convert::From<ChannelReady> for FiberMessageUnion {
    fn from(item: ChannelReady) -> Self {
        FiberMessageUnion::ChannelReady(item)
    }
}
impl ::core::convert::From<UpdateTlcInfo> for FiberMessageUnion {
    fn from(item: UpdateTlcInfo) -> Self {
        FiberMessageUnion::UpdateTlcInfo(item)
    }
}
impl ::core::convert::From<AddTlc> for FiberMessageUnion {
    fn from(item: AddTlc) -> Self {
        FiberMessageUnion::AddTlc(item)
    }
}
impl ::core::convert::From<RemoveTlc> for FiberMessageUnion {
    fn from(item: RemoveTlc) -> Self {
        FiberMessageUnion::RemoveTlc(item)
    }
}
impl ::core::convert::From<RevokeAndAck> for FiberMessageUnion {
    fn from(item: RevokeAndAck) -> Self {
        FiberMessageUnion::RevokeAndAck(item)
    }
}
impl ::core::convert::From<Shutdown> for FiberMessageUnion {
    fn from(item: Shutdown) -> Self {
        FiberMessageUnion::Shutdown(item)
    }
}
impl ::core::convert::From<ClosingSigned> for FiberMessageUnion {
    fn from(item: ClosingSigned) -> Self {
        FiberMessageUnion::ClosingSigned(item)
    }
}
impl ::core::convert::From<ReestablishChannel> for FiberMessageUnion {
    fn from(item: ReestablishChannel) -> Self {
        FiberMessageUnion::ReestablishChannel(item)
    }
}
impl ::core::convert::From<AnnouncementSignatures> for FiberMessageUnion {
    fn from(item: AnnouncementSignatures) -> Self {
        FiberMessageUnion::AnnouncementSignatures(item)
    }
}
impl<'r> ::core::convert::From<OpenChannelReader<'r>> for FiberMessageUnionReader<'r> {
    fn from(item: OpenChannelReader<'r>) -> Self {
        FiberMessageUnionReader::OpenChannel(item)
    }
}
impl<'r> ::core::convert::From<AcceptChannelReader<'r>> for FiberMessageUnionReader<'r> {
    fn from(item: AcceptChannelReader<'r>) -> Self {
        FiberMessageUnionReader::AcceptChannel(item)
    }
}
impl<'r> ::core::convert::From<TxSignaturesReader<'r>> for FiberMessageUnionReader<'r> {
    fn from(item: TxSignaturesReader<'r>) -> Self {
        FiberMessageUnionReader::TxSignatures(item)
    }
}
impl<'r> ::core::convert::From<TxUpdateReader<'r>> for FiberMessageUnionReader<'r> {
    fn from(item: TxUpdateReader<'r>) -> Self {
        FiberMessageUnionReader::TxUpdate(item)
    }
}
impl<'r> ::core::convert::From<TxCompleteReader<'r>> for FiberMessageUnionReader<'r> {
    fn from(item: TxCompleteReader<'r>) -> Self {
        FiberMessageUnionReader::TxComplete(item)
    }
}
impl<'r> ::core::convert::From<TxAbortReader<'r>> for FiberMessageUnionReader<'r> {
    fn from(item: TxAbortReader<'r>) -> Self {
        FiberMessageUnionReader::TxAbort(item)
    }
}
impl<'r> ::core::convert::From<TxInitRBFReader<'r>> for FiberMessageUnionReader<'r> {
    fn from(item: TxInitRBFReader<'r>) -> Self {
        FiberMessageUnionReader::TxInitRBF(item)
    }
}
impl<'r> ::core::convert::From<TxAckRBFReader<'r>> for FiberMessageUnionReader<'r> {
    fn from(item: TxAckRBFReader<'r>) -> Self {
        FiberMessageUnionReader::TxAckRBF(item)
    }
}
impl<'r> ::core::convert::From<CommitmentSignedReader<'r>> for FiberMessageUnionReader<'r> {
    fn from(item: CommitmentSignedReader<'r>) -> Self {
        FiberMessageUnionReader::CommitmentSigned(item)
    }
}
impl<'r> ::core::convert::From<ChannelReadyReader<'r>> for FiberMessageUnionReader<'r> {
    fn from(item: ChannelReadyReader<'r>) -> Self {
        FiberMessageUnionReader::ChannelReady(item)
    }
}
impl<'r> ::core::convert::From<UpdateTlcInfoReader<'r>> for FiberMessageUnionReader<'r> {
    fn from(item: UpdateTlcInfoReader<'r>) -> Self {
        FiberMessageUnionReader::UpdateTlcInfo(item)
    }
}
impl<'r> ::core::convert::From<AddTlcReader<'r>> for FiberMessageUnionReader<'r> {
    fn from(item: AddTlcReader<'r>) -> Self {
        FiberMessageUnionReader::AddTlc(item)
    }
}
impl<'r> ::core::convert::From<RemoveTlcReader<'r>> for FiberMessageUnionReader<'r> {
    fn from(item: RemoveTlcReader<'r>) -> Self {
        FiberMessageUnionReader::RemoveTlc(item)
    }
}
impl<'r> ::core::convert::From<RevokeAndAckReader<'r>> for FiberMessageUnionReader<'r> {
    fn from(item: RevokeAndAckReader<'r>) -> Self {
        FiberMessageUnionReader::RevokeAndAck(item)
    }
}
impl<'r> ::core::convert::From<ShutdownReader<'r>> for FiberMessageUnionReader<'r> {
    fn from(item: ShutdownReader<'r>) -> Self {
        FiberMessageUnionReader::Shutdown(item)
    }
}
impl<'r> ::core::convert::From<ClosingSignedReader<'r>> for FiberMessageUnionReader<'r> {
    fn from(item: ClosingSignedReader<'r>) -> Self {
        FiberMessageUnionReader::ClosingSigned(item)
    }
}
impl<'r> ::core::convert::From<ReestablishChannelReader<'r>> for FiberMessageUnionReader<'r> {
    fn from(item: ReestablishChannelReader<'r>) -> Self {
        FiberMessageUnionReader::ReestablishChannel(item)
    }
}
impl<'r> ::core::convert::From<AnnouncementSignaturesReader<'r>> for FiberMessageUnionReader<'r> {
    fn from(item: AnnouncementSignaturesReader<'r>) -> Self {
        FiberMessageUnionReader::AnnouncementSignatures(item)
    }
}
impl FiberMessageUnion {
    pub const NAME: &'static str = "FiberMessageUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            FiberMessageUnion::OpenChannel(item) => item.as_bytes(),
            FiberMessageUnion::AcceptChannel(item) => item.as_bytes(),
            FiberMessageUnion::TxSignatures(item) => item.as_bytes(),
            FiberMessageUnion::TxUpdate(item) => item.as_bytes(),
            FiberMessageUnion::TxComplete(item) => item.as_bytes(),
            FiberMessageUnion::TxAbort(item) => item.as_bytes(),
            FiberMessageUnion::TxInitRBF(item) => item.as_bytes(),
            FiberMessageUnion::TxAckRBF(item) => item.as_bytes(),
            FiberMessageUnion::CommitmentSigned(item) => item.as_bytes(),
            FiberMessageUnion::ChannelReady(item) => item.as_bytes(),
            FiberMessageUnion::UpdateTlcInfo(item) => item.as_bytes(),
            FiberMessageUnion::AddTlc(item) => item.as_bytes(),
            FiberMessageUnion::RemoveTlc(item) => item.as_bytes(),
            FiberMessageUnion::RevokeAndAck(item) => item.as_bytes(),
            FiberMessageUnion::Shutdown(item) => item.as_bytes(),
            FiberMessageUnion::ClosingSigned(item) => item.as_bytes(),
            FiberMessageUnion::ReestablishChannel(item) => item.as_bytes(),
            FiberMessageUnion::AnnouncementSignatures(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            FiberMessageUnion::OpenChannel(item) => item.as_slice(),
            FiberMessageUnion::AcceptChannel(item) => item.as_slice(),
            FiberMessageUnion::TxSignatures(item) => item.as_slice(),
            FiberMessageUnion::TxUpdate(item) => item.as_slice(),
            FiberMessageUnion::TxComplete(item) => item.as_slice(),
            FiberMessageUnion::TxAbort(item) => item.as_slice(),
            FiberMessageUnion::TxInitRBF(item) => item.as_slice(),
            FiberMessageUnion::TxAckRBF(item) => item.as_slice(),
            FiberMessageUnion::CommitmentSigned(item) => item.as_slice(),
            FiberMessageUnion::ChannelReady(item) => item.as_slice(),
            FiberMessageUnion::UpdateTlcInfo(item) => item.as_slice(),
            FiberMessageUnion::AddTlc(item) => item.as_slice(),
            FiberMessageUnion::RemoveTlc(item) => item.as_slice(),
            FiberMessageUnion::RevokeAndAck(item) => item.as_slice(),
            FiberMessageUnion::Shutdown(item) => item.as_slice(),
            FiberMessageUnion::ClosingSigned(item) => item.as_slice(),
            FiberMessageUnion::ReestablishChannel(item) => item.as_slice(),
            FiberMessageUnion::AnnouncementSignatures(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            FiberMessageUnion::OpenChannel(_) => 0,
            FiberMessageUnion::AcceptChannel(_) => 1,
            FiberMessageUnion::TxSignatures(_) => 2,
            FiberMessageUnion::TxUpdate(_) => 3,
            FiberMessageUnion::TxComplete(_) => 4,
            FiberMessageUnion::TxAbort(_) => 5,
            FiberMessageUnion::TxInitRBF(_) => 6,
            FiberMessageUnion::TxAckRBF(_) => 7,
            FiberMessageUnion::CommitmentSigned(_) => 8,
            FiberMessageUnion::ChannelReady(_) => 9,
            FiberMessageUnion::UpdateTlcInfo(_) => 10,
            FiberMessageUnion::AddTlc(_) => 11,
            FiberMessageUnion::RemoveTlc(_) => 12,
            FiberMessageUnion::RevokeAndAck(_) => 13,
            FiberMessageUnion::Shutdown(_) => 14,
            FiberMessageUnion::ClosingSigned(_) => 15,
            FiberMessageUnion::ReestablishChannel(_) => 16,
            FiberMessageUnion::AnnouncementSignatures(_) => 17,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            FiberMessageUnion::OpenChannel(_) => "OpenChannel",
            FiberMessageUnion::AcceptChannel(_) => "AcceptChannel",
            FiberMessageUnion::TxSignatures(_) => "TxSignatures",
            FiberMessageUnion::TxUpdate(_) => "TxUpdate",
            FiberMessageUnion::TxComplete(_) => "TxComplete",
            FiberMessageUnion::TxAbort(_) => "TxAbort",
            FiberMessageUnion::TxInitRBF(_) => "TxInitRBF",
            FiberMessageUnion::TxAckRBF(_) => "TxAckRBF",
            FiberMessageUnion::CommitmentSigned(_) => "CommitmentSigned",
            FiberMessageUnion::ChannelReady(_) => "ChannelReady",
            FiberMessageUnion::UpdateTlcInfo(_) => "UpdateTlcInfo",
            FiberMessageUnion::AddTlc(_) => "AddTlc",
            FiberMessageUnion::RemoveTlc(_) => "RemoveTlc",
            FiberMessageUnion::RevokeAndAck(_) => "RevokeAndAck",
            FiberMessageUnion::Shutdown(_) => "Shutdown",
            FiberMessageUnion::ClosingSigned(_) => "ClosingSigned",
            FiberMessageUnion::ReestablishChannel(_) => "ReestablishChannel",
            FiberMessageUnion::AnnouncementSignatures(_) => "AnnouncementSignatures",
        }
    }
    pub fn as_reader<'r>(&'r self) -> FiberMessageUnionReader<'r> {
        match self {
            FiberMessageUnion::OpenChannel(item) => item.as_reader().into(),
            FiberMessageUnion::AcceptChannel(item) => item.as_reader().into(),
            FiberMessageUnion::TxSignatures(item) => item.as_reader().into(),
            FiberMessageUnion::TxUpdate(item) => item.as_reader().into(),
            FiberMessageUnion::TxComplete(item) => item.as_reader().into(),
            FiberMessageUnion::TxAbort(item) => item.as_reader().into(),
            FiberMessageUnion::TxInitRBF(item) => item.as_reader().into(),
            FiberMessageUnion::TxAckRBF(item) => item.as_reader().into(),
            FiberMessageUnion::CommitmentSigned(item) => item.as_reader().into(),
            FiberMessageUnion::ChannelReady(item) => item.as_reader().into(),
            FiberMessageUnion::UpdateTlcInfo(item) => item.as_reader().into(),
            FiberMessageUnion::AddTlc(item) => item.as_reader().into(),
            FiberMessageUnion::RemoveTlc(item) => item.as_reader().into(),
            FiberMessageUnion::RevokeAndAck(item) => item.as_reader().into(),
            FiberMessageUnion::Shutdown(item) => item.as_reader().into(),
            FiberMessageUnion::ClosingSigned(item) => item.as_reader().into(),
            FiberMessageUnion::ReestablishChannel(item) => item.as_reader().into(),
            FiberMessageUnion::AnnouncementSignatures(item) => item.as_reader().into(),
        }
    }
}
impl<'r> FiberMessageUnionReader<'r> {
    pub const NAME: &'r str = "FiberMessageUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            FiberMessageUnionReader::OpenChannel(item) => item.as_slice(),
            FiberMessageUnionReader::AcceptChannel(item) => item.as_slice(),
            FiberMessageUnionReader::TxSignatures(item) => item.as_slice(),
            FiberMessageUnionReader::TxUpdate(item) => item.as_slice(),
            FiberMessageUnionReader::TxComplete(item) => item.as_slice(),
            FiberMessageUnionReader::TxAbort(item) => item.as_slice(),
            FiberMessageUnionReader::TxInitRBF(item) => item.as_slice(),
            FiberMessageUnionReader::TxAckRBF(item) => item.as_slice(),
            FiberMessageUnionReader::CommitmentSigned(item) => item.as_slice(),
            FiberMessageUnionReader::ChannelReady(item) => item.as_slice(),
            FiberMessageUnionReader::UpdateTlcInfo(item) => item.as_slice(),
            FiberMessageUnionReader::AddTlc(item) => item.as_slice(),
            FiberMessageUnionReader::RemoveTlc(item) => item.as_slice(),
            FiberMessageUnionReader::RevokeAndAck(item) => item.as_slice(),
            FiberMessageUnionReader::Shutdown(item) => item.as_slice(),
            FiberMessageUnionReader::ClosingSigned(item) => item.as_slice(),
            FiberMessageUnionReader::ReestablishChannel(item) => item.as_slice(),
            FiberMessageUnionReader::AnnouncementSignatures(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            FiberMessageUnionReader::OpenChannel(_) => 0,
            FiberMessageUnionReader::AcceptChannel(_) => 1,
            FiberMessageUnionReader::TxSignatures(_) => 2,
            FiberMessageUnionReader::TxUpdate(_) => 3,
            FiberMessageUnionReader::TxComplete(_) => 4,
            FiberMessageUnionReader::TxAbort(_) => 5,
            FiberMessageUnionReader::TxInitRBF(_) => 6,
            FiberMessageUnionReader::TxAckRBF(_) => 7,
            FiberMessageUnionReader::CommitmentSigned(_) => 8,
            FiberMessageUnionReader::ChannelReady(_) => 9,
            FiberMessageUnionReader::UpdateTlcInfo(_) => 10,
            FiberMessageUnionReader::AddTlc(_) => 11,
            FiberMessageUnionReader::RemoveTlc(_) => 12,
            FiberMessageUnionReader::RevokeAndAck(_) => 13,
            FiberMessageUnionReader::Shutdown(_) => 14,
            FiberMessageUnionReader::ClosingSigned(_) => 15,
            FiberMessageUnionReader::ReestablishChannel(_) => 16,
            FiberMessageUnionReader::AnnouncementSignatures(_) => 17,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            FiberMessageUnionReader::OpenChannel(_) => "OpenChannel",
            FiberMessageUnionReader::AcceptChannel(_) => "AcceptChannel",
            FiberMessageUnionReader::TxSignatures(_) => "TxSignatures",
            FiberMessageUnionReader::TxUpdate(_) => "TxUpdate",
            FiberMessageUnionReader::TxComplete(_) => "TxComplete",
            FiberMessageUnionReader::TxAbort(_) => "TxAbort",
            FiberMessageUnionReader::TxInitRBF(_) => "TxInitRBF",
            FiberMessageUnionReader::TxAckRBF(_) => "TxAckRBF",
            FiberMessageUnionReader::CommitmentSigned(_) => "CommitmentSigned",
            FiberMessageUnionReader::ChannelReady(_) => "ChannelReady",
            FiberMessageUnionReader::UpdateTlcInfo(_) => "UpdateTlcInfo",
            FiberMessageUnionReader::AddTlc(_) => "AddTlc",
            FiberMessageUnionReader::RemoveTlc(_) => "RemoveTlc",
            FiberMessageUnionReader::RevokeAndAck(_) => "RevokeAndAck",
            FiberMessageUnionReader::Shutdown(_) => "Shutdown",
            FiberMessageUnionReader::ClosingSigned(_) => "ClosingSigned",
            FiberMessageUnionReader::ReestablishChannel(_) => "ReestablishChannel",
            FiberMessageUnionReader::AnnouncementSignatures(_) => "AnnouncementSignatures",
        }
    }
}
impl From<OpenChannel> for FiberMessage {
    fn from(value: OpenChannel) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<AcceptChannel> for FiberMessage {
    fn from(value: AcceptChannel) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<TxSignatures> for FiberMessage {
    fn from(value: TxSignatures) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<TxUpdate> for FiberMessage {
    fn from(value: TxUpdate) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<TxComplete> for FiberMessage {
    fn from(value: TxComplete) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<TxAbort> for FiberMessage {
    fn from(value: TxAbort) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<TxInitRBF> for FiberMessage {
    fn from(value: TxInitRBF) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<TxAckRBF> for FiberMessage {
    fn from(value: TxAckRBF) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<CommitmentSigned> for FiberMessage {
    fn from(value: CommitmentSigned) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<ChannelReady> for FiberMessage {
    fn from(value: ChannelReady) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<UpdateTlcInfo> for FiberMessage {
    fn from(value: UpdateTlcInfo) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<AddTlc> for FiberMessage {
    fn from(value: AddTlc) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<RemoveTlc> for FiberMessage {
    fn from(value: RemoveTlc) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<RevokeAndAck> for FiberMessage {
    fn from(value: RevokeAndAck) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<Shutdown> for FiberMessage {
    fn from(value: Shutdown) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<ClosingSigned> for FiberMessage {
    fn from(value: ClosingSigned) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<ReestablishChannel> for FiberMessage {
    fn from(value: ReestablishChannel) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<AnnouncementSignatures> for FiberMessage {
    fn from(value: AnnouncementSignatures) -> Self {
        Self::new_builder().set(value).build()
    }
}
#[derive(Clone)]
pub struct PaymentPreimageOpt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for PaymentPreimageOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for PaymentPreimageOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for PaymentPreimageOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for PaymentPreimageOpt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        PaymentPreimageOpt::new_unchecked(v)
    }
}
impl PaymentPreimageOpt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Byte32> {
        if self.is_none() {
            None
        } else {
            Some(Byte32::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> PaymentPreimageOptReader<'r> {
        PaymentPreimageOptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for PaymentPreimageOpt {
    type Builder = PaymentPreimageOptBuilder;
    const NAME: &'static str = "PaymentPreimageOpt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        PaymentPreimageOpt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PaymentPreimageOptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PaymentPreimageOptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct PaymentPreimageOptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for PaymentPreimageOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for PaymentPreimageOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for PaymentPreimageOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> PaymentPreimageOptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Byte32Reader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(Byte32Reader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for PaymentPreimageOptReader<'r> {
    type Entity = PaymentPreimageOpt;
    const NAME: &'static str = "PaymentPreimageOptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        PaymentPreimageOptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            Byte32Reader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct PaymentPreimageOptBuilder(pub(crate) Option<Byte32>);
impl PaymentPreimageOptBuilder {
    pub fn set(mut self, v: Option<Byte32>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for PaymentPreimageOptBuilder {
    type Entity = PaymentPreimageOpt;
    const NAME: &'static str = "PaymentPreimageOptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        PaymentPreimageOpt::new_unchecked(inner.into())
    }
}
impl From<Byte32> for PaymentPreimageOpt {
    fn from(value: Byte32) -> Self {
        Self::new_builder().set(Some(value)).build()
    }
}
#[derive(Clone)]
pub struct PubkeyOpt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for PubkeyOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for PubkeyOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for PubkeyOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for PubkeyOpt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        PubkeyOpt::new_unchecked(v)
    }
}
impl PubkeyOpt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Pubkey> {
        if self.is_none() {
            None
        } else {
            Some(Pubkey::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> PubkeyOptReader<'r> {
        PubkeyOptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for PubkeyOpt {
    type Builder = PubkeyOptBuilder;
    const NAME: &'static str = "PubkeyOpt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        PubkeyOpt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PubkeyOptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PubkeyOptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct PubkeyOptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for PubkeyOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for PubkeyOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for PubkeyOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> PubkeyOptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<PubkeyReader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(PubkeyReader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for PubkeyOptReader<'r> {
    type Entity = PubkeyOpt;
    const NAME: &'static str = "PubkeyOptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        PubkeyOptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            PubkeyReader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct PubkeyOptBuilder(pub(crate) Option<Pubkey>);
impl PubkeyOptBuilder {
    pub fn set(mut self, v: Option<Pubkey>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for PubkeyOptBuilder {
    type Entity = PubkeyOpt;
    const NAME: &'static str = "PubkeyOptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        PubkeyOpt::new_unchecked(inner.into())
    }
}
impl From<Pubkey> for PubkeyOpt {
    fn from(value: Pubkey) -> Self {
        Self::new_builder().set(Some(value)).build()
    }
}
#[derive(Clone)]
pub struct PaymentHopData(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for PaymentHopData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for PaymentHopData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for PaymentHopData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "amount", self.amount())?;
        write!(f, ", {}: {}", "expiry", self.expiry())?;
        write!(f, ", {}: {}", "payment_preimage", self.payment_preimage())?;
        write!(f, ", {}: {}", "hash_algorithm", self.hash_algorithm())?;
        write!(f, ", {}: {}", "funding_tx_hash", self.funding_tx_hash())?;
        write!(f, ", {}: {}", "next_hop", self.next_hop())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for PaymentHopData {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        PaymentHopData::new_unchecked(v)
    }
}
impl PaymentHopData {
    const DEFAULT_VALUE: [u8; 85] = [
        85, 0, 0, 0, 28, 0, 0, 0, 44, 0, 0, 0, 52, 0, 0, 0, 52, 0, 0, 0, 53, 0, 0, 0, 85, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn amount(&self) -> Uint128 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint128::new_unchecked(self.0.slice(start..end))
    }
    pub fn expiry(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn payment_preimage(&self) -> PaymentPreimageOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        PaymentPreimageOpt::new_unchecked(self.0.slice(start..end))
    }
    pub fn hash_algorithm(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn funding_tx_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn next_hop(&self) -> PubkeyOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            PubkeyOpt::new_unchecked(self.0.slice(start..end))
        } else {
            PubkeyOpt::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> PaymentHopDataReader<'r> {
        PaymentHopDataReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for PaymentHopData {
    type Builder = PaymentHopDataBuilder;
    const NAME: &'static str = "PaymentHopData";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        PaymentHopData(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PaymentHopDataReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PaymentHopDataReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .amount(self.amount())
            .expiry(self.expiry())
            .payment_preimage(self.payment_preimage())
            .hash_algorithm(self.hash_algorithm())
            .funding_tx_hash(self.funding_tx_hash())
            .next_hop(self.next_hop())
    }
}
#[derive(Clone, Copy)]
pub struct PaymentHopDataReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for PaymentHopDataReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for PaymentHopDataReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for PaymentHopDataReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "amount", self.amount())?;
        write!(f, ", {}: {}", "expiry", self.expiry())?;
        write!(f, ", {}: {}", "payment_preimage", self.payment_preimage())?;
        write!(f, ", {}: {}", "hash_algorithm", self.hash_algorithm())?;
        write!(f, ", {}: {}", "funding_tx_hash", self.funding_tx_hash())?;
        write!(f, ", {}: {}", "next_hop", self.next_hop())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> PaymentHopDataReader<'r> {
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn amount(&self) -> Uint128Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint128Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn expiry(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn payment_preimage(&self) -> PaymentPreimageOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        PaymentPreimageOptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn hash_algorithm(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn funding_tx_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn next_hop(&self) -> PubkeyOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            PubkeyOptReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            PubkeyOptReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for PaymentHopDataReader<'r> {
    type Entity = PaymentHopData;
    const NAME: &'static str = "PaymentHopDataReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        PaymentHopDataReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint128Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint64Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        PaymentPreimageOptReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        ByteReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Byte32Reader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        PubkeyOptReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct PaymentHopDataBuilder {
    pub(crate) amount: Uint128,
    pub(crate) expiry: Uint64,
    pub(crate) payment_preimage: PaymentPreimageOpt,
    pub(crate) hash_algorithm: Byte,
    pub(crate) funding_tx_hash: Byte32,
    pub(crate) next_hop: PubkeyOpt,
}
impl PaymentHopDataBuilder {
    pub const FIELD_COUNT: usize = 6;
    pub fn amount(mut self, v: Uint128) -> Self {
        self.amount = v;
        self
    }
    pub fn expiry(mut self, v: Uint64) -> Self {
        self.expiry = v;
        self
    }
    pub fn payment_preimage(mut self, v: PaymentPreimageOpt) -> Self {
        self.payment_preimage = v;
        self
    }
    pub fn hash_algorithm(mut self, v: Byte) -> Self {
        self.hash_algorithm = v;
        self
    }
    pub fn funding_tx_hash(mut self, v: Byte32) -> Self {
        self.funding_tx_hash = v;
        self
    }
    pub fn next_hop(mut self, v: PubkeyOpt) -> Self {
        self.next_hop = v;
        self
    }
}
impl molecule::prelude::Builder for PaymentHopDataBuilder {
    type Entity = PaymentHopData;
    const NAME: &'static str = "PaymentHopDataBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.amount.as_slice().len()
            + self.expiry.as_slice().len()
            + self.payment_preimage.as_slice().len()
            + self.hash_algorithm.as_slice().len()
            + self.funding_tx_hash.as_slice().len()
            + self.next_hop.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.amount.as_slice().len();
        offsets.push(total_size);
        total_size += self.expiry.as_slice().len();
        offsets.push(total_size);
        total_size += self.payment_preimage.as_slice().len();
        offsets.push(total_size);
        total_size += self.hash_algorithm.as_slice().len();
        offsets.push(total_size);
        total_size += self.funding_tx_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.next_hop.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.amount.as_slice())?;
        writer.write_all(self.expiry.as_slice())?;
        writer.write_all(self.payment_preimage.as_slice())?;
        writer.write_all(self.hash_algorithm.as_slice())?;
        writer.write_all(self.funding_tx_hash.as_slice())?;
        writer.write_all(self.next_hop.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        PaymentHopData::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ChannelUpdate(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ChannelUpdate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ChannelUpdate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ChannelUpdate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "signature", self.signature())?;
        write!(f, ", {}: {}", "chain_hash", self.chain_hash())?;
        write!(f, ", {}: {}", "channel_outpoint", self.channel_outpoint())?;
        write!(f, ", {}: {}", "timestamp", self.timestamp())?;
        write!(f, ", {}: {}", "message_flags", self.message_flags())?;
        write!(f, ", {}: {}", "channel_flags", self.channel_flags())?;
        write!(f, ", {}: {}", "tlc_expiry_delta", self.tlc_expiry_delta())?;
        write!(f, ", {}: {}", "tlc_minimum_value", self.tlc_minimum_value())?;
        write!(f, ", {}: {}", "tlc_maximum_value", self.tlc_maximum_value())?;
        write!(
            f,
            ", {}: {}",
            "tlc_fee_proportional_millionths",
            self.tlc_fee_proportional_millionths()
        )?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for ChannelUpdate {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        ChannelUpdate::new_unchecked(v)
    }
}
impl ChannelUpdate {
    const DEFAULT_VALUE: [u8; 204] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const TOTAL_SIZE: usize = 204;
    pub const FIELD_SIZES: [usize; 10] = [64, 32, 36, 8, 4, 4, 8, 16, 16, 16];
    pub const FIELD_COUNT: usize = 10;
    pub fn signature(&self) -> EcdsaSignature {
        EcdsaSignature::new_unchecked(self.0.slice(0..64))
    }
    pub fn chain_hash(&self) -> Byte32 {
        Byte32::new_unchecked(self.0.slice(64..96))
    }
    pub fn channel_outpoint(&self) -> OutPoint {
        OutPoint::new_unchecked(self.0.slice(96..132))
    }
    pub fn timestamp(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(132..140))
    }
    pub fn message_flags(&self) -> Uint32 {
        Uint32::new_unchecked(self.0.slice(140..144))
    }
    pub fn channel_flags(&self) -> Uint32 {
        Uint32::new_unchecked(self.0.slice(144..148))
    }
    pub fn tlc_expiry_delta(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(148..156))
    }
    pub fn tlc_minimum_value(&self) -> Uint128 {
        Uint128::new_unchecked(self.0.slice(156..172))
    }
    pub fn tlc_maximum_value(&self) -> Uint128 {
        Uint128::new_unchecked(self.0.slice(172..188))
    }
    pub fn tlc_fee_proportional_millionths(&self) -> Uint128 {
        Uint128::new_unchecked(self.0.slice(188..204))
    }
    pub fn as_reader<'r>(&'r self) -> ChannelUpdateReader<'r> {
        ChannelUpdateReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ChannelUpdate {
    type Builder = ChannelUpdateBuilder;
    const NAME: &'static str = "ChannelUpdate";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ChannelUpdate(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelUpdateReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelUpdateReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .signature(self.signature())
            .chain_hash(self.chain_hash())
            .channel_outpoint(self.channel_outpoint())
            .timestamp(self.timestamp())
            .message_flags(self.message_flags())
            .channel_flags(self.channel_flags())
            .tlc_expiry_delta(self.tlc_expiry_delta())
            .tlc_minimum_value(self.tlc_minimum_value())
            .tlc_maximum_value(self.tlc_maximum_value())
            .tlc_fee_proportional_millionths(self.tlc_fee_proportional_millionths())
    }
}
#[derive(Clone, Copy)]
pub struct ChannelUpdateReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ChannelUpdateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ChannelUpdateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ChannelUpdateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "signature", self.signature())?;
        write!(f, ", {}: {}", "chain_hash", self.chain_hash())?;
        write!(f, ", {}: {}", "channel_outpoint", self.channel_outpoint())?;
        write!(f, ", {}: {}", "timestamp", self.timestamp())?;
        write!(f, ", {}: {}", "message_flags", self.message_flags())?;
        write!(f, ", {}: {}", "channel_flags", self.channel_flags())?;
        write!(f, ", {}: {}", "tlc_expiry_delta", self.tlc_expiry_delta())?;
        write!(f, ", {}: {}", "tlc_minimum_value", self.tlc_minimum_value())?;
        write!(f, ", {}: {}", "tlc_maximum_value", self.tlc_maximum_value())?;
        write!(
            f,
            ", {}: {}",
            "tlc_fee_proportional_millionths",
            self.tlc_fee_proportional_millionths()
        )?;
        write!(f, " }}")
    }
}
impl<'r> ChannelUpdateReader<'r> {
    pub const TOTAL_SIZE: usize = 204;
    pub const FIELD_SIZES: [usize; 10] = [64, 32, 36, 8, 4, 4, 8, 16, 16, 16];
    pub const FIELD_COUNT: usize = 10;
    pub fn signature(&self) -> EcdsaSignatureReader<'r> {
        EcdsaSignatureReader::new_unchecked(&self.as_slice()[0..64])
    }
    pub fn chain_hash(&self) -> Byte32Reader<'r> {
        Byte32Reader::new_unchecked(&self.as_slice()[64..96])
    }
    pub fn channel_outpoint(&self) -> OutPointReader<'r> {
        OutPointReader::new_unchecked(&self.as_slice()[96..132])
    }
    pub fn timestamp(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[132..140])
    }
    pub fn message_flags(&self) -> Uint32Reader<'r> {
        Uint32Reader::new_unchecked(&self.as_slice()[140..144])
    }
    pub fn channel_flags(&self) -> Uint32Reader<'r> {
        Uint32Reader::new_unchecked(&self.as_slice()[144..148])
    }
    pub fn tlc_expiry_delta(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[148..156])
    }
    pub fn tlc_minimum_value(&self) -> Uint128Reader<'r> {
        Uint128Reader::new_unchecked(&self.as_slice()[156..172])
    }
    pub fn tlc_maximum_value(&self) -> Uint128Reader<'r> {
        Uint128Reader::new_unchecked(&self.as_slice()[172..188])
    }
    pub fn tlc_fee_proportional_millionths(&self) -> Uint128Reader<'r> {
        Uint128Reader::new_unchecked(&self.as_slice()[188..204])
    }
}
impl<'r> molecule::prelude::Reader<'r> for ChannelUpdateReader<'r> {
    type Entity = ChannelUpdate;
    const NAME: &'static str = "ChannelUpdateReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ChannelUpdateReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct ChannelUpdateBuilder {
    pub(crate) signature: EcdsaSignature,
    pub(crate) chain_hash: Byte32,
    pub(crate) channel_outpoint: OutPoint,
    pub(crate) timestamp: Uint64,
    pub(crate) message_flags: Uint32,
    pub(crate) channel_flags: Uint32,
    pub(crate) tlc_expiry_delta: Uint64,
    pub(crate) tlc_minimum_value: Uint128,
    pub(crate) tlc_maximum_value: Uint128,
    pub(crate) tlc_fee_proportional_millionths: Uint128,
}
impl ChannelUpdateBuilder {
    pub const TOTAL_SIZE: usize = 204;
    pub const FIELD_SIZES: [usize; 10] = [64, 32, 36, 8, 4, 4, 8, 16, 16, 16];
    pub const FIELD_COUNT: usize = 10;
    pub fn signature(mut self, v: EcdsaSignature) -> Self {
        self.signature = v;
        self
    }
    pub fn chain_hash(mut self, v: Byte32) -> Self {
        self.chain_hash = v;
        self
    }
    pub fn channel_outpoint(mut self, v: OutPoint) -> Self {
        self.channel_outpoint = v;
        self
    }
    pub fn timestamp(mut self, v: Uint64) -> Self {
        self.timestamp = v;
        self
    }
    pub fn message_flags(mut self, v: Uint32) -> Self {
        self.message_flags = v;
        self
    }
    pub fn channel_flags(mut self, v: Uint32) -> Self {
        self.channel_flags = v;
        self
    }
    pub fn tlc_expiry_delta(mut self, v: Uint64) -> Self {
        self.tlc_expiry_delta = v;
        self
    }
    pub fn tlc_minimum_value(mut self, v: Uint128) -> Self {
        self.tlc_minimum_value = v;
        self
    }
    pub fn tlc_maximum_value(mut self, v: Uint128) -> Self {
        self.tlc_maximum_value = v;
        self
    }
    pub fn tlc_fee_proportional_millionths(mut self, v: Uint128) -> Self {
        self.tlc_fee_proportional_millionths = v;
        self
    }
}
impl molecule::prelude::Builder for ChannelUpdateBuilder {
    type Entity = ChannelUpdate;
    const NAME: &'static str = "ChannelUpdateBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.signature.as_slice())?;
        writer.write_all(self.chain_hash.as_slice())?;
        writer.write_all(self.channel_outpoint.as_slice())?;
        writer.write_all(self.timestamp.as_slice())?;
        writer.write_all(self.message_flags.as_slice())?;
        writer.write_all(self.channel_flags.as_slice())?;
        writer.write_all(self.tlc_expiry_delta.as_slice())?;
        writer.write_all(self.tlc_minimum_value.as_slice())?;
        writer.write_all(self.tlc_maximum_value.as_slice())?;
        writer.write_all(self.tlc_fee_proportional_millionths.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ChannelUpdate::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ChannelUpdateOpt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ChannelUpdateOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ChannelUpdateOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ChannelUpdateOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for ChannelUpdateOpt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        ChannelUpdateOpt::new_unchecked(v)
    }
}
impl ChannelUpdateOpt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<ChannelUpdate> {
        if self.is_none() {
            None
        } else {
            Some(ChannelUpdate::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ChannelUpdateOptReader<'r> {
        ChannelUpdateOptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ChannelUpdateOpt {
    type Builder = ChannelUpdateOptBuilder;
    const NAME: &'static str = "ChannelUpdateOpt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ChannelUpdateOpt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelUpdateOptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelUpdateOptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct ChannelUpdateOptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ChannelUpdateOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ChannelUpdateOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ChannelUpdateOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> ChannelUpdateOptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<ChannelUpdateReader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(ChannelUpdateReader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ChannelUpdateOptReader<'r> {
    type Entity = ChannelUpdateOpt;
    const NAME: &'static str = "ChannelUpdateOptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ChannelUpdateOptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            ChannelUpdateReader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct ChannelUpdateOptBuilder(pub(crate) Option<ChannelUpdate>);
impl ChannelUpdateOptBuilder {
    pub fn set(mut self, v: Option<ChannelUpdate>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for ChannelUpdateOptBuilder {
    type Entity = ChannelUpdateOpt;
    const NAME: &'static str = "ChannelUpdateOptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ChannelUpdateOpt::new_unchecked(inner.into())
    }
}
impl From<ChannelUpdate> for ChannelUpdateOpt {
    fn from(value: ChannelUpdate) -> Self {
        Self::new_builder().set(Some(value)).build()
    }
}
#[derive(Clone)]
pub struct ChannelFailed(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ChannelFailed {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ChannelFailed {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ChannelFailed {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_outpoint", self.channel_outpoint())?;
        write!(f, ", {}: {}", "channel_update", self.channel_update())?;
        write!(f, ", {}: {}", "node_id", self.node_id())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ChannelFailed {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        ChannelFailed::new_unchecked(v)
    }
}
impl ChannelFailed {
    const DEFAULT_VALUE: [u8; 85] = [
        85, 0, 0, 0, 16, 0, 0, 0, 52, 0, 0, 0, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_outpoint(&self) -> OutPoint {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        OutPoint::new_unchecked(self.0.slice(start..end))
    }
    pub fn channel_update(&self) -> ChannelUpdateOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        ChannelUpdateOpt::new_unchecked(self.0.slice(start..end))
    }
    pub fn node_id(&self) -> Pubkey {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Pubkey::new_unchecked(self.0.slice(start..end))
        } else {
            Pubkey::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ChannelFailedReader<'r> {
        ChannelFailedReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ChannelFailed {
    type Builder = ChannelFailedBuilder;
    const NAME: &'static str = "ChannelFailed";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ChannelFailed(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelFailedReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelFailedReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .channel_outpoint(self.channel_outpoint())
            .channel_update(self.channel_update())
            .node_id(self.node_id())
    }
}
#[derive(Clone, Copy)]
pub struct ChannelFailedReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ChannelFailedReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ChannelFailedReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ChannelFailedReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_outpoint", self.channel_outpoint())?;
        write!(f, ", {}: {}", "channel_update", self.channel_update())?;
        write!(f, ", {}: {}", "node_id", self.node_id())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ChannelFailedReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_outpoint(&self) -> OutPointReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        OutPointReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn channel_update(&self) -> ChannelUpdateOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        ChannelUpdateOptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn node_id(&self) -> PubkeyReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            PubkeyReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            PubkeyReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ChannelFailedReader<'r> {
    type Entity = ChannelFailed;
    const NAME: &'static str = "ChannelFailedReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ChannelFailedReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        OutPointReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        ChannelUpdateOptReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        PubkeyReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct ChannelFailedBuilder {
    pub(crate) channel_outpoint: OutPoint,
    pub(crate) channel_update: ChannelUpdateOpt,
    pub(crate) node_id: Pubkey,
}
impl ChannelFailedBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn channel_outpoint(mut self, v: OutPoint) -> Self {
        self.channel_outpoint = v;
        self
    }
    pub fn channel_update(mut self, v: ChannelUpdateOpt) -> Self {
        self.channel_update = v;
        self
    }
    pub fn node_id(mut self, v: Pubkey) -> Self {
        self.node_id = v;
        self
    }
}
impl molecule::prelude::Builder for ChannelFailedBuilder {
    type Entity = ChannelFailed;
    const NAME: &'static str = "ChannelFailedBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.channel_outpoint.as_slice().len()
            + self.channel_update.as_slice().len()
            + self.node_id.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.channel_outpoint.as_slice().len();
        offsets.push(total_size);
        total_size += self.channel_update.as_slice().len();
        offsets.push(total_size);
        total_size += self.node_id.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.channel_outpoint.as_slice())?;
        writer.write_all(self.channel_update.as_slice())?;
        writer.write_all(self.node_id.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ChannelFailed::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct NodeFailed(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for NodeFailed {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for NodeFailed {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for NodeFailed {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "node_id", self.node_id())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for NodeFailed {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        NodeFailed::new_unchecked(v)
    }
}
impl NodeFailed {
    const DEFAULT_VALUE: [u8; 41] = [
        41, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn node_id(&self) -> Pubkey {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Pubkey::new_unchecked(self.0.slice(start..end))
        } else {
            Pubkey::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> NodeFailedReader<'r> {
        NodeFailedReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for NodeFailed {
    type Builder = NodeFailedBuilder;
    const NAME: &'static str = "NodeFailed";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        NodeFailed(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NodeFailedReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NodeFailedReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().node_id(self.node_id())
    }
}
#[derive(Clone, Copy)]
pub struct NodeFailedReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for NodeFailedReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for NodeFailedReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for NodeFailedReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "node_id", self.node_id())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> NodeFailedReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn node_id(&self) -> PubkeyReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            PubkeyReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            PubkeyReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for NodeFailedReader<'r> {
    type Entity = NodeFailed;
    const NAME: &'static str = "NodeFailedReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        NodeFailedReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        PubkeyReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct NodeFailedBuilder {
    pub(crate) node_id: Pubkey,
}
impl NodeFailedBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn node_id(mut self, v: Pubkey) -> Self {
        self.node_id = v;
        self
    }
}
impl molecule::prelude::Builder for NodeFailedBuilder {
    type Entity = NodeFailed;
    const NAME: &'static str = "NodeFailedBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.node_id.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.node_id.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.node_id.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        NodeFailed::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TlcErrData(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TlcErrData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TlcErrData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TlcErrData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for TlcErrData {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TlcErrData::new_unchecked(v)
    }
}
impl TlcErrData {
    const DEFAULT_VALUE: [u8; 89] = [
        0, 0, 0, 0, 85, 0, 0, 0, 16, 0, 0, 0, 52, 0, 0, 0, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const ITEMS_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> TlcErrDataUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => ChannelFailed::new_unchecked(inner).into(),
            1 => NodeFailed::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> TlcErrDataReader<'r> {
        TlcErrDataReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TlcErrData {
    type Builder = TlcErrDataBuilder;
    const NAME: &'static str = "TlcErrData";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TlcErrData(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TlcErrDataReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TlcErrDataReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct TlcErrDataReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TlcErrDataReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TlcErrDataReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TlcErrDataReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> TlcErrDataReader<'r> {
    pub const ITEMS_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> TlcErrDataUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => ChannelFailedReader::new_unchecked(inner).into(),
            1 => NodeFailedReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TlcErrDataReader<'r> {
    type Entity = TlcErrData;
    const NAME: &'static str = "TlcErrDataReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TlcErrDataReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => ChannelFailedReader::verify(inner_slice, compatible),
            1 => NodeFailedReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TlcErrDataBuilder(pub(crate) TlcErrDataUnion);
impl TlcErrDataBuilder {
    pub const ITEMS_COUNT: usize = 2;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<TlcErrDataUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for TlcErrDataBuilder {
    type Entity = TlcErrData;
    const NAME: &'static str = "TlcErrDataBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TlcErrData::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum TlcErrDataUnion {
    ChannelFailed(ChannelFailed),
    NodeFailed(NodeFailed),
}
#[derive(Debug, Clone, Copy)]
pub enum TlcErrDataUnionReader<'r> {
    ChannelFailed(ChannelFailedReader<'r>),
    NodeFailed(NodeFailedReader<'r>),
}
impl ::core::default::Default for TlcErrDataUnion {
    fn default() -> Self {
        TlcErrDataUnion::ChannelFailed(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for TlcErrDataUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            TlcErrDataUnion::ChannelFailed(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ChannelFailed::NAME, item)
            }
            TlcErrDataUnion::NodeFailed(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, NodeFailed::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for TlcErrDataUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            TlcErrDataUnionReader::ChannelFailed(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ChannelFailed::NAME, item)
            }
            TlcErrDataUnionReader::NodeFailed(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, NodeFailed::NAME, item)
            }
        }
    }
}
impl TlcErrDataUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            TlcErrDataUnion::ChannelFailed(ref item) => write!(f, "{}", item),
            TlcErrDataUnion::NodeFailed(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> TlcErrDataUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            TlcErrDataUnionReader::ChannelFailed(ref item) => write!(f, "{}", item),
            TlcErrDataUnionReader::NodeFailed(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<ChannelFailed> for TlcErrDataUnion {
    fn from(item: ChannelFailed) -> Self {
        TlcErrDataUnion::ChannelFailed(item)
    }
}
impl ::core::convert::From<NodeFailed> for TlcErrDataUnion {
    fn from(item: NodeFailed) -> Self {
        TlcErrDataUnion::NodeFailed(item)
    }
}
impl<'r> ::core::convert::From<ChannelFailedReader<'r>> for TlcErrDataUnionReader<'r> {
    fn from(item: ChannelFailedReader<'r>) -> Self {
        TlcErrDataUnionReader::ChannelFailed(item)
    }
}
impl<'r> ::core::convert::From<NodeFailedReader<'r>> for TlcErrDataUnionReader<'r> {
    fn from(item: NodeFailedReader<'r>) -> Self {
        TlcErrDataUnionReader::NodeFailed(item)
    }
}
impl TlcErrDataUnion {
    pub const NAME: &'static str = "TlcErrDataUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            TlcErrDataUnion::ChannelFailed(item) => item.as_bytes(),
            TlcErrDataUnion::NodeFailed(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            TlcErrDataUnion::ChannelFailed(item) => item.as_slice(),
            TlcErrDataUnion::NodeFailed(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            TlcErrDataUnion::ChannelFailed(_) => 0,
            TlcErrDataUnion::NodeFailed(_) => 1,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            TlcErrDataUnion::ChannelFailed(_) => "ChannelFailed",
            TlcErrDataUnion::NodeFailed(_) => "NodeFailed",
        }
    }
    pub fn as_reader<'r>(&'r self) -> TlcErrDataUnionReader<'r> {
        match self {
            TlcErrDataUnion::ChannelFailed(item) => item.as_reader().into(),
            TlcErrDataUnion::NodeFailed(item) => item.as_reader().into(),
        }
    }
}
impl<'r> TlcErrDataUnionReader<'r> {
    pub const NAME: &'r str = "TlcErrDataUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            TlcErrDataUnionReader::ChannelFailed(item) => item.as_slice(),
            TlcErrDataUnionReader::NodeFailed(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            TlcErrDataUnionReader::ChannelFailed(_) => 0,
            TlcErrDataUnionReader::NodeFailed(_) => 1,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            TlcErrDataUnionReader::ChannelFailed(_) => "ChannelFailed",
            TlcErrDataUnionReader::NodeFailed(_) => "NodeFailed",
        }
    }
}
impl From<ChannelFailed> for TlcErrData {
    fn from(value: ChannelFailed) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<NodeFailed> for TlcErrData {
    fn from(value: NodeFailed) -> Self {
        Self::new_builder().set(value).build()
    }
}
#[derive(Clone)]
pub struct TlcErrDataOpt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TlcErrDataOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TlcErrDataOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TlcErrDataOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for TlcErrDataOpt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TlcErrDataOpt::new_unchecked(v)
    }
}
impl TlcErrDataOpt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<TlcErrData> {
        if self.is_none() {
            None
        } else {
            Some(TlcErrData::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TlcErrDataOptReader<'r> {
        TlcErrDataOptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TlcErrDataOpt {
    type Builder = TlcErrDataOptBuilder;
    const NAME: &'static str = "TlcErrDataOpt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TlcErrDataOpt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TlcErrDataOptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TlcErrDataOptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct TlcErrDataOptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TlcErrDataOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TlcErrDataOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TlcErrDataOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> TlcErrDataOptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<TlcErrDataReader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(TlcErrDataReader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TlcErrDataOptReader<'r> {
    type Entity = TlcErrDataOpt;
    const NAME: &'static str = "TlcErrDataOptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TlcErrDataOptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            TlcErrDataReader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TlcErrDataOptBuilder(pub(crate) Option<TlcErrData>);
impl TlcErrDataOptBuilder {
    pub fn set(mut self, v: Option<TlcErrData>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for TlcErrDataOptBuilder {
    type Entity = TlcErrDataOpt;
    const NAME: &'static str = "TlcErrDataOptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TlcErrDataOpt::new_unchecked(inner.into())
    }
}
impl From<TlcErrData> for TlcErrDataOpt {
    fn from(value: TlcErrData) -> Self {
        Self::new_builder().set(Some(value)).build()
    }
}
#[derive(Clone)]
pub struct TlcErr(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TlcErr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TlcErr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TlcErr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "error_code", self.error_code())?;
        write!(f, ", {}: {}", "extra_data", self.extra_data())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TlcErr {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TlcErr::new_unchecked(v)
    }
}
impl TlcErr {
    const DEFAULT_VALUE: [u8; 14] = [14, 0, 0, 0, 12, 0, 0, 0, 14, 0, 0, 0, 0, 0];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn error_code(&self) -> Uint16 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint16::new_unchecked(self.0.slice(start..end))
    }
    pub fn extra_data(&self) -> TlcErrDataOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            TlcErrDataOpt::new_unchecked(self.0.slice(start..end))
        } else {
            TlcErrDataOpt::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TlcErrReader<'r> {
        TlcErrReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TlcErr {
    type Builder = TlcErrBuilder;
    const NAME: &'static str = "TlcErr";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TlcErr(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TlcErrReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TlcErrReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .error_code(self.error_code())
            .extra_data(self.extra_data())
    }
}
#[derive(Clone, Copy)]
pub struct TlcErrReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TlcErrReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TlcErrReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TlcErrReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "error_code", self.error_code())?;
        write!(f, ", {}: {}", "extra_data", self.extra_data())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TlcErrReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn error_code(&self) -> Uint16Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint16Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn extra_data(&self) -> TlcErrDataOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            TlcErrDataOptReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            TlcErrDataOptReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TlcErrReader<'r> {
    type Entity = TlcErr;
    const NAME: &'static str = "TlcErrReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TlcErrReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint16Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        TlcErrDataOptReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TlcErrBuilder {
    pub(crate) error_code: Uint16,
    pub(crate) extra_data: TlcErrDataOpt,
}
impl TlcErrBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn error_code(mut self, v: Uint16) -> Self {
        self.error_code = v;
        self
    }
    pub fn extra_data(mut self, v: TlcErrDataOpt) -> Self {
        self.extra_data = v;
        self
    }
}
impl molecule::prelude::Builder for TlcErrBuilder {
    type Entity = TlcErr;
    const NAME: &'static str = "TlcErrBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.error_code.as_slice().len()
            + self.extra_data.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.error_code.as_slice().len();
        offsets.push(total_size);
        total_size += self.extra_data.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.error_code.as_slice())?;
        writer.write_all(self.extra_data.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TlcErr::new_unchecked(inner.into())
    }
}
